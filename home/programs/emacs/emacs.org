#+title: Emacs Configuration
#+author: icurry
#+language: en
#+options: toc:2 num:t author:t
#+startup: show2levels

* Introduction and Overview

* Initialization of Emacs (=init.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./init.el
:END:

** Emacs Version Check

I have not tested this config on any emacs version less than 29.1.

#+begin_src emacs-lisp
  ;; ===Check Emacs Version===
  (when (version< emacs-version "29.1")
    (error "This setup is only guarunteed to work on 29.1, disable this line to load anyways."))
#+end_src

** Some Basic Settings

These are some basic settings that don't really fit anywhere else in my config.

#+begin_src emacs-lisp
  ;; ===Basic Settings===
  (setq frame-title-format "%b")      ;; Set window title to buffer name
  (setq initial-scratch-message ";; Scratch Buffer\n\n")
  (setq initial-buffer-choice t)      ;; Scratch as initial buffer
  (setq make-backup-files nil)        ;; No more file~ everywhere
  (setq inhibit-startup-message t)    ;; Starts on blank screen
  (scroll-bar-mode -1)                ;; Disable visible scrollbar
  (tool-bar-mode -1)                  ;; Disable tool bar
  (menu-bar-mode -1)                  ;; Disable menu bar
  (tooltip-mode -1)                   ;; Disable tooltips
  (set-fringe-mode 10)                ;; No idea what this does
#+end_src

** Enabling Disabled Functions

These functions I want enabled and not asking me if I want to run the command every single time.

#+begin_src emacs-lisp
  ;; ===Enable Disabled Functions===
  (dolist (c '(narrow-to-region narrow-to-page upcase-region downcase-region))
    (put c 'disabled nil))
#+end_src

** "Disabling" Custom

Set it to a temp file so I don't have to deal with custom, lol.

#+begin_src emacs-lisp
  ;; ===Disable Custom===
  (setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Package.el and Package Archives

This is only used if I find myself on a non-nixos system, as I have nixos manage my emacs packages instead.

#+begin_src emacs-lisp
  ;; ===Package Initialization===
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/"))) ;; Setting Repos
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

** Use-package

Setting up use package. Not sure if all of this is necessary now since ~use-package~ comes with base emacs now.

#+begin_src emacs-lisp
  ;; ===use-package Initialization===
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

** Configuration modules.

First, I add the =cur-lisp= and =cur-config= to the ~load-path~. Then its just as simple as ~(require 'module)~.

#+begin_src emacs-lisp
  ;; ===Load Modules and Packages===
  (dolist (path '("cur-lisp" "cur-config"))
    (add-to-list 'load-path (locate-user-emacs-file path)))

  ;; =====================
  ;; == Loading Modules ==
  ;; =====================

  ;; ===Essentials===
  (require 'cur-config-essentials)
  (require 'cur-config-search)
  (require 'cur-config-bindings)
  (require 'cur-config-help)
  (require 'cur-config-dired)

  ;; ===Interfaces===
  (require 'cur-config-faces)
  (require 'cur-config-completion)
  (require 'cur-config-window)
  (require 'cur-modeline)

  ;; ===Languages===
  (require 'cur-config-ide)
  (require 'cur-config-lisp)
  (require 'cur-config-java)
  (require 'cur-config-markup)
  (require 'cur-config-nix)
  (require 'cur-config-rust)
  (require 'cur-config-haskell)
  (require 'cur-config-c)
  (require 'cur-config-zig)
  (require 'cur-config-go)

  ;; ===Terminal Apps===
  (require 'cur-config-shell)

  ;; ===Word Processing===
  (require 'cur-config-org)

  ;; ===Misc===
  (require 'cur-config-smol-net)
  (require 'cur-config-elcord)

  ;; ===Direnv is Last===
  (require 'cur-config-direnv)

  (provide 'init)
#+end_src

* Configuration Modules (=cur-config=)

** Essential configuration (=cur-config-essentials.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-essentials.el
:END:

These are the basic configurations that I have done in emacs. Its sort of a hodge-podge of fixing/changing things that are built emacs. They aren't strictly essential so the name is kind of a misnomer.

*** Parentheses highlighting

Removing the weird delay for highlighting the opposite parenthesis.

#+begin_src emacs-lisp
  ;; ===Parens===
  (use-package paren
    :ensure nil
    :demand t
    :custom
    (show-paren-delay 0 "No delay for paren highlighting"))
#+end_src

*** Line numbers

I like having absolute line numbers, especially since the meow number selection makes relative line numbers not as useful. Some modes, especially terminal and shell modes, look weird with line numbers so I disable them. Org-mode also has them disabled because they make the document look kind of weird, especially with images or non-text.

#+begin_src emacs-lisp
  ;; ===Line Numbers===
  (column-number-mode)
  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type t)
  ;; Disable line numbers for terminal modes
  (dolist (mode '(org-mode-hook
                  dired-mode-hook
                  term-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  eshell-mode-hook
                  eat-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  (provide 'cur-config-essentials)
#+end_src

** Search configuration (=cur-config-search.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-search.el
:END:

#+begin_src emacs-lisp
  (use-package isearch
    :custom
    (isearch-wrap-pause 'no-ding)
    (isearch-repeat-on-direction-change t))

  (provide 'cur-config-search)
#+end_src

** Key bindings configurations (=cur-config-bindings.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-bindings.el
:END:

I use [[https:github.com/meow-edit/meow][meow]], a modal editing layer designed to be integrate well into emacs. It's very easy to hack on and extend and just feels more emacsy. I have had almost no issues with this, compared to evil which just felt sluggish and was hard to customize. The object-verb syntax is also really great and I prefer it to the verb-object of vim/nvim.

*** Hydra 

I use hydras for repeat keybindings. I plan to switch to use the built in repeat keymap more in the future but they are very helpful for creating something almost like a mini meow state, just for one particular task.

#+begin_src emacs-lisp
  ;; ===Hydra===
  (use-package hydra
    :demand t)
#+end_src

*** Meow

This is the meat and potatoes of my keybindings. First I have several keymaps: sub-leader, projectile, toggle, and alignment. Sub leader is for more miscellaneous one-off commands, such as ~ibuffer~. Projectile is for, you guessed it, projectile related commands. Toggle is for quick, on the fly, changing of settings, such as the font size. The alignment is currently unused as of now but will have commands to change how text is currently being viewed without actually modifying the text of the buffer, think ~recenter-top-bottom~ like commands and more.

I try to keep the leader key map as static as possible, with no keybindings being changed with the mode. If I want something to change with the mode I will put it under C-c, which I can access from =RET= via normal mode. The leader key primarily has things for interacting with general emacs constructs, like buffers, universal arg, =M-x=, etc.

The meow states, what vim/nvim call modes, are as follows:
  - *Normal* - The main state that is used. Used for navigation, selection, and editing. Basically vim's normal and visual mode in one.
  - *Insert* - Insert text, esc to go back to normal state.
  - *Motion* - A minimal state used when you don't know what the major-mode does. I have only =j=, =k=, and =SPC= bound to down, up, and leader respectively. Everything else is as the major mode defines it. It's just there so I'm still able to interface with emacs like I normally would, just with a minimal interface.
  - *Keypad* - Leader key map.
  - *Beacon* - Multi-cursor in a region. Very convenient but kmacros are GOATed.

Also of note, I find it easier to think about the cursor in normal mode as being a single character selection. This is how helix does it and I really like it so I have a lot of the meow fallback commands to operate on the char after the cursor.

A cheatsheet for the normal state can be accessed via =M-x meow-cheatsheet RET=.
  
#+begin_src emacs-lisp
  ;; ===Meow Setup===
  (use-package meow
    :after (hydra)
    :demand t
    :preface
    (defvar cur/sub-leader-keymap
      (let ((map (make-sparse-keymap)))
        map)
      "The keymap for quick command/function execution.")
    (defvar cur/projectile-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for projectile command execution from the leader key.")
    (defvar cur/toggle-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for commands that change settings from the leader key.")
    (defvar cur/alignment-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for commands that change alignment and cursor display.")
    (defun cur/kmacro-toggle ()
      (interactive)
      (cond
       (defining-kbd-macro
        (call-interactively #'meow-end-kmacro))
       (t
        (call-interactively #'meow-start-kmacro))))
    (defhydra cur/window (:hint nil)
      "
  ^Movement^            ^Splitting^               ^Manipulation
  ^--------^------------^---------^---------------^--------------
  _h_: left             _1_: only window          _H_: swap left
  _j_: down             _2_: split vertical       _J_: swap down
  _k_: up               _3_: split horizontal     _K_: swap up
  _l_: right            _0_: close window         _L_: swap right
  _o_: other window
  "
      ("RET" ignore "finished" :exit t)
      ("w" other-window "other window" :exit t)
      ("." delete-other-windows "only window" :exit t)
      ("f" find-file-other-window "file in new window" :exit t)
      ("v" split-window-right "split vertical" :exit t)
      (";" split-window-below "split horizontal" :exit t)
      ("c" delete-window "delete window" :exit t)

      ("o" other-window)
      ("h" windmove-left)
      ("j" windmove-down)
      ("k" windmove-up)
      ("l" windmove-right)

      ("1" delete-other-windows)
      ("2" split-window-right)
      ("3" split-window-below)
      ("0" delete-window)

      ("H" windmove-swap-states-left)
      ("J" windmove-swap-states-down)
      ("K" windmove-swap-states-up)
      ("L" windmove-swap-states-right))
    (defhydra cur/goto (:hint nil)
      "
  _g_:  goto line         _a_:  beginning of line     _,_: buffer start     _n_: next buffer hydra
  _s_: to indentation     _e_:  end of line           _._: buffer end       _p_: prev buffer hydra
  "
      ("g" meow-goto-line :exit t)
      ("a" move-beginning-of-line :exit t)
      ("e" move-end-of-line :exit t)
      ("m" back-to-indentation :exit t)
      ("s" back-to-indentation :exit t)
      ("," beginning-of-buffer :exit t)
      ("." end-of-buffer :exit t)
      ("n" cur/hydra-buffer-cycle/next-buffer :exit t)
      ("p" cur/hydra-buffer-cycle/previous-buffer :exit t))
    (defun meow-setup ()
      (meow-motion-overwrite-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("<escape>" . ignore))
      (meow-leader-define-key
       ;; ===Top Row===
       '("1" . delete-other-windows)
       '("2" . split-window-right)
       '("3" . split-window-below)
       ;'("4" . )
       ;'("5" . )
       ;'("6" . )
       ;'("7" . )
       ;'("8" . )
       ;'("9" . )
       '("0" . "C-x 0") ; delete window

       ;; ===2nd Row===
       ;'("TAB"  . )
       '("q" . "M-;") ; comment dwim
       '("w" . cur/window/body)
       ;'("e" . )
       '("r" . query-replace)
       (cons "t" cur/toggle-map)
       ;'("y" . )
       '("u" . "C-u")   ; universal argument
       '("i" . "M-g i") ; imenu
       '("o" . "C-x o") ; other window
       (cons "p" cur/projectile-map)
       ;'("-" . )

       ;; ===3rd Row===
       ;'("<escape>" . )
       ;'("a" . )
       '("s" . "C-x C-s") ; save buffer
       '("d" . kill-current-buffer)
       '("f" . "C-x C-f") ; find file
       ;'("g" . ) ; C-M- map
       ;'("h" . ) ; C-h map
       ;'("j" . )
       ;'("k" . )
       ;'("l" . )
       (cons ";" cur/sub-leader-keymap)
       '("RET"   . "M-x")

       ;; ===4th Row===
       (cons "z" cur/alignment-map)
       ;'("x" . ) ; C-x map
       ;'("c" . ) ; C-c map
       ;'("v" . )
       '("b" . "C-x b")
       ;'("n" . )
       ;'("m" . ) ; M- map
       '("," . meow-bounds-of-thing)
       '("." . meow-inner-of-thing)
       '("/" . rg)
       ;'("'"  . )
       )
      (meow-normal-define-key
       ;; ===Top Row===
       '("1" . meow-expand-1)
       ;'("!" . )
       '("2" . meow-expand-2)
       ;'("@" . )
       '("3" . meow-expand-3)
       ;'("#" . )
       '("4" . meow-expand-4)
       ;'("$" . )
       '("5" . meow-expand-5)
       ;'("%" . )
       '("6" . meow-expand-6)
       ;'("^" . )
       '("7" . meow-expand-7)
       ;'("&" . )
       '("8" . meow-expand-8)
       ;'("*" . )
       '("9" . meow-expand-9)
       ;'("(" . )
       '("0" . meow-expand-0)
       ;'(")" . )

       ;; ===2nd Row===
       ;'("TAB"  . )
       ;'("BTAB" . )
       '("q" . kmacro-end-and-call-macro)
       '("Q" . cur/kmacro-toggle)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("r" . meow-replace)
       ;'("R" . )
       '("t" . meow-till)
       '("T" . meow-till-expand)
       '("y" . meow-save)
       '("Y" . meow-clipboard-save)
       '("u" . meow-undo)
       ;'("U" . )
       '("i" . meow-insert)
       ;'("I" . )
       '("o" . meow-open-below)
       '("O" . meow-open-above)
       '("p" . meow-yank)
       '("P" . meow-clipboard-yank)
       '("-" . negative-argument)
       ;'("_" . )

       ;; ===3rd Row===
       '("<escape>" . keyboard-quit)
       '("a" . meow-append)
       ;'("A" . )
       '("s" . repeat)
       ;'("S" . )
       '("d" . meow-kill)
       '("D" . meow-c-k)
       '("f" . meow-find)
       '("F" . meow-find-expand)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '(";" . meow-reverse)
       '(":" . meow-page-up)
       '("RET" . "C-c")
       ;'("S-RET" . )

       ;; ===4th Row===
       '("z" . meow-pop-selection)
       ;'("Z" . )
       '("x" . meow-line)
       '("X" . meow-line-expand)
       '("c" . meow-change)
       ;'("C" . )
       ;'("v" . )
       ;'("V" . )
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("n" . meow-search)
       '("N" . meow-goto-line)
       '("m" . meow-join)
       ;'("M" . )
       '("," . meow-beginning-of-thing)
       '("<" . meow-bounds-of-thing)
       '("." . meow-end-of-thing)
       '(">" . meow-inner-of-thing)
       '("/" . isearch-meow-wrapper)
       '("?" . meow-page-down)
       '("'"  . meow-block)
       '("\"" . meow-to-block)))
    :init
    (defhydra cur/hydra-buffer-cycle (:timeout 4)
      "tab through buffers"
      ("n" next-buffer "next buffer")
      ("p" previous-buffer "previous buffer")
      ("f" nil "finished" :exit t)
      ("RET" nil "finished" :exit t))
    :custom
    (meow-mode-state-list
     '((authinfo-mode . normal)
       (beancount-mode . normal)
       (bibtex-mode . normal)
       (cider-repl-mode . normal)
       (cider-test-report-mode . normal)
       (cider-browse-spec-view-mode . motion)
       (cargo-process-mode . normal)
       (conf-mode . normal)
       (deadgrep-edit-mode . normal)
       (deft-mode . normal)
       (diff-mode . normal)
       (dired-mode . motion)
       (eat-mode . insert)
       (ediff-mode . motion)
       (eshell-mode . insert)
       (gud-mode . normal)
       (haskell-interactive-mode . normal)
       (help-mode . motion)
       (helpful-mode . normal)
       (json-mode . normal)
       (jupyter-repl-mode . normal)
       (mix-mode . normal)
       (occur-edit-mode . normal)
       (pass-view-mode . normal)
       (prog-mode . normal)
       (py-shell-mode . normal)
       (restclient-mode . normal)
       (telega-chat-mode . normal)
       (term-mode . normal)
       (text-mode . normal)
       (vterm-mode . normal)
       (Custom-mode . normal))
     "Default meow states for modes")
    (meow-selection-command-fallback
     '((meow-change . meow-change-char)
       (meow-kill . meow-C-d)
       (meow-cancel-selection . keyboard-quit)
       (meow-pop-selection . meow-pop-grab)
       (meow-beacon-change . meow-beacon-change-char))
     "Meow fallback commands")
    (meow-keypad-describe-delay 0.0 "No delay in keypad help popup")
    (meow-cheats-layout meow-cheatsheet-layout-qwerty "Meow qwerty layout for the cheatsheet")
    :bind (:map cur/sub-leader-keymap
                ("C-b" . ibuffer)
                ("C-n" . meow-temp-normal))
    :config
    (setq meow-kteypad-leader-dispatch nil)
    (meow-setup)
    (meow-global-mode 1))

  (provide 'cur-config-bindings)
#+end_src

** Help configurations (=cur-config-help.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-help.el
:END:

Enhancing the help mechanisms in emacs.

*** Which-key

Which-key shows you what keybindings are available in a keychord. Super helpful and a must have in emacs.

#+begin_src emacs-lisp
  ;; ===which-key===
  (use-package which-key
    :demand t
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.0001))
#+end_src

*** Helpful

Provides additional info help.

#+begin_src emacs-lisp
  ;; ===helpful===
  (use-package helpful
    ;; :custom
    ;; (counsel-describe-function-function #'helpful-callable)
    ;; (counsel-describe-variable-function #'helpful-variable)
    :bind
    ;; ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ;; ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src

*** Info

Info is emacs' built in manual system. In essence, its a more feature rich =man= (which emacs also has easy access to with =woman=). Right now I have a custom meow state for keybindings. However, this kind of sucks and I will eventually switch to just changing the default keybindings.

#+begin_src emacs-lisp
  ;; ===Info===
  (use-package info
    :config
    (setq meow-info-keymap (make-keymap))
    (meow-define-state info
      "meow state for interacting with Info"
      :lighter "INFO"
      :keymap meow-info-keymap)
    (meow-define-keys 'info
      '(":" . meow-page-up)
      '("?" . meow-page-down)
      '("," . beginning-of-buffer)
      '("." . end-of-buffer)
      ; '("a" . )
      ; '("b" . )
      ; '("c" . Info-follow-reference)
      ; '("d" . )
      ; '("e" . )
      '("f" . Info-menu)
      '("g" . keyboard-quit)
      '("h" . Info-backward-node)
      '("H" . meow-left)
      '("i" . Info-index)
      '("j" . meow-next)
      '("k" . meow-prev)
      '("l" . Info-forward-node)
      '("L" . meow-right)
      '("m" . meow-join)
      '("n" . Info-next)
      ; '("o" . )
      '("p" . Info-prev)
      '("q" . meow-goto-line)
      '("r" . Info-follow-reference)
      ; '("s" . )
      '("t" . Info-toc)
      '("u" . Info-up)
      '("v" . meow-visit)
      ; '("w" . )
      ; '("x" . )
      '("y" . Info-copy-current-node-name)
      '("z" . info-display-manual)
      '("RET" . Info-follow-nearest-node)
      '("SPC" . meow-keypad)
      '("TAB" . Info-next-reference)
      '("<backtab>" . Info-prev-reference)
      '("<escape>" . keyboard-quit))
    (add-hook 'Info-mode-hook #'meow-info-mode))

  (provide 'cur-config-help)
#+end_src

** Dired configuration (=cur-config-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-dired.el
:END:

Dired is the built in file manager in emacs. Its very capable and very hackable although it lacks good file previewing solutions

*** Nerd Icons Dired

Adds icons to make dired a bit more pretty and gives a visual sense of what files are what. 

#+begin_src emacs-lisp
  ;; ===Dired Icons===
  (use-package nerd-icons-dired
    :after (dired)
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** Main Dired Configuration

By default, I want dired to look very minimal. This lack of clutter makes it easier to focus on what I am doing in the file manager. This is also the approach I try to take with other parts of emacs as well. By default, I have file details (owner, permissions, last modified, etc.) hidden. I have other changes as well, use the system trash can instead of deleting, that are under the ~:config~ part of the ~use-package~ declaration.

The keybindings are a hybrid of my normal state and the default dired keybindings.

#+begin_src emacs-lisp
  ;; ===Dired===
  (use-package dired
    :hook
    (dired-mode . dired-hide-details-mode) ; don't show file details by default
    (dired-mode . hl-line-mode) ; Highlight the line the cursor is on
    ;; TODO: create a dired-find-file-dwim for external programs
    :bind ( :map dired-mode-map
            ;; ===Top Row===
            ;; ("1" . )
            ;; ("!" . )
            ;; ("2" . )
            ;; ("@" . )
            ;; ("3" . )
            ;; ("#" . )
            ;; ("4" . )
            ;; ("$" . )
            ;; ("5" . )
            ;; ("%" . )
            ;; ("6" . )
            ;; ("^" . )
            ;; ("7" . )
            ;; ("&" . )
            ;; ("8" . )
            ;; ("*" . )
            ;; ("9" . )
            ;; ("(" . )
            ;; ("0" . )
            ;; (")" . )

            ;; ===2nd Row===
            ;; ("TAB"  . )
            ;; ("BTAB" . )
            ("q" . quit-window)
            ;; ("Q" . )
            ;; ("w" . )
            ;; ("W" . )
            ;; ("e" . )
            ;; ("E" . )
            ("r" . dired-do-rename)
            ("R" . dired-toggle-read-only)
            ("t" . dired-toggle-marks)
            ;; ("T" . )
            ;; ("y" . )
            ;; ("Y" . )
            ("u" . dired-unmark)
            ("U" . dired-unmark-all-marks)
            ("i" . dired-isearch-filenames-regexp)
            ("I" . dired-do-isearch-regexp)
            ;; ("o" . )
            ("O" . dired-do-chown)
            ("p" . dired-previous-line)
            ;; ("P" . )
            ("-" . negative-argument)
            ;; ("_" . )

            ;; ===3rd Row===
            ("<escape>" . keyboard-quit)
            ;; ("a" . )
            ;; ("A" . )
            ;; ("s" . )
            ;; ("S" . )
            ("d" . dired-do-kill-lines)
            ("D" . dired-do-delete)
            ("f" . find-file)
            ;; ("F" . )
            ("g" . revert-buffer)
            ;; ("G" . )
            ("h" . dired-up-directory)
            ;; ("H" . )
            ("j" . dired-next-line)
            ;; ("J" . )
            ("k" . dired-previous-line)
            ;; ("K" . )
            ("l" . dired-find-file)
            ("L" . dired-find-file-other-window)
            ;; (";" . )
            ;; (":" . )
            ("RET" . dired-find-file)
            ;; ("S-RET" . )

            ;; ===4th Row===
            ("z" . dired-undo)
            ;; ("Z" . )
            ("x" . dired-mark)
            ;; ("X" . )
            ("c" . dired-do-copy)
            ("C" . dired-do-copy-regexp)
            ("v" . dired-find-file-other-window)
            ;; ("V" . )
            ;; ("b" . )
            ;; ("B" . )
            ("n" . dired-next-line)
            ;; ("N" . )
            ("m" . dired-mark-files-regexp)
            ("M" . dired-do-chmod)
            ;; ("," . )
            ;; ("<" . )
            ;; ("." . )
            ;; (">" . )
            ("/" . dired-goto-file)
            ;; ("?" . )
            ;; ("'"  . )
            ;; ("\"" . )
            :map cur/sub-leader-keymap
            ("d" . dired)
            )
    :config
    (setq delete-by-moving-to-trash t)
    (setq dired-recursive-copies t)
    (setq dired-recursive-deletes t)
    (setq dired-listing-switches "-A -G -F -h -l -v --group-directories-first --time-style=long-iso")
    (setq dired-dwim-target t)
    (setq dired-auto-revert-buffer #'dired-directory-changed-p)
    (setq dired-free-space nil)
    (setq dired-make-directory-clickable t)
    (setq dired-mouse-drag-files t))

  (provide 'cur-config-dired)
#+end_src

** Faces, themes, and eye candy configurations (=cur-config-faces.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-faces.el
:END:

I think that emacs should have a lot of eye candy, especially since I spend so much time in it. These are my configurations for emacs' faces, theming and ui settings essentially.

*** Default Font

JetBrains Mono supremacy.

#+begin_src emacs-lisp
  ;; ===Default Font===
  (add-to-list 'default-frame-alist
               '(font . "JetBrains Mono Nerd Font-11"))
#+end_src

*** Default Opacity

I have this transparency set to be the same as with my Alacritty config. This adds more consistency to my computing experience. It also just looks really cool.

#+begin_src emacs-lisp
  ;; ===Default Opacity===
  (add-to-list 'default-frame-alist
               '(alpha-background . 85))
#+end_src

*** TODO Custom themes

I have several custom themes in a directory weirdly named themes. These are the =everforest= and =kanagawa= themes. I have changed these from the originals. TODO: add the links to the original themes.

#+begin_src emacs-lisp
  ;; ===Themes Path===
  (add-to-list 'custom-theme-load-path (locate-user-emacs-file "themes"))
#+end_src

*** Doom themes

Doom themes are a theme pack specifically for the Doom Emacs distribution, but work well without doom as well. I have a function that sets some faces based on the theme in ~custom-enabled-themes~. This function is more than just a little jank and I plan on creating my own themes instead of trying to hack around ones made by someone else.

#+begin_src emacs-lisp
    ;; ===Doom Emacs Themes===
    (use-package doom-themes
      :demand t
      :init
      (defun cur/theme-override ()
        "Change faces depending on what the value of `custom-enabled-themes' is."
        (cond ((member 'doom-gruvbox custom-enabled-themes)
               (set-face-attribute 'secondary-selection nil
                                   :background "#504945"))
              ((member 'doom-flatwhite custom-enabled-themes)
               (set-face-attribute 'haskell-operator-face nil
                                   :background (doom-color 'bg)
                                   :foreground (doom-color 'fg))
               (set-face-attribute 'haskell-type-face nil
                                   :background (doom-color 'fw-teal-blend)
                                   :foreground (doom-color 'fw-teal-text))
               (set-face-attribute 'haskell-constructor-face nil
                                   :background (doom-color 'fw-orange-blend)
                                   :foreground (doom-color 'fw-orange-text)))
              (t t)))
      (defun cur/load-theme (theme)
        "Load THEME, disabling all other currently enabled themes. Then
    check for overrides with `cur/theme-override'."
        (interactive
         (list
          (intern (completing-read "Cur Custom Themes: "
                                   (mapcar #'symbol-name
                                           (custom-available-themes))))))
        (condition-case nil
            (progn
              (mapc #'disable-theme custom-enabled-themes)
              (load-theme theme t)
              (cur/theme-override))
          (error "Problem loading theme %s" theme)))
      :bind (:map cur/toggle-map
                  ("C-t" . cur/load-theme))
      :config
      (cur/load-theme 'doom-oceanic-next))
#+end_src

*** Autothemer

A library used by =catppuccin= and =kanagawa=.

#+begin_src emacs-lisp
  ;; ===Autothemer===
  (use-package autothemer)
#+end_src

*** Catppuccin Theme

[[https:github.com/catppuccin/catppuccin][Link]] to the catppuccin theme.

#+begin_src emacs-lisp
  ;; ===Catppuccin Theme===
  (use-package catppuccin-theme
    :after (autothemer))
#+end_src

*** Text Scaling Hydra

A simple hydra that allows me to interactively set the size of the text in a buffer.

#+begin_src emacs-lisp
  ;; ===Text Scaling===
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("k" text-scale-increase "in")
    ("j" text-scale-decrease "out")
    ("f" nil "finished" :exit t)
    ("RET" nil "finished" :exit t))
  (define-key cur/toggle-map (kbd "C-s") 'hydra-text-scale/body)
#+end_src

*** Ef-themes

Themes made by Protesilaos, also known as Prot.

#+begin_src emacs-lisp
  ;; ===Ef-Themes===
  (use-package ef-themes)
    ;; :config
    ;; (cur/load-theme 'ef-tritanopia-dark))
#+end_src

*** Nerd Icons Ibuffer

Adds Icons to ~ibuffer~. Not really a face thing but I don't have a dedicated ~ibuffer~ module so it goes here instead.

#+begin_src emacs-lisp
  ;; ===Ibuffer Icons===
  (use-package nerd-icons-ibuffer
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** Spacious Padding

It adds padding and makes emacs look better.

#+begin_src emacs-lisp
  ;; ===Spacious Padding===
  (use-package spacious-padding
    :config
    (setq spacious-padding-widths
          '(:internal-border-width 8
            :header-line-width 0
            :mode-line-width 0
            :tab-width 0
            :right-divider-width 18
            :scroll-bar-width 0
            :fringe-width 0))
    (setq spacious-padding-subtle-mode-line nil)
    (spacious-padding-mode 1))

  (provide 'cur-config-faces)
#+end_src

** Completion system configurations (=cur-config-completion.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-completion.el
:END:

This section is not about code completion. Rather, this is my configuration for Emacs' completion system and the main interfaces that use them. For code completion please go see =cur-config-ide.el= and ~company-mode~.

Currently I am using the [[https:github.com/abo-abo/swiper/][ivy/counsel/swiper]] suite for doing completions in emacs. I like it but I know that the vertico/marginelia/consult/embark chain is better, faster, and more modern. I plan to make the switch at some point but for now I sticking with ivy.

*** Completions Styles

#+begin_src emacs-lisp
  (use-package minibuffer
    :config
    (setq completion-styles '(basic substring orderless))
    (setq completion-category-overrides
          '((file      (styles . (basic partial-completion orderless)))
            (kill-ring (styles . (emacs22 orderless))))))

  (use-package orderless
    :bind ( :map minibuffer-local-completion-map
            ("SPC" . nil)
            ("?" . nil))
    :config
    (setq orderless-matching-styles '(orderless-prefixes orderless-regexp)))
#+end_src

*** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode 1))
#+end_src

*** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode 1))
#+end_src

*** Vertico Posframe

#+begin_src emacs-lisp
  (use-package vertico-posframe
    :config
    (vertico-posframe-mode 1))
#+end_src

*** Consult

#+begin_src emacs-lisp
  (use-package consult
    :demand t
    :bind (("C-x b" . consult-buffer)
           ("M-g i" . consult-imenu)
           ("M-y"   . consult-yank-pop)))

  (provide 'cur-config-completion)
#+end_src

** Window management configurations (=cur-config-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-window.el
:END:

*** Display Buffer Alist

These are my settings for ~display-buffer-alist~ so windows just Do What I Mean.

#+begin_src emacs-lisp
  (use-package cur-window
    :config
    (setq window-sides-slots
          '(1 1 1 1))
    (setq display-buffer-alist
          '(("\\`\\*Async Shell Command\\*\\'"
             (display-buffer-no-window))
            ("\\*Org Src.*"
             (display-buffer-same-window))
            ((or (derived-mode . compilation-mode)
                 (derived-mode . geiser-mode)
                 (derived-mode . grep-mode)
                 (derived-mode . help-mode)
                 (derived-mode . Info-mode)
                 (derived-mode . rg-mode)
                 (derived-mode . woman-mode))
             (cur-window-display-buffer-below-or-pop)
             (body-function . cur-window-select-fit-to-size))
            ((derived-mode . occur-mode)
             (display-buffer-reuse-window
              display-buffer-below-selected)
             (dedicated . t)
             (body-function . cur-window-select-fit-to-size))
            ((or (derived-mode . justl-mode)
                 "\\*eshell .*"
                 "\\*vterm.*"
                 "\\*.*-eat\\*"
                 "justl - .*")
             (display-buffer-reuse-window
              display-buffer-at-bottom)
             (dedicated . t)
             (window-height . 0.25)))))

  (provide 'cur-config-window)
#+end_src

** IDE configurations (=cur-config-ide.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-ide.el
:END:

Emacs can be made to have all the features of a modern text editor and then some.

*** LSP-mode

Lsp-mode is my chosen language server protocol support package. I chose this over eglot because of the richer features and (at the time that I started using lsp) more mature state. I will revisit elgot in the future but for now I am perfectly happy with lsp-mode.

#+begin_src emacs-lisp
  ;; ===LSP Mode===
  (use-package lsp-mode
    :demand t
    :hook
    (lsp-mode  . lsp-enable-which-key-integration)
    :custom
    (lsp-keymap-prefix "C-c C-M-l" "lsp mode keymap")
    :bind (:map lsp-mode-map
                ("C-c C-a" . lsp-execute-code-action)  ; code actions
                ("C-c C-e" . lsp-treemacs-errors-list) ; treemacs error list
                ("C-c f"   . lsp-find-references)      ; find references
                ("C-c r"   . lsp-find-definition))     ; find definitions
    :config
    (lsp-deferred)
    (setq gc-cons-threshold (* 100 1024 1024))
    (setq read-process-output-max (* 3 1024 1024))
    (setq lsp-idle-delay 0.500)
    (setq lsp-lens-enable nil)
    (lsp-enable-which-key-integration t))
#+end_src

*** LSP UI

Lsp-ui provides some ui enhancements and extra features to lsp. Probably the best one is the doc feature to view documentation in the editor.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after (lsp-mode)
    :custom
    (lsp-ui-doc-enable nil "lsp-ui doc disabled by default")
    (lsp-ui-doc-show-with-cursor t "lsp-ui doc follows cursor")
    (lsp-ui-doc-show-with-mouse t "lsp-ui doc follows mouse")
    (lsp-ui-doc-position 'at-point "lsp-ui doc shows at cursor")
    :bind (:map lsp-ui-mode-map
                ("C-c C-f" . lsp-ui-peek-find-references)  ; find references ui
                ("C-c C-r" . lsp-ui-peek-find-definitions) ; find definitions ui
                ("C-c C-d" . lsp-ui-doc-mode) ; toggle doc mode
                :map lsp-ui-peek-mode-map
                ("ESC" . lsp-ui-peek--abort)             ; toggle doc mode
                ("g"   . lsp-ui-peek--abort)             ; toggle doc mode
                ("j"   . lsp-ui-peek--select-next)       ; toggle doc mode
                ("k"   . lsp-ui-peek--select-prev)       ; toggle doc mode
                ("C-j" . lsp-ui-peek--select-next-file)  ; toggle doc mode
                ("C-k" . lsp-ui-peek--select-prev-file)) ; toggle doc mode
    :hook
    (lsp-mode . lsp-ui-mode))
#+end_src

*** Company

The code completion system. This is different from completions systems like ivy or vertico, this is for interactively completing a symbol while programming.

#+begin_src emacs-lisp
  ;; ===Company Mode===
  (use-package company
    :hook
    (prog-mode . company-mode)
    (lsp-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-common-or-cycle)
                ("<return>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))
  ;;(company-tng-configure-default))
#+end_src

*** Flycheck

Code error checking with a nice UI.

#+begin_src emacs-lisp
  ;; ===Flycheck===
  (use-package flycheck
    :hook
    (prog-mode . flycheck-mode)
    (lsp-mode  . flycheck-mode))
#+end_src

*** Treemacs

Project tree, I don't use this all that often.

#+begin_src emacs-lisp
  ;; ===Treemacs==
  (use-package treemacs
    :bind
    (:map cur/sub-leader-keymap
          ("C-t" . treemacs-select-window))
    :config
    (treemacs-follow-mode))
#+end_src

*** Magit

Magit is a git interface, probably the best one I have ever seen or had the pleasure of using. I consider magit to be one of emacs' "killer features", right up there with org-mode.

#+begin_src emacs-lisp
  ;; ===Magit===
  (use-package magit
    :bind (:map cur/sub-leader-keymap
                ("C-M-g" . magit))
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    (transient-default-level 5 "Allowing for commit signing"))
#+end_src

*** Projectile

Projectile provides many commands to help manage and do things in a project, such as compile a project from its root, list all files in the project, or run grep or ripgrep on all the files in the project. I also use it's project switching aspect as sort of a bookmark like system.

#+begin_src emacs-lisp
  ;; ===Projectile===
  (use-package projectile
    :after (rg)
    :bind (:map cur/projectile-map
                ("C-p"   . projectile-switch-project)
                ("C-a"   . projectile-add-known-project)
                ("C-d"   . projectile-dired)
                ("d"     . projectile-find-dir)
                ("C-f"   . projectile-find-file)
                ("C-r"   . consult-ripgrep)
                ("C-c"   . projectile-compile-project)
                ("C-b"   . consult-project-buffer)
                ("C-l"   . projectile-ibuffer)
                ("C-k"   . projectile-kill-buffers)
                ("C-v"   . projectile-vc)
                ("C-e"   . projectile-run-eshell))
    :config
    (projectile-mode 1))

  ;; Need ripgrep wrapper for `projectile-ripgrep'
  (use-package rg)
#+end_src

*** Just

[[https:github.com/casey/just][Just]] is just a command runner. Think of it sort of like make but simplified. This is my configuration for working and interacting with it from emacs.

#+begin_src emacs-lisp
  (use-package just-mode)

  (use-package justl
    :bind (:map cur/projectile-map
                ("C-j" . justl)))

  (provide 'cur-config-ide)
#+end_src

** Configurations for Lisp (=cur-config-lisp.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-lisp.el
:END:

These are my configurations for working with Lisp languages.

*** Rainbow Delimiters

This color codes opening and closing delimiters such as parentheses and square brackets.

#+begin_src emacs-lisp
  ;; ===rainbow-delimiters===
  (use-package rainbow-delimiters
    ;:ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Paredit

#+begin_src emacs-lisp
  ;; ===Paredit===
  (use-package paredit
    :hook ((emacs-lisp-mode lisp-interaction-mode scheme-mode) .
           (lambda () (paredit-mode 1))))
#+end_src

*** Geiser

#+begin_src emacs-lisp
  ;; ===Geiser===

  (provide 'cur-config-lisp)
#+end_src

** Configurations for Java (=cur-config-java.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-java.el
:END:

My configurations for working with the Java language. I have ~java-ts-mode~, the tree sitter version of the normal ~java-mode~, as the mode for editing =.java= files. I have found that either tree sitter provides exactly the same or better syntax highlighting and the possibility of better movement once it gets better integrated into emacs.

I also have lsp-java set up for better integrating ~lsp-mode~ into ~java-ts-mode~. Note because I have =direnv= integration with ~envrc~, the hooks I add to start ~lsp~ must be ~lsp-defered~. ~lsp-defered~ does not start ~lsp-mode~ until after the buffer has visually loaded. We want this because ~envrc~ will change the ~exec-path~ to what =direnv= would change it to. For instance, if I have a devshell that says "here is the lsp-server, the build tool, and external libraries with these exact versions", envrc will make sure that ~exec-path~ contains exactly those versions of those programs in the nix store.

#+begin_src emacs-lisp
  ;; ===Java Tree-Sitter Mode===
  (use-package java-ts-mode
    :mode "\\.java\\'")

  ;; ===lsp-java===
  (use-package lsp-java
    :after (lsp-mode cc-mode)
    :init
    :hook
    (envrc-mode . (lambda ()
                    (when (equal major-mode 'java-ts-mode)
                      (setq lsp-java-server-install-dir (concat (getenv "JDTLS_PATH") "/share/java/jdtls/")))))
    (java-ts-mode . lsp-deferred)
    :config
    (defun lsp-java--ls-command ()
      (let ((jdtls-path (getenv "JDTLS_PATH"))
            (jdtls-exec-options (list
                                 "-configuration"
                                 (concat (getenv "HOME") "/.jdtls/config_linux")
                                 "-data"
                                 (concat (getenv "HOME") "/.jdtls/java-workspace"))))
        (message (concat jdtls-path "/share/java/"))
        (append (list (concat jdtls-path "/bin/jdtls")) jdtls-exec-options))))

  (provide 'cur-config-java)
#+end_src

** Configurations for Mark-up Languages (=cur-config-markup.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-markup.el
:END:

Literally just ~yaml-mode~.

#+begin_src emacs-lisp
  ;; ===YAML===
  (use-package yaml-mode
    :commands (yaml-mode))

  (provide 'cur-config-markup)
#+end_src

** Configurations for Nix (=cur-config-nix.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-nix.el
:END:

My configurations for the Nix language, which boils down to "start the lsp server".

#+begin_src emacs-lisp
  ;; ===nix-mode===
  (use-package nix-mode
    :hook
    ((nix-mode) . lsp-deferred))

  (provide 'cur-config-nix)
#+end_src

** Configurations for Rust (=cur-config-rust.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-rust.el
:END:

#+begin_src emacs-lisp
  ;; ===Rust-Mode===
  (use-package rustic
    :after (lsp-mode)
    :hook (rustic . lsp-deferred))

  (provide 'cur-config-rust)
#+end_src

** Configurations for Haskell (=cur-config-haskell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-haskell.el
:END:

#+begin_src emacs-lisp
  ;; ===Haskell-Mode===
  (use-package haskell-mode)

  ;; ===LSP-Haskell===
  (use-package lsp-haskell
    :hook
    ((haskell-mode) . lsp-deferred))

  ;; ===Company-GHCI===
  (use-package company-ghci
    :after (company)
    :custom (company-ghc-show-info t)
    :config
    (push 'company-ghci company-backends))

  (provide 'cur-config-haskell)
#+end_src

** Configurations for C (=cur-config-c.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-c.el
:END:

I use tree-sitter for C, which unfortunately is not currently integrated into the default C major mode for emacs. I have also changed the ~c-default-style~ for C to be "linux", which is 8 spaces for indentation instead of the default of 2.

#+begin_src emacs-lisp
  ;; ===C Tree-Sitter Mode===
  (use-package c-ts-mode
    :after (cc-mode)
    :mode
    ("\\.c\\'" . c-ts-mode)
    ("\\.h\\'" . c-ts-mode)
    :custom
    (c-default-style '((c-ts-mode . "linux")
                       (java-mode . "java")
                       (awk-mode  . "awk")
                       (other     . "gnu"))
     "default style for c programs is linux")
    :hook
    (c-ts-mode . (lambda () (require 'ccls) (lsp-deferred))))

  ;; ===CCLS Mode===
  (use-package ccls
    :after (cc-mode c-ts-mode))

  (provide 'cur-config-c)
#+end_src

** Configurations for Zig (=cur-config-zig.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-zig.el
:END:

#+begin_src emacs-lisp
  ;; ===Zig Mode===
  (use-package zig-mode
    :hook (zig-mode . lsp-deferred))

  (provide 'cur-config-zig)
#+end_src

** Configurations for Go (=cur-config-go.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-go.el
:END:

#+begin_src emacs-lisp
  ;; ===Go Tree-Sitter Mode===
  (use-package go-ts-mode
    :mode
    ("\\.go\\'" . go-ts-mode)
    ("^go\\.mod\\'" . go-mod-ts-mode)
    :custom
    (go-ts-mode-indent-offset 4 "Set the indentation to 4")
    :hook
    (go-ts-mode . lsp-deferred)
    (go-ts-mode . (lambda () (setq tab-width 4))))

  (provide 'cur-config-go)
#+end_src

** Terminal emulation and Eshell configuration (=cur-config-shell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-shell.el
:END:

*** Vterm

Vterm is a terminal emulator for emacs. It is faster than ~term~ and ~ansi-term~ but the downside is that it is not written entirely in elisp so its cross platform. ~cur/meow-vterm~ and ~cur/meow-vterm-other-window~ help make vterm more "intuitive". ~cur/vterm-kill~ kills the vterm buffer cleanly and without prompting.

#+begin_src emacs-lisp
  ;; ===Vterm===
  (use-package vterm
    :ensure nil
    :commands (vterm cur/meow-vterm-other-window cur/meow-vterm)
    :bind (:map vterm-mode-map
           ("C-c C-k" . cur/vterm-kill)
           :map cur/sub-leader-keymap
           ("C-RET" . cur/meow-vterm-other-window)
           ("RET"   . cur/meow-vterm))
    :init
    (defun cur/meow-vterm ()
      (interactive)
      (vterm)
      (meow-insert-mode))
    (defun cur/meow-vterm-other-window ()
      (interactive)
      (vterm-other-window)
      (meow-insert-mode))
    (defun cur/vterm-kill ()
      (interactive)
      (when (equal (buffer-name) "*vterm*")
        (let ((kill-buffer-query-functions nil))
          (kill-buffer-and-window))))
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
    (setq vterm-max-scrollback 10000))
#+end_src

*** Eat

Eat is just a better elisp terminal emulator. I mostly use this so that elisp can run TUI programs.

#+begin_src emacs-lisp
  ;; ===Eat===
  (use-package eat
    :config
    (eat-eshell-mode 1))
#+end_src

*** Eshell

Eshell is an shell for Emacs like bash or sh, but written in elisp and has its own ways of doing things. Note: not POSIX compliant.

#+begin_src emacs-lisp
  ;; ===Eshell===
  (use-package eshell)

  (use-package cur-eshell
    :custom
    (eshell-prompt-regexp cur-eshell-prompt-regexp "Regex for custom eshell prompt")
    (eshell-prompt-function 'cur-eshell-prompt "Set custom prompt for eshell"))
#+end_src

*** Zoxide

Interfacing with Zoxide from emacs.

#+begin_src emacs-lisp
  ;; ===Zoxide===
  (use-package zoxide)

  (provide 'cur-config-shell)
#+end_src

** Org-mode (=cur-config-org.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-org.el
:END:

#+begin_src emacs-lisp
  ;; ===Org-Mode===
  (use-package org
    :ensure nil
    :defer t
    :hook (org-mode . cur/org-mode-setup)
    :bind (:map org-mode-map
            ("C-S-h" . outline-promote)
            ("C-S-j" . outline-move-subtree-down)
            ("C-S-k" . outline-move-subtree-up)
            ("C-S-l" . outline-demote))
    :init
    (defun cur/org-mode-setup ()
      (org-indent-mode 1)
      (variable-pitch-mode 0)
      (visual-line-mode 1)
      (flyspell-mode 1))
    :custom
    (org-ellipsis " ▾" "Readable ellipsis")
    (org-adapt-indentation nil)
    (org-special-ctrl-a/e nil)
    (org-M-RET-may-split-line '((default . nil)))
    (org-hide-emphasis-markers nil)
    (org-hide-macro-markers nil)
    (org-hide-leading-stars nil)
    (org-agenda-start-with-log-mode t)
    (org-src-window-setup 'plain) ; don't override `display-buffer-alist'
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-agenda-window-setup 'current-window "Have org-agenda pop up in the current window")
    :config
    (load-library "find-lisp")
    ;; (setq org-agenda-files (find-lisp-find-files "~/dox/agenda" "\.org$"))
    (setq org-agenda-time-grid '((daily today require-timed)
                                 (400 600 800 1000 1200 1400 1600 1800 2000 2200)
                                 "......" "----------------"))
    (setq org-format-latex-options '(:foreground "#e5e9e9" :scale 1.0)))
    ;; (cur/org-font-setup))
#+end_src

#+begin_src emacs-lisp
  ;; ===Org Tempo and SRC Blocks===
  (use-package org-tempo
    :after org
    :config
    (push '("conf-unix" . conf-unix) org-src-lang-modes)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("tex" . "src latex"))
    (add-to-list 'org-structure-template-alist '("conf" . "src conf-unix"))
    (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
    (add-to-list 'org-structure-template-alist '("java" . "src java"))
    (add-to-list 'org-structure-template-alist '("elv" . "src elvish")))
#+end_src

#+begin_src emacs-lisp
  ;; ===Org Babel===
  (use-package ob
    :after org)
  ;; TODO: fix this so I can still auto tangle on saving
    ;; :init
    ;; (defun cur/org-babel-tangle-config ()
    ;;   (when (string-equal (file-name-directory (buffer-file-name))
    ;;                       (expand-file-name user-emacs-directory))
    ;;     ;; Dynamic scoping to the rescue
    ;;     (let ((org-confirm-babel-evaluate nil))
    ;;       (org-babel-tangle))))
    ;; 
    ;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'cur/org-babel-tangle-config))))

  (provide 'cur-config-org)
#+end_src

** Configurations for Gemini and the smolnet (=cur-config-smol-net.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-smol-net.el
:END:

#+begin_src emacs-lisp
  ;; ===Gemini-Mode===
  (use-package gemini-mode)

  ;; ===Org Gemini Exporter==
  (use-package ox-gemini)

  ;; ===Elpher Gemini/Gopher Client===
  (use-package elpher
    :custom
    (elpher-default-url-type "gemini"))

  (provide 'cur-config-smol-net)
#+end_src

** Elcord and making myself look productive to my friends (=cur-config-elcord.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-elcord.el
:END:

#+begin_src emacs-lisp
  (use-package elcord)

  (provide 'cur-config-elcord)
#+end_src

** Direnv integration (=cur-config-direnv.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-direnv.el
:END:

#+begin_src emacs-lisp
  ;; ===Envrc===
  (use-package envrc
    :config
    (envrc-global-mode))

  (provide 'cur-config-direnv)
#+end_src

* Custom Library Modules (=cur-lisp=)

** Base Values and Functions (=cur-base.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-base.el
:END:

#+begin_src emacs-lisp
  ;;; cur-base.el --- The base of my customizations for emacs

  ;;; Commentary:
  ;; This is the base of my extensions to Emac's functionality.
  ;; Do try this at home kids.

  ;;; Code:

  (defgroup cur-base ()
    "Base functions and variables for my Emacs configuration."
    :group 'editing)

  (provide 'cur-base)
  ;;; cur-base.el ends here
#+end_src

** Eshell aliases and extensions (=cur-eshell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-eshell.el
:END:

#+begin_src emacs-lisp
  ;;; cur-eshell.el --- My exensions of the Emacs Shell

  ;;; Commentary:

  ;;; Code:

  (require 'eshell)
  (require 'files)
  (require 'dired)

  (defun cur-eshell-prompt ()
    "A minimal and colourful prompt for `eshell'.
  Set `eshell-prompt-function' to this function to enable."
    (concat
     (propertize "[" 'face 'ansi-color-red)
     (propertize (eshell/whoami) 'face 'ansi-color-yellow)
     (propertize "@" 'face 'ansi-color-green)
     (propertize (system-name) 'face 'ansi-color-blue)
     " "
     (propertize (concat (eshell/pwd)) 'face 'ansi-color-magenta)
     (propertize "]" 'face 'ansi-color-red)
     (propertize "$ " 'face 'bold)))

  (defun eshell/ff (&optional file)
    "Eshell alias to open FILE.
  Will call `find-file' interactively if no file is specified."
    (cond (file
           (find-file file))
          (t
           (call-interactively 'find-file))))

  (defun eshell/dir (&optional dir)
    "Eshell alias to open `dired' at DIR.
  Will call `dired' on current directory if no directory is specified."
    (cond (dir
           (dired dir))
          (t
           (dired "."))))

  (defvar cur-eshell-prompt-regexp
    "^\\[[^]]*\\]\\[?[[:digit:]]*\\]?[#$λ] "
    "Regex for the `cur-eshell-prompt' prompt.")

  (provide 'cur-eshell)
  ;;; cur-base.el ends here
#+end_src

** Tmux Integration (=cur-tmux.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-tmux.el
:END:

#+begin_src emacs-lisp
  ;;; cur-tmux.el --- Integrating Emacs with a tmux

  ;;; Commentary:

  ;;; Code:

  (defvar cur-tmux-session-name
    "emacs"
    "The name of the session Emacs will try to connect to and manipulate.")

  (defun cur-tmux--remove-ansi-escape-colors (str)
    "Remove ansi escape color codes from STR."
    (replace-regexp-in-string "\\[.*?m" "" str))

  (defun cur-tmux--list-session-names ()
    "List the names of all active tmux sessions."
    (let* ((session-names (string-split
                          (with-temp-buffer
                            (cur-tmux--exec-command '("ls" "-F" "#{session_name}") t)
                            (buffer-string)) "\n" t)))
      (remove nil session-names)))

  (defun cur-tmux-emacs-session-p ()
    "Return t of `cur-tmux-session-name' is an active session."
    (if (member cur-tmux-session-name (cur-tmux--list-session-names))
        t
      nil))

  (defun cur-tmux--create-session (&optional command)
    "Create session named after `cur-tmux-session-name' if one does not exist.
  Will return nil if session exists and will return t if session is
  created successfully.  Will error if tmux is not found or if tmux
  returns an error value.
  If COMMAND is not nil, it will be passed as the initial shell command to tmux."
    (if (cur-tmux-emacs-session-p)
        nil
      (let* ((exit-code (cond
                         (command (call-process "tmux" nil nil nil
                                                "new" "-d" "-s" cur-tmux-session-name command))
                         (t (call-process "tmux" nil nil nil
                                          "new" "-d" "-s" cur-tmux-session-name)))))
        (if (= exit-code 0)
            t
          (error "Tmux was unable to create a new session with that name")))))

  ;; TODO: make it so that you can set the directory of the shell.
  (defun cur-tmux--exec-command-with-code (args &optional buffer)
    "Call tmux with ARGS, output to BUFFER and return exit code.
  ARGS must be a list strings that corespond to tmux flags and arguments."
    (apply 'call-process "tmux" nil buffer nil args))

  (defun cur-tmux--exec-command (args &optional buffer)
    "Call `cur-tmux--exec-command' with ARGS and BUFFER, return t or nil.
  Nil is returned if there is an error and t is returned if there is no error.
  ARGS must be a list strings that corespond to tmux flags and arguments."
    (let ((exit-code (cur-tmux--exec-command-with-code args buffer)))
      (if (> exit-code 0)
          nil
        t)))

  (defun cur-tmux--exec-command-err-on-err (args &optional buffer)
    "Call `cur-tmux--exec-command' with ARGS and BUFFER, `error' on error."
    (let* ((exit-code (cur-tmux--exec-command-with-code args buffer)))
      (if (= exit-code 0)
          t
        (error "Tmux terminated with exit code %d" exit-code))))

  (defun cur-tmux--new-window (window-name &optional command)
    "New window named WINDOW-NAME, executing COMMAND if it is non nil."
    (let* ((args (list "new-window" "-n" window-name "-t" cur-tmux-session-name))
           (args* (if command
                      (append args (list command))
                    args)))
      (cur-tmux--exec-command-err-on-err args*)))

  (defun cur-tmux--list-windows (&optional index)
    "List windows in `cur-tmux-session-name'.
  If INDEX is not nil, output the with format \"#{window_index}: #{window_name}\"."
    (let* ((args (list "list-windows" "-t" cur-tmux-session-name "-F" ))
           (args* (if index
                      (append args '("#{window_index}: #{window_name}"))
                    (append args '("#{window_name}")))))
      (split-string
       (with-temp-buffer
         (cur-tmux--exec-command-err-on-err args* t)
         (buffer-string))
       "\n" t)))

  (defun cur-tmux-window-exists-p (window &optional index)
    "Check if WINDOW is a window in `cur-tmux-session-name'.
  If INDEX is not nil, check if there is a window named WINDOW with number INDEX.
  The behavior is similar to that of `member'."
    (cond
     (index (if (member (format "%d: %s" index window) (cur-tmux--list-windows index))
                t
              nil))
     (t (if (member window (cur-tmux--list-windows))
            t
          nil))))

  (provide 'cur-tmux)
  ;;; cur-tmux.el ends here
#+end_src

** Custom modeline (=cur-modline.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; cur/modeline.el --- My custom modeline -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;
  ;; This is my custom modeline.  This is here bascially because I don't want to
  ;; use doom modeline.

  ;;; Code:
  (defgroup cur-modeline nil
    "My custom modeline that tries to be minimal."
    :group 'mode-line)
  
  (defgroup cur-modeline-faces nil
    "The faces for my custom modeline."
    :group 'cur-modeline)

  (defun cur-mode-line/padding ()
    "Function to return padding so `mode-line-end-spaces' will be right aligned."
    (let ((r-length (length (format-mode-line mode-line-end-spaces))))
      (propertize " "
                  'display `(space :align-to (- right ,r-length)))))

  (setq-default mode-line-format
                '("%e"
                  (:eval
                   (when (and (mode-line-window-selected-p) defining-kbd-macro)
                     (propertize "  KMACRO  " 'face 'font-lock-string-face)))
                  (:eval
                   (when (and (mode-line-window-selected-p)
                              (buffer-narrowed-p)
                              (not (derived-mode-p 'Info-mode 'help-mode 'special-mode 'message-mode)))
                     (propertize "  NARROWED  " 'face 'font-lock-constant-face)))
                  (:eval
                   (when (and (member 'meow features) (mode-line-window-selected-p))
                     (propertize (format "  %s  " (upcase (symbol-name meow--current-state)))
                                 'face 'highlight)))
                  "  "
                  (:eval
                   (when (mode-line-window-selected-p)
                     (cond (buffer-read-only
                            (propertize "RO" 'face 'shadow))
                           ((buffer-modified-p)
                            (propertize "**" 'face 'shadow))
                           (t
                            (propertize "RW" 'face 'shadow)))))
                  "  "
                  (:eval
                   (propertize (format "%s" (buffer-name)) 'face 'bold))
                  "  "
                  (:eval
                   (if (mode-line-window-selected-p)
                     (propertize (capitalize (symbol-name major-mode)) 'face 'warning)
                     (propertize (capitalize (symbol-name major-mode)) 'face 'shadow)))
                  (:eval (cur-mode-line/padding))))

  (provide 'cur-modeline)
  ;;; cur-modeline.el ends here
#+end_src

** Window Management (=cur-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-window.el
:END:

#+begin_src emacs-lisp
  ;;; cur-window.el --- Customization and helper functions for window management

  ;;; Commentary:
  ;; Custom functions and variables for managing windows.  In particular, setting `display-buffer-alist'
  ;; so that windows are just placed how I want.
  ;;
  ;; Much of this was shamelessly stolen from Protesilaos Stavrou, who greatly inspired much of my config.
  ;; Please see https://protesilaos.com/emacs/dotemacs#h:35b8a0a5-c447-4301-a404-bc274596238d for his window
  ;; management section of his Emacs config.

  ;;; Code:

  (defun cur-window--window-small-p ()
    "Return non-nil if window is small.
  Check if the `window-width' or `window-height' is less than
  `split-width-threshold' and `split-height-threshold',
  respectively."
    (or (and (numberp split-width-threshold)
             (< (window-total-width) split-width-threshold))
        (and (numberp split-height-threshold)
             (> (window-total-height) split-height-threshold))))

  (defun cur-window--three-or-more-windows-p (&optional frame)
    "Return non-nil if three or more windows occupy FRAME.
  If FRAME is non-nil, inspect the current frame."
    (>= (length (window-list frame :no-minibuffer)) 3))

  (defun cur-window--get-display-buffer-below-or-pop ()
    "Return list of functions for `cur-window-display-buffer-below-or-pop'."
    (list
     #'display-buffer-reuse-mode-window
     (if (or (cur-window--window-small-p)
             (cur-window--three-or-more-windows-p))
         #'display-buffer-below-selected
       #'display-buffer-pop-up-window)))

  (defun cur-window-display-buffer-below-or-pop (&rest args)
    "Display buffer below current window or pop a new window.
  The criterion for choosing to display the buffer below the
  current one is a non-nil return value for
  `prot-common-window-small-p'.

  Apply ARGS expected by the underlying `display-buffer' functions.

  This as the action function in a `display-buffer-alist' entry."
    (let ((functions (cur-window--get-display-buffer-below-or-pop)))
      (catch 'success
        (dolist (fn functions)
          (when (apply fn args)
            (throw 'success fn))))))

  (defvar cur-window-window-sizes
    '( :max-height (lambda () (floor (frame-height) 3))
       :min-height 10
       :max-width (lambda () (floor (frame-width) 3))
       :min-width 20)
    "This is a property list of max and min values for window sizes.
  This value is used by `cur-window-select-fit-to-size' to set the
  size of the window.")

  (defun cur-window--get-window-size (key)
    "Use KEY to extract the value from `cur-window-window-sizes'.
  If the value is a number return it, if it is a function, call
  it and return it's value."
    (when-let ((value (plist-get cur-window-window-sizes key)))
      (cond
       ((functionp value)
        (funcall value))
       ((numberp value)
        value)
       (t
        (error "The value of %s is not a number or function" key)))))

  (defun cur-window-select-fit-to-size (window)
    "Select WINDOW and fit it to the buffer.
  The minimum and maximum height and width is determined by
  `cur-window-window-sizes'."
    (select-window window)
    (fit-window-to-buffer
     window
     (cur-window--get-window-size :max-height)
     (cur-window--get-window-size :min-height)
     (cur-window--get-window-size :max-width)
     (cur-window--get-window-size :min-width)))

  (defvar cur-window-same-window-modes-list
    '(justl-mode)
    "List of major modes that should have their window reused.
  The function `cur-window-display-buffer-below-or-pop' uses this variable to
  determine if it will create a new window or reuse the current one.")

  (defun cur-window--get-display-buffer-same-window-or-below ()
    "Return a list of functions for `cur-window-display-buffer-same-window-or-below'."
    (list
     #'display-buffer-reuse-window
     (if (memq major-mode cur-window-same-window-modes-list)
         #'display-buffer-same-window
       #'display-buffer-below-selected)))

  (defun cur-window-display-buffer-same-window-or-below (&rest args)
    "Display buffer either reusing the current window or bellow."
    (let ((functions (cur-window--get-display-buffer-same-window-or-below)))
      (catch 'success
        (dolist (fn functions)
          (when (apply fn args)
            (throw 'success fn))))))

  (provide 'cur-window)
  ;;; cur-window.el ends here
#+end_src
