#+title: Emacs Configuration
#+author: icurry
#+language: en
#+options: toc:2 num:t author:t

Obligatory Frieren Ascii art.

#+begin_example text
            Frieren
⠀⠀⠀⠀⠀⠀⢀⡴⢾⣶⣴⠚⣫⠏⠉⠉⠛⠛⢭⡓⢶⣶⠶⣦⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣰⠋⡀⣠⠟⢁⣾⠇⠀⣀⣷⠀⠀⠓⣝⠂⠙⣆⢄⢻⡞⢢⠀⠀⠀
⠀⠀⠀⠀⢠⡇⢸⢡⠃⢠⡞⠁⠀⣰⡟⠉⢦⣄⠀⠈⢆⠀⢻⣾⡄⢧⢸⠀⠀⠀
⠀⠀⠀⠀⢸⠀⡇⡌⠀⡞⠀⢀⣴⡋⠀⠀⠀⣙⣷⡀⠘⡄⠘⣿⣧⢸⣼⣥⠀⠀
⣀⣀⣀⣀⣞⣰⠁⡇⠀⣧⠴⠛⠛⠁⠀⠀⠀⠉⠉⠙⠦⡇⠀⣿⣸⣼⣿⣇⣀⣀
⠳⢽⣷⠺⡟⡿⣯⡇⠰⣧⠠⣿⡷⠂⠀⠀⠀⠐⣾⠷⠀⡀⠀⣿⡟⣴⠶⢁⡨⠊
⠀⠀⠉⢳⢦⣅⠘⣿⣄⢿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⢀⣏⣳⣿⣴⡞⠈⠀
⠀⠀⠀⣼⢸⡅⢹⣿⣿⣾⣟⠀⠀⢠⣀⣄⣠⠀⠀⢠⣾⣿⡿⣿⢻⠁⢹⣷⡀⠀
⠀⠀⠸⡏⠸⡇⢼⣿⡿⠟⠛⠓⣦⣄⣀⣀⣀⣀⡤⠴⠿⢿⡟⠛⠺⣦⣬⣗⠀⠀
⠀⠀⢰⡇⠀⡇⠸⡏⠀⠀⢰⠋⠙⠛⠛⠉⠉⢹⠀⠀⠀⠀⡇⠀⠀⣿⣿⣿⣿⡇
⠀⡐⣾⠀⡀⢹⠀⣿⣄⠀⢸⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢠⣇⠀⠀⣿⣿⣿⣿⣿
⣰⣿⣿⠀⡇⠘⡄⢸⣿⠆⠈⡇⠀⠀⠀⠀⠈⢉⠃⠀⣰⡾⠻⠃⢰⣿⣿⣿⣿⡇
⣿⣿⣿⡆⢷⠀⢧⠈⣿⠤⠤⣇⠀⠀⠀⠀⢀⣸⣠⢾⠟⠓⡶⢤⣾⣿⣿⣿⣿⣷
#+end_example

This is my configuration for GNU Emacs. It is a [[https://protesilaos.com/codelog/2025-01-26-emacs-organise-init/][literate configuration]], meaning that the documentation (prose) and configuration (code) are part of one file, right next to each other. This makes it easier for future me and others to be able to know what each part of my configuration does. That said, it is still possible for the prose and the code to become out of sync so please be aware of that when reading (i.e. if there is a discrepancy between the code and the prose, go with the code). I have primarily based my configuration specifically, and my approach to Emacs generally, off of [[https://protesilaos.com/emacs/dotemacs][Proesilaos Stavrou's]]. I highly recommend reading through some of his configuration as it is one of the most well documented and well structured configurations for Emacs out there.

The way my configuration works is that the code parts of this file get copied out (tangled) to their respective files, meaning that Emacs does not read from this file at all. The main benefit of doing this is speed, Emacs only has to worry about the code parts, not finding the code among the prose (its more complicated than this but thats the gist). My configuration is structured as follows:
- =init.el= :: This is the file Emacs reads from after starting. Here I take care of the some the fundamental stuff like setting up package management, checking if the feature configuration macro (~use-package~) is installed, and loading my configuration modules.
- =cur-config= :: This is the directory I keep all my configuration modules in. Each "module" is really just an Emacs Lisp file that configures a part of Emacs. Although these are Emacs Lisp files and I /could/ write anything in here (it is a complete programming language), I try to keep extending the functionalities of Emacs out of these files. These files tend to only set variables (settings in Emacs) and change key bindings.
- =cur-lisp= :: This directory contains modules that extend the functionality of Emacs or Emacs packages. A good example is my custom [[info:emacs#Mode Line][mode line]], which I find cleaner that the default.
- =themes= :: This is the directory where I store themes to change the color scheme of Emacs. It needs a major overhaul and can effectively ignored.

* Initialization of Emacs (=init.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./init.el
:ID:       38c3c91c-fcd9-48e1-8fe8-bef0085a12fc
:END:

This is the beginning of my configuration. All code in here gets tangled out into =init.el= and is loaded by Emacs on startup.

** =init.el= section on Emacs version check
:PROPERTIES:
:ID:       16193924-963c-4e0c-b2c8-34b65c7ce743
:END:

This is to check what version of Emacs is being used. I do not test this configuration on any Emacs version less than 29.4. Using this configuration on any version less than 29.4 could lead to [[https://youtube.com/watch?v=xtrqYdvZ29E][unforeseen consequences]].

#+begin_src emacs-lisp
;; ===Check Emacs Version===
(when (version< emacs-version "29.4")
  (error "This setup is only guarunteed to work on 29.4, disable this line to load anyways."))
#+end_src

** =init.el= section on some basic settings
:PROPERTIES:
:ID:       5ba13056-a274-4213-af86-dadd25293fb4
:END:

These are some basic settings that I want Emacs to load up front. Most of them are built in or core to the function of Emacs. If the rest of my configuration fails to load, I would like to at minimum have these settings enabled. There are comments next to each of them explaining what each of them does. The only exception is the one setting the scratch buffer.

#+begin_src emacs-lisp
;; ===Basic Settings===
(setq frame-title-format "%b")      ; Set window title to buffer name
(setq initial-scratch-message ";; Scratch Buffer\n\n")
(setq initial-buffer-choice t)      ; Scratch as initial buffer
(setq make-backup-files nil)        ; No more file~ everywhere
(setq inhibit-startup-message t)    ; Starts on blank screen
(setq scroll-conservatively 101)    ; Enable Line by line scrolling
(setq scroll-margin 0)              ; Start scrolling when at the very top/bottom of window
(setq recenter-positions '(top bottom middle)) ; recenter line on top, then bottom, then middle
(setq use-dialog-box nil)           ; No yes-no-p for mouse clicks
(setq use-short-answers t)          ; Use y-or-n-p for yes-no dialogue.
(setq async-shell-command-buffer 'new-buffer) ; Create new buffer or each async-shell-command
(scroll-bar-mode -1)                ; Disable visible scrollbar
(tool-bar-mode -1)                  ; Disable tool bar
(menu-bar-mode -1)                  ; Disable menu bar
(tooltip-mode -1)                   ; Disable tooltips
(set-fringe-mode 10)                ; No idea what this does
#+end_src

** =init.el= section on enabling disabled functions
:PROPERTIES:
:ID:       3b95a744-fb39-4582-8652-78c4bad57520
:END:

These functions are disabled by default, meaning Emacs will ask me to confirm if I really want to run them. This makes sense for beginners but I use these functions often enough that I want them enabled.

#+begin_src emacs-lisp
;; ===Enable Disabled Functions===
(dolist (c '(narrow-to-region narrow-to-page upcase-region downcase-region))
  (put c 'disabled nil))
#+end_src

** =init.el= section on "disabling" custom
:PROPERTIES:
:ID:       e3f462eb-1464-45e6-84e5-a17cfee2797b
:END:

Set ~custom-file~ to a temp file so I don't have to deal with custom. This is a tip I learned from [[https://protesilaos.com/emacs/dotemacs#h:f2ffe0e9-a58d-4bba-9831-cc35940ea83f][Protesilaos' config]]. If you are just starting with Emacs you may want to consider using =M-x customize= and friends in the interim. However, in the long run it will limit you and I recommend learning the basics of elisp as quickly as you can. If you have little to no prior experience to programming, consider reading [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][An Introduction to Programming in Emacs Lisp]]. It is a book written for non-technical people and should provide a solid base for you to work on your configuration and extend Emacs' capabilities.

#+begin_src emacs-lisp
;; ===Disable Custom===
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** =init.el= section on package.el and package archives
:PROPERTIES:
:ID:       e6684d48-0111-450f-9809-a587079ee9ec
:END:

This is only used if I find myself on a non-nixos system, as I have nixos manage my Emacs packages instead.

#+begin_src emacs-lisp
;; ===Package Initialization===
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("elpa" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/"))) ;; Setting Repos
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

** =init.el= section on use-package
:PROPERTIES:
:ID:       095c9460-65d2-4884-ab8f-e3ea428863e7
:END:

Requiring ~use-package~ as that is what I use for almost all of my configuration. It is a macro that allows for easily declaring configuration for a specific [[info:elisp#Named Features][feature]] (think a program or plug-in within Emacs). Please read the [[info:use-package][info manual]] for how to use it and use [[https://jwiegley.github.io/use-package/keywords/][this keyword overview]] for a quick a reference if you need a refresher while using the macro.

#+begin_src emacs-lisp
;; ===use-package Initialization===
(require 'use-package)
#+end_src

** =init.el= section on configuration modules.
:PROPERTIES:
:ID:       5f5ac6fb-9a3e-4c61-b585-f5a19c10f9f9
:END:

First, I add the =cur-lisp= and =cur-config= to the ~load-path~. Then its just as simple as ~(require 'module)~.

#+begin_src emacs-lisp
;; ===Load Modules and Packages===
(dolist (path '("cur-lisp" "cur-config"))
  (add-to-list 'load-path (locate-user-emacs-file path)))

(require 'cur-config-essentials)
(require 'cur-config-bindings)
(require 'cur-config-dired)
(require 'cur-config-faces)
(require 'cur-config-completion)
(require 'cur-config-window)
(require 'cur-config-ide)
(require 'cur-config-shell)
(require 'cur-config-org)
(require 'cur-config-net)
(require 'cur-config-direnv) ; Direnv is the last to be loaded

(provide 'init)
#+end_src

* Configuration Modules (=cur-config=)
:PROPERTIES:
:ID:       9eb5052a-d247-44f4-95bf-0747de210827
:END:

The following are the modules that the =init.el= loads.

** Essential configuration (=cur-config-essentials.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-essentials.el
:ID:       56443852-8eb0-4c6d-9d51-fe8d48d6ab66
:END:

These are the basic configurations that I have done in Emacs. Its sort of a hodge-podge of fixing/changing things that are built Emacs. They aren't strictly essential so the name is kind of a misnomer.

*** =cur-config-essentials.el= section on parentheses highlighting
:PROPERTIES:
:ID:       861dafb4-2509-481d-8ca4-21be9174cdb1
:END:

=paren= is what highlights the matching parenthesis, bracket, brace, etc. of the one next to point. For some reason the default is to have delay in the highlight that is just long enough that it makes Emacs seem slow when it actually isn't.

#+begin_src emacs-lisp
;; ===Parens===
(use-package paren
  :ensure nil
  :demand t
  :custom
  (show-paren-delay 0 "No delay for paren highlighting"))
#+end_src

*** =cur-config-essentials.el= section on line numbers
:PROPERTIES:
:ID:       8869ca67-28b7-43bc-93e4-ea28dbf87807
:END:

I like having absolute line numbers, especially since the meow number selection makes relative line numbers not as useful. Some modes, especially terminal and shell modes, look weird with line numbers so I disable them. I also have them disabled in modes like =org-mode= which have non-textual elements (e.g. images) because they make the buffer look janky.

#+begin_src emacs-lisp
;; ===Line Numbers===
(use-package emacs
  :custom
  (display-line-numbers-type t)
  :config
  (column-number-mode 1)
  (global-display-line-numbers-mode 1)
  ;; Disable line numbers for terminal modes
  (dolist (mode '(bookmark-bmenu-mode-hook
                  org-mode-hook
                  dired-mode-hook
                  term-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  eshell-mode-hook
                  eat-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode -1)))))

#+end_src

*** =cur-config-essentials.el= section on bookmark settings
:PROPERTIES:
:ID:       e62f628a-9d35-4526-8a1e-4e30d17bece8
:END:

The built in bookmark feature of Emacs is great and one of the pillars of making Emacs a one-stop-shop for all* your computing needs. Really the only changes that I need to make is to set bookmarks to autosave and for  =hl-line-mode= to be enabled in =bookmark-bmenu-mode=.

#+begin_src emacs-lisp
;; ===Bookmarks===
(use-package bookmark
  :commands (bookmark-set
             bookmark-set-no-overwrite
             bookmark-jump
             bookmark-bmenu-list)
  :hook (bookmark-bmenu-mode . hl-line-mode)
  :config
  (setq bookmark-save-flag 1))
#+end_src

*** =cur-config-essentials.el= section on recent files
:PROPERTIES:
:ID:       afd9b978-9ce9-4a22-a6d5-05115ac660dc
:END:

This sets emacs to save the most recently visited files. I enable this primarily for quick file access.

#+begin_src emacs-lisp
(use-package recentf
  :hook (emacs-startup . recentf-mode))
#+end_src

*** =cur-config-essentials.el= section on ~isearch~ and incremental searching
:PROPERTIES:
:ID:       9f9b16a7-d53f-4ae5-84c7-d3eff7f604e4
:END:

=isearch=, or incremental search, is Emacs' primary incremental search (shocker). I mainly use it where my usual searching methods (see the section on =meow= and =consult=) aren't available or convenient like in =info= buffers. It is also very good for working with [[info:emacs#Keyboard Macros][keyboard macros]].

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :demand t
  :custom
  (isearch-wrap-pause 'no-ding)
  (isearch-repeat-on-direction-change t)
  :config
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format "(%s/%s) ")
  (setq lazy-count-suffix-format nil))
#+end_src

*** =cur-config-essentials.el= section on ~occur~ and finding regexp occurrences
:PROPERTIES:
:ID:       be1322cb-70d6-4c7f-9a9d-ae2b4a552cc2
:END:

~occur~ is a command to find occurrences in a buffer that match a regexp and display those matches in a ~compile~ like buffer. This allows you to quickly see and edit patterns of text. It's useful but has the draw back of not being search-as-you-type.

#+begin_src emacs-lisp
(use-package emacs
  :custom (list-matching-lines-jump-to-current-line nil)
  :bind ( :map occur-mode-map
	  ("RET" . occur-mode-goto-occurrence-other-window)
	  :map search-map
	  ("o" . occur)))
#+end_src

*** =cur-config-essentials.el= section on ~grep~ and searching with grep in emacs
:PROPERTIES:
:ID:       f8a5f08e-cb9f-4e81-b124-09258d3d54f0
:END:

Emacs provides nice wrappers around standard cli commands such as grep. You can run grep with the aptly named ~grep~ command which will put all of the results in a ~compile~ like buffer. However, using grep this way isn't much more useful than using Emacs' built in ~occur~. What's more useful is grepping over multiple files which is what ~lgrep~ and ~rgrep~ are for. I also have emacs set to use ripgrep instead of grep if it is available.

#+begin_src emacs-lisp
(use-package grep
  :ensure nil
  :commands (grep lgrep rgrep)
  :custom
  (grep-save-buffers 'ask)
  :bind ( :map search-map
	  ("d" . lgrep)
	  ("r" . rgrep)
	  :map grep-mode-map
	  ("M-e" . compilation-next-file)
	  ("M-a" . compilation-previous-file))
  :config
  (let ((rg-found (executable-find "rg")))
    (setopt grep-template (if rg-found
			      "rg --no-heading -nH --null -e <R> <F>"
			      "grep <X> <C> -nH --null -e <R> <F>"))
    (setopt xref-search-program (if rg-found 'ripgrep 'grep))))
#+end_src

*** =cur-config-essentials.el= section on ~proced~ and viewing process (htop like)
:PROPERTIES:
:ID:       43057235-3fa9-4f74-a68f-805448523905
:END:

=proced= provides an htop like overview of what processes are running. Though I mainly use [[https://github.com/ClementTsang/bottom][bottom]] because of its pretty visuals, I do find it occasionally useful.

#+begin_src emacs-lisp
(use-package proced
  :ensure nil
  :if (eq system-type 'gnu/linux)
  :commands (proced)
  :custom
  (proced-auto-update-flag t)
  (proced-enable-color-flag t)
  (proced-auto-update-interval 2)
  (proced-descend t)
  (proced-filter 'user))
#+end_src

*** =cur-config-essentials.el= section on starting the Emacs server
:PROPERTIES:
:ID:       f526082c-4ebe-42b6-95b0-155e98dc7786
:END:

Its no secret that Emacs has a slow startup time when compared to other text editors like ([[https://neovim.io/][neo]])[[https://www.vim.org/][vim]]. This is an often cited reason to use X editor instead of Emacs. However, I practically never have to deal with slow startup times by using [[info:emacs#Emacs Server][Emacs' server functionality]]. This allows me to have to the best of both worlds: I can have a long lived Emacs session, only dealing with startup once and I can spawn and kill ad hoc Emacs Client frames for any need. I often spawn these ad hoc frames when working on school work or browsing media I have downloaded.

The typical way to start Emacs as a server is to run ~emacs --daemon~ or start it as a systemd service. However, I prefer to launch it as a part of my configuration 1 second after Emacs launches, but only if a sever is not already running. I do this so that Emacs sort of just "does what I mean" with out having to set up a service or make sure I use the appropriate flag.

#+begin_src emacs-lisp
(use-package server
  :defer 1
  :config
  (setq server-client-instructions nil)
  (unless (server-running-p)
    (server-start)))
#+end_src

*** =cur-config-essentials.el= section on ~tmr~ (tomato timer in emacs)
:PROPERTIES:
:ID:       57ae1e8f-83da-4f1a-96ad-770d88ffcdce
:END:

[[https://protesilaos.com/emacs/tmr][TMR]] is a simple tomato timer in Emacs with a convenient notation.

#+begin_src text :tangle ./packages.txt :padline no
tmr
#+end_src

#+begin_src emacs-lisp
(use-package tmr
  :defer t)
#+end_src

*** =cur-config-essentials.el= section on ~which-key~ and showing key bindings
:PROPERTIES:
:ID:       f98928ad-7a8d-47f1-be1f-c6fb33c35294
:END:

[[https://github.com/justbur/emacs-which-key][~which-key~]] shows you what keybindings are available in a keychord. Super helpful and +a must have in Emacs+ will be a part of Emacs 30 🎉.

#+begin_src text :tangle ./packages.txt :padline no
which-key
#+end_src

#+begin_src emacs-lisp
;; ===which-key===
(use-package which-key
  :demand t
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1.0))
#+end_src

*** =cur-config-essentials.el= call to ~provide~
:PROPERTIES:
:ID:       2d610426-19cb-42e2-9a50-fee49ffca0ba
:END:

At the bottom of all Emacs Lisp libraries a all to ~provide~ with the name of the library is required. For example, if the file is named =foobar.el= the call to provide will be ~(provide 'foobar)~. At the end of each my configuration modules there will be a call to provide but I will not really document it as it is documented here.

#+begin_src emacs-lisp
(provide 'cur-config-essentials)
#+end_src

** Key bindings configurations (=cur-config-bindings.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-bindings.el
:ID:       c6c1b5c2-a355-42d3-9e0b-ec3521726fae
:END:

This module is the base of my key bindings. I use [[https:github.com/meow-edit/meow][meow]], a modal editing layer designed to be well integrated into the rest of the Emacs ecosystem. It's very easy to hack on and extend and just feels more Emacsy (e.g. using regular keymaps instead of =general.el=). I have had almost no issues with this, compared to evil which just felt sluggish and was hard to customize. The object-verb syntax is also really great and I prefer it to the verb-object of vim/nvim. There are also some other things I use in this section, such as ~repeat-mode~ and ~hydra~.

*** =cur-config-bindings.el= section on ~repeat-mode~ and repeating key bindings
:PROPERTIES:
:ID:       a78dad5e-2675-4530-a3ea-8066f102905c
:END:

~repeat-mode~ is one of the most basic ways to make working with standard Emacs key bindings a breeze. In its simplest form, it allows you to be able to simply repeat a key with out a prefix or modifiers. For example, instead of having to type =C-x o C-x o C-x o C-x o= to cycle through 4 windows, you would just keep hitting the =o= key, typing =C-x o o o o=. In more advanced cases you have several (often related) commands that are just a key-press away. This is one of those features that, in my opinion, should just be enabled by default in Emacs. This is [[info:emacs#Repeating][section in the manual]] talks about it some and this [[https://karthinks.com/software/it-bears-repeating/][blog post]] by [[https://karthinks.com/][karthinks]] goes very in depth into what ~repeat-mode~ can do.

#+begin_src emacs-lisp
;; ===Repeat Mode===
(use-package emacs
  :hook (after-init . repeat-mode))
#+end_src

*** =cur-config-bindings.el= section on ~hydra~ and quick transient key maps
:PROPERTIES:
:ID:       5ec45ba2-771f-461f-835c-b6e5a6bd350d
:END:

~hydra~ is a package that makes creating ad hoc [[info:transient#Top][transient]] key maps very easy. Transient key maps are temporary keyboard driven menus, somewhere between full on modal editing and keyboard short cuts. [[info:magit#Top][magit]] is a good example of what transient key maps are capable of.

#+begin_src text :tangle ./packages.txt :padline no
hydra
#+end_src

#+begin_src emacs-lisp
;; ===Hydra===
(use-package hydra
  :demand t)
#+end_src

*** =cur-config-bindings.el= section on ~avy~ and jumping to characters
:PROPERTIES:
:ID:       fc0629a4-40b3-45fd-880f-67c14d1aee36
:END:

~avy~ is a package that allows you to quickly jump to a point on screen. I almost exclusively use ~avy-goto-char-2~ as opposed to ~avy-goto-char-timer~ since I like consistent behavior in my editing commands. ~avy~ also has commands for being able to quickly edit or select text at a point as well but I honestly never use it as I prefer using ~meow~ editing commands. If that does interest you please read [[https://karthinks.com/software/avy-can-do-anything/][this article]] by [[https://karthinks.com/][karthinks]].

#+begin_src text :tangle ./packages.txt :padline no
avy
#+end_src

#+begin_src emacs-lisp
(use-package avy
  :bind ( :map goto-map
	  ("c" . avy-goto-char-2)))
#+end_src

*** =cur-config-bindings.el= section on ~meow~ and modal key bindings
:PROPERTIES:
:ID:       d0be41a7-a02d-4c61-a980-3a2bef444971
:END:

[[https://github.com/meow-edit/meow][meow]] is a package that implements modal editing in Emacs in a very unobtrusive way. By default ~meow~ provides a well thought out set of editing commands (which are just wrappers around the default Emacs editing commands) and states (~meow~'s analog to ([[https://neovim.io/][neo]])[[https://www.vim.org/][vim's]] modes). Much of the beauty of ~meow~ is how its all just normal Emacs concepts under the hood ([[info:emacs#Keymaps][keymaps]], [[info:elisp#Defining Commands][interactive functions]], [[info:emacs#Keyboard Macros][keyboard macros]], etc.) making it trivial to mold and shape ~meow~ to what you need it to be. Contrast this to [[https://github.com/emacs-evil/evil][evil]] (vim emulation in Emacs) which I found to be more confusing, less extensible, and very slow. One of the primary things I like about ~meow~ is its inversion of (neo)vim's (and Emacs') typical model of action -> selection. ~meow~ follows [[https://kakoune.org/][kakoune's]] and [[https://helix-editor.com/][helix's]] approach which is selection -> action. This to me feels very logical and, in my option, should be the default way things should operate. Please read these parts of [[https://karthinks.com/software/fifteen-ways-to-use-embark/][these]] [[https://karthinks.com/software/emacs-window-management-almanac/#window-magic-with-ace-window-dispatch][blog]] [[https://karthinks.com/software/avy-can-do-anything/#adc2ee][posts]] by [[https://karthinks.com/][karthinks]] on some of the theory behind this if you are interested (I cover ~embark~ and ~ace-window~ later in my configuration and I covered avy previously in my configuration).

There is a lot that ~meow~ is capable of so instead of trying to say what has been said better by others I will leave you with how I learned ~meow~. First I followed along with each of the [[https://github.com/meow-edit/meow?tab=readme-ov-file#documents][documents listed in the README]]. This will take you through installation, the tutorial (available with =M-x meow-tutor RET=), list of commands and customization options, and the explanation of the concepts behind ~meow~. Read all of it (except for maybe the changelog) and do what the documentation says. It is a very well documented and you will thank yourself in the future for having read it. On a side note, if you are coming from (neo)vim, please read the [[https://github.com/meow-edit/meow/blob/master/VIM_COMPARISON.org][comparison sheet]]. Next you are going to want to make the key bindings what you find comfortable to type and behave the way you want them too. To do this I suggest you write something long and relatively unimportant while using these ~meow~ key bindings *and only ~meow~ keybindings*. It doesn't really matter what it is, an essay, a program, a collection notes, some sort of hybrid documentation-Emacs-lisp code base (hey, wait a second!). Something that will force you to find what is comfortable, find what is not, and get familiar with the way ~meow~ does editing. Personally I found something close to the defaults to be what is most comfortable for me but I have seen others who have completely unique layouts and states.

The ~meow~ default states, what (neo)vim call modes, are as follows:
- *Normal* - The main state that is used. Used for navigation, selection, and editing. Basically vim's normal and visual mode in one.
- *Insert* - Insert text like normal Emacs, =ESC= to go back to *Normal* state.
- *Motion* - A minimal state used when you don't know what the ~major-mode~ does. I have only =j=, =k=, and =SPC= bound to down, up, and *Keypad* respectively. Everything else is as the major mode defines it. It's just there so I'm still able to interface with Emacs like I normally would, just with a minimal interface.
- *Keypad* - This is effectively my leader key (if you are coming from (neo)vim). I use this for quick access to important commands and keymaps that I want available globally. I also use this as a translation layer so I don't have to use modifier keys for Emacs commands under =C-x= and =C-c= (=x= and =c= in *Keypad* respectively). Please consult [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org][meow's web tutorial]] for a better explanation on how to use it. This is very convenient for dealing with Emacs' infamous long key chords but can sometimes become tedious if most of the keys are lower case. 
- *Beacon* - Beacon creates multiple cursors over a region. Basically you create a [[info:emacs#Secondary Selection][secondary selection]] and your actions automatically get converted into a keyboard macro that gets played where all of your cursors are. Please read [[https://github.com/meow-edit/meow/blob/master/TUTORIAL.org#beacon][here]] for a better explanation or go through the tutorial (type =M-x meow-tutor RET=).
I use the default states but there is no stopping you from making your own.

I have several key maps I define for use under the *Keypad* state: ~cur/sub-leader-keymap~, ~cur/toggle-map~, and ~cur/register-map~. ~cur/sub-leader-map~ is for more miscellaneous one-off commands that I want quick access to, such as ~ibuffer~. ~cur/toggle-map~ is for quick, on the fly, changing of settings, such as the font size and theme. ~cur/register-map~ is for register related commands such as ~jump-to-register~ or ~copy-to-register~. In addition to the key maps I define, I also use the built in ~project-prefix-map~ for project / version control related commands. I try to keep the leader key map as static as possible, with no keybindings being changed with the mode. If I want something to change with the mode I will put it under =C-c=, which I can access under =c= in *Keypad* and under =RET= in *Normal*. The leader key primarily has things for interacting with general Emacs constructs, like buffers, universal arg, =M-x=, etc.

Under *Normal* state I try to reuse Emacs functionality and key maps, such as binding the ~goto-map~ under =v=. This maximizes my ability to draw from standard Emacs functionality and makes Emacs feel far more consistent. The only thing I am missing is bringing ~search-map~ into the mix but I will address that in due time.

Also of note, I find it easier to think about the cursor in normal mode as being a single character selection. This is how helix does it and I really like it so I have a lot of the meow fallback commands to operate on the char after the cursor. There are sometimes I have to think about it in the normal Emacs way of being between two characters but after using it for a while you get used to it.

A cheatsheet for the normal state can be accessed via =M-x meow-cheatsheet RET=.

Currently ~meow~ is broken in the Emacs overlay so I am including the package from mepla stable instead.

#+begin_src text :tangle ./packages.txt :padline no
meow
#+end_src

#+begin_src emacs-lisp
;; ===Meow Setup===
(use-package meow
  :after (hydra)
  :demand t
  :preface
  (defvar cur/sub-leader-keymap
    (let ((map (make-sparse-keymap)))
      map)
    "The keymap for quick command/function execution.")
  (defvar cur/toggle-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for commands that change settings from the leader key.")
  (defvar cur/register-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for commands that use registers.")
  (defun cur/shell-filter-active-region ()
    (interactive)
    (if (region-active-p)
        (shell-command-on-region (region-beginning) (region-end)
                                 (read-shell-command "Filter Region with: ")
                                 1 1)
      (user-error "The region is not currently active")))
  (defhydra cur/window (:hint nil)
    "
^Movement^            ^Splitting and Balancing^   ^Manipulation^       ^Resizing^
^--------^------------^-----------------------^---^------------^-------^--------^---------------------
_h_: left             _._: only window            _H_: swap left       _i_: enlarge window
_j_: down             _v_: split vertical         _J_: swap down       _r_: shrink window
_k_: up               _s_: split horizontal       _K_: swap up         _f_: enlarge window horizonally
_l_: right            _=_: balance windows        _L_: swap right      _b_: shrink window horizonally
_o_: other window     _F_: fit to buffer          _d_: close window
"
    ("RET" ignore "finished" :exit t)

    ("o" other-window)
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)

    ("." delete-other-windows)
    ("v" split-window-right)
    ("s" split-window-below)
    ("=" balance-windows)
    ("F" fit-window-to-buffer)

    ("H" windmove-swap-states-left)
    ("J" windmove-swap-states-down)
    ("K" windmove-swap-states-up)
    ("L" windmove-swap-states-right)
    ("d" delete-window)

    ("i" enlarge-window)
    ("r" shrink-window)
    ("f" enlarge-window-horizontally)
    ("b" shrink-window-horizontally))
  (defun cur/reverse-other-window ()
    (interactive)
    (other-window -1))
  (defun meow-setup ()
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; ===Top Row===
     '("1" . digit-argument)
     '("2" . digit-argument)
     '("3" . digit-argument)
     '("4" . digit-argument)
     '("5" . digit-argument)
     '("6" . digit-argument)
     '("7" . digit-argument)
     '("8" . digit-argument)
     '("9" . digit-argument)
     '("0" . digit-argument)

     ;; ===2nd Row===
     ;; '("TAB"  . )
     '("q" . meow-comment) ; comment dwim
     ;; '("w" . ) ; bound in ace-window section
     '("W" . cur/window/body)
     ;; '("e" . ) ; bound in popper section
     (cons "r" cur/register-map)
     (cons "t" cur/toggle-map)
     ;; '("y" . )
     '("u" . "C-u")   ; universal argument
     ;; '("i" . ) ; bound in popper section
     '("o" . other-window) ; other window
     (cons "p" project-prefix-map)
     ;; '("-" . )

     ;; ===3rd Row===
     ;; '("<escape>" . )
     ;; '("a" . )
     '("s" . "C-x C-s") ; save buffer
     '("d" . kill-current-buffer)
     '("f" . "C-x C-f") ; find file
     ;; '("g" . ) ; C-M- map
     ;; '("h" . ) ; C-h map
     ;; '("j" . )
     ;; '("k" . )
     ;; '("l" . )
     (cons ";" cur/sub-leader-keymap)
     '("RET"   . "M-x")

     ;; ===4th Row===
     ;; '("z" . )
     ;; '("x" . ) ; C-x map
     ;; '("c" . ) ; C-c map
     '("C" . capitalize-dwim)
     (cons "v" search-map)
     '("b" . "C-x b")
     ;; '("n" . )
     ;; '("m" . ) ; M- map
     '("," . meow-beginning-of-thing)
     '("." . meow-end-of-thing)
     '("/" . rg)
     ;; '("'"  . )
     )
    (meow-normal-define-key
     ;; ===Special===
     '("|" . cur/shell-filter-active-region)

     ;; ===Top Row===
     '("1" . meow-expand-1)
     ;; '("!" . )
     '("2" . meow-expand-2)
     ;; '("@" . )
     '("3" . meow-expand-3)
     ;; '("#" . )
     '("4" . meow-expand-4)
     ;; '("$" . )
     '("5" . meow-expand-5)
     '("%" . meow-query-replace)
     '("6" . meow-expand-6)
     ;; '("^" . )
     '("7" . meow-expand-7)
     ;; '("&" . )
     '("8" . meow-expand-8)
     ;; '("*" . )
     '("9" . meow-expand-9)
     '("(" . meow-start-kmacro)
     '("0" . meow-expand-0)
     '(")" . meow-end-kmacro)

     ;; ===2nd Row===
     ;; '("TAB"  . )
     ;; '("BTAB" . )
     ;; '("q" . )
     '("Q" . kmacro-end-and-call-macro)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("t" . meow-till)
     '("T" . meow-till-expand)
     '("y" . meow-save)
     '("Y" . meow-clipboard-save)
     '("u" . meow-undo)
     ;; '("U" . )
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("P" . meow-yank-pop)
     '("-" . negative-argument)
     ;; '("_" . )

     ;; ===3rd Row===
     '("<escape>" . keyboard-quit)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("s" . repeat)
     ;; '("S" . )
     '("d" . meow-kill)
     '("D" . meow-c-k)
     '("f" . meow-find)
     '("F" . meow-find-expand)
     '("g" . meow-cancel-selection)
     ;; '("G" . )
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '(";" . meow-reverse)
     ;; '(":" . )
     ;; '("RET" . )
     ;; '("S-RET" . )

     ;; ===4th Row===
     '("z" . meow-pop-selection)
     ;; '("Z" . )
     '("x" . meow-line)
     '("X" . meow-line-expand)
     '("c" . meow-change)
     '("C" . meow-sync-grab)
     (cons "v" goto-map)
     ;; '("V" . )
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("n" . meow-search)
     '("N" . meow-visit)
     '("m" . meow-join)
     ;; '("M" . )
     '("," . meow-bounds-of-thing)
     '("<" . beginning-of-buffer)
     '("." . meow-inner-of-thing)
     '(">" . end-of-buffer)
     '("/" . meow-visit)
     ;; '("?" . )
     '("'" . meow-grab)
     '("\"" . meow-pop-grab)))
  :init
  (defhydra cur/hydra-buffer-cycle (:timeout 4)
    "tab through buffers"
    ("n" next-buffer "next buffer")
    ("p" previous-buffer "previous buffer")
    ("f" nil "finished" :exit t)
    ("RET" nil "finished" :exit t))
  :custom
  (meow-mode-state-list
   '((authinfo-mode . normal)
     (beancount-mode . normal)
     (bibtex-mode . normal)
     (cider-repl-mode . normal)
     (cider-test-report-mode . normal)
     (cider-browse-spec-view-mode . motion)
     (cargo-process-mode . normal)
     (conf-mode . normal)
     (deadgrep-edit-mode . normal)
     (deft-mode . normal)
     (diff-mode . normal)
     (dired-mode . motion)
     (eat-mode . insert)
     (ediff-mode . motion)
     (eshell-mode . insert)
     (gud-mode . normal)
     (haskell-interactive-mode . normal)
     (help-mode . motion)
     (helpful-mode . normal)
     (json-mode . normal)
     (jupyter-repl-mode . normal)
     (mix-mode . normal)
     (occur-edit-mode . normal)
     (pass-view-mode . normal)
     (prog-mode . normal)
     (py-shell-mode . normal)
     (restclient-mode . normal)
     (telega-chat-mode . normal)
     (term-mode . normal)
     (text-mode . normal)
     (vterm-mode . insert)
     (Custom-mode . normal))
   "Default meow states for modes")
  (meow-selection-command-fallback
   '((meow-change . meow-change-char)
     (meow-kill . meow-C-d)
     (meow-cancel-selection . keyboard-quit)
     (meow-pop-selection . meow-pop-grab)
     (meow-beacon-change . meow-beacon-change-char))
   "Meow fallback commands")
  (meow-keypad-describe-delay 0.0 "No delay in keypad help popup")
  (meow-cheats-layout meow-cheatsheet-layout-qwerty "Meow qwerty layout for the cheatsheet")
  (meow-keypad-leader-dispatch nil)
  (meow-visit-sanitize-completion nil)
  :bind ( :map cur/sub-leader-keymap
          ("C-l" . ibuffer)
          ("C-b" . bookmark-set-no-overwrite)
          ("C-c" . compile)
          :map cur/register-map
          ("C-j" . jump-to-register)
          ("C-." . point-to-register)
          ("C-y" . copy-to-register)
          ("C-p" . insert-register)
          ("C-w" . window-configuration-to-register)
          ("C-n" . number-to-register)
          ("C-+" . increment-register)
          ("C-q" . kmacro-to-register)
          :map goto-map
          ("e a" . first-error)
          ("e n" . next-error)
          ("e p" . previous-error)
          (","   . xref-go-back)
          ("d"   . xref-find-definitions)
          ("r"   . xref-find-references)
          ("A"   . xref-find-apropos)
          ("h"   . move-beginning-of-line)
          ("j"   . end-of-buffer)
          ("k"   . beginning-of-buffer)
          ("l"   . move-end-of-line)
          ("J"   . next-logical-line)
          ("K"   . previous-logical-line)
          ("s"   . back-to-indentation)
          :map next-error-repeat-map
          ("a" . first-error))
  :config
  (meow-setup)
  (meow-global-mode 1))

(use-package meow
  :if (locate-library "ace-window.el")
  :config
  (meow-leader-define-key
   '("w" . ace-window)))

(use-package meow
  :if (locate-library "popper.el")
  :config
  (meow-leader-define-key
   '("e" . popper-toggle)
   '("i" . popper-cycle)))

(use-package cur-meow
  :after (meow)
  :bind ( :map cur/sub-leader-keymap
          ("C-n" . cur-meow-toggle-temp-normal-motion)))
#+end_src

*** =cur-config-bindings.el= section on ~meow-tree-sitter~
:PROPERTIES:
:ID:       9082076e-8399-470a-8778-83c9c800065d
:END:

This integrates ~meow~'s thing system with tree-sitter, allowing me to quickly select classes, functions, arguments, etc. This is not a complete system for structural editing but it is a good component.

#+begin_src text :tangle ./packages.txt :padline no
meow-tree-sitter
#+end_src

#+begin_src emacs-lisp
(use-package meow-tree-sitter
  :after meow
  :config
  (meow-tree-sitter-register-defaults))

#+end_src

*** =cur-config-bindings.el= call to ~provide~
:PROPERTIES:
:ID:       e866972a-7579-4005-938d-b068c9a6c660
:END:

#+begin_src emacs-lisp
(provide 'cur-config-bindings)
#+end_src

** Dired configuration (=cur-config-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-dired.el
:ID:       fe71ad88-6ff2-4974-a849-f0e5ff9bc906
:END:

Dired is the built in file manager in Emacs. Its very capable and very hackable although it lacks good file previewing solutions

*** =cur-config-dired.el= section on ~nerd-icons-dired~ and file icons
:PROPERTIES:
:ID:       d413c669-dc46-41e6-a7b3-e3415d847e28
:END:

Adds icons to make dired a bit more pretty and gives a visual sense of what files are what. 

#+begin_src text :tangle ./packages.txt :padline no
nerd-icons-dired
#+end_src

#+begin_src emacs-lisp
;; ===Dired Icons===
(use-package nerd-icons-dired
  :after (dired)
  :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** =cur-config-dired.el= section on the main ~dired~ configuration
:PROPERTIES:
:ID:       18cf0d85-e484-4b03-98c1-cc016c928b17
:END:

By default, I want dired to look very minimal. This lack of clutter makes it easier to focus on what I am doing in the file manager. This is also the approach I try to take with other parts of Emacs as well. By default, I have file details (owner, permissions, last modified, etc.) hidden. I have other changes as well, use the system trash can instead of deleting, that are under the ~:config~ part of the ~use-package~ declaration.

The keybindings are a hybrid of my normal state and the default dired keybindings.

#+begin_src emacs-lisp
;; ===Dired===
(use-package dired
  :ensure nil
  :hook
  (dired-mode . dired-hide-details-mode) ; don't show file details by default
  (dired-mode . hl-line-mode) ; Highlight the line the cursor is on
  (dired-mode . (lambda (&rest _)
		  (setq-local truncate-lines t)))
  ;; TODO: create a dired-find-file-dwim for external programs
  :bind ( :map dired-mode-map
          ;; ===Top Row===
          ;; ("1" . )
          ("!" . dired-do-shell-command)
          ;; ("2" . )
          ;; ("@" . )
          ;; ("3" . )
          ;; ("#" . )
          ;; ("4" . )
          ;; ("$" . )
          ;; ("5" . )
          ;; ("%" . )
          ;; ("6" . )
          ;; ("^" . )
          ;; ("7" . )
          ("&" . dired-do-async-shell-command)
          ;; ("8" . )
          ;; ("*" . )
          ;; ("9" . )
          ;; ("(" . )
          ;; ("0" . )
          ;; (")" . )

          ;; ===2nd Row===
          ("TAB"  . dired-hide-subdir)
          ("<backtab>" . dired-hide-all)
          ("q" . quit-window)
          ;; ("Q" . )
          ("w" . dired-mark-subdir-files)
          ;; ("W" . ) ; Bound it custom wallpaper settings
          ("e" . dired-next-subdir)
          ;; ("E" . )
          ("r" . dired-do-rename)
          ("R" . dired-do-rename-regexp)
          ("t" . dired-toggle-marks)
          ("T" . dired-kill-tree)
          ("y" . dired-copy-filename-as-kill)
          ;; ("Y" . )
          ("u" . dired-unmark)
          ("U" . dired-unmark-all-marks)
          ("i" . dired-toggle-read-only)
          ("I" . image-dired)
          ("o" . dired-do-async-shell-command)
          ("O" . dired-do-chown)
          ("p" . dired-next-marked-file)
          ;; ("P" . )
          ("-" . negative-argument)
          ;; ("_" . )

          ;; ===3rd Row===
          ("<escape>" . keyboard-quit)
          ("a" . dired-find-alternate-file)
          ;; ("A" . dired-find-alternate-file)
          ("s" . dired-kill-subdir)
          ("S" . dired-kill-tree)
          ("d" . dired-do-kill-lines)
          ("D" . dired-do-delete)
          ("f" . dired-goto-file)
          ("F" . dired-goto-subdir)
          ("g" . revert-buffer)
          ;; ("G" . )
          ("h" . dired-up-directory)
          ;; ("H" . )
          ;; ("j" . ) ; already bound in meow-motion-mode
          ;; ("J" . )
          ;; ("k" . ) ; already bound in meow-motion-mode
          ;; ("K" . )
          ;; ("l" . ) ; bound in cur-dired declaration
          ("L" . dired-find-file-other-window)
          (";" . dired-toggle-marks)
          (":" . scroll-down-command)
          ("RET" . dired-find-file)
          ("S-RET" . dired-find-file-other-window)

          ;; ===4th Row===
          ("z" . dired-undo)
          ;; ("Z" . )
          ("x" . dired-mark)
          ("X" . dired-mark-files-regexp)
          ("c" . dired-do-copy)
          ("C" . dired-do-copy-regexp)
          ("v" . dired-view-file)
          ;; ("V" . )
          ("b" . dired-prev-subdir)
          ;; ("B" . )
          ("n" . dired-next-marked-file)
          ;; ("N" . )
          ;; ("m" . )
          ("M" . dired-do-chmod)
          ("," . dired-prev-dirline)
          ("<" . beginning-of-buffer)
          ("." . dired-next-dirline)
          (">" . end-of-buffer)
          ("/" . dired-sort-toggle-or-edit)
          ("?" . scroll-up-command)
          ;; ("'"  . ) ; Leave these blank, usually embark-act
          ;; ("\"" . ) ; Leave these blank, usually embark-dwim
          :map cur/sub-leader-keymap
          ("d" . dired))
  :custom
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (delete-by-moving-to-trash t)
  (dired-dwim-target t)
  (dired-listing-switches "-A -G -F -h -l -v --group-directories-first --time-style=long-iso")
  (dired-guess-shell-alist-user '(("\\.\\(png\\|jpe?g\\|tiff\\|gif\\)" "xdg-open" "imv" "feh")
                                  ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\|mov\\)" "xdg-open" "mpv" "vlc")
                                  ("\\.pdf" "xdg-open" "zathura")
                                  (".*" "xdg-open")))
  (dired-auto-revert-buffer #'dired-directory-changed-p)
  (dired-free-space nil)
  (dired-make-directory-clickable t)
  (dired-mouse-drag-files t)
  :config
  (setq dired-deletion-confirmer 'y-or-n-p)
  (setopt dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir)))))

(use-package cur-dired
  :after (dired)
  :bind ( :map dired-mode-map
	  ("l" . cur-dired-maybe-insert-subdir-or-find-file)))
#+end_src

*** =cur-config-dired.el= section on setting my wallpaper
:PROPERTIES:
:ID:       a9bbcca2-9303-4252-8926-b0520fb68b7a
:END:

#+begin_src emacs-lisp
(use-package cur-wallpaper
  :after (dired)
  :bind ( :map dired-mode-map
	  ("W" . cur-wallpaper-set-wallpaper-dired)))

(use-package cur-wallpaper
  :after (image-dired)
  :bind ( :map image-dired-thumbnail-mode-map
	  ("W" . cur-wallpaper-set-wallpaper)))
#+end_src

*** =cur-config-dired.el= call to ~provide~
:PROPERTIES:
:ID:       11189827-2b84-4388-b819-4cf71456230c
:END:

#+begin_src emacs-lisp
(provide 'cur-config-dired)
#+end_src

** Faces, themes, and eye candy configurations (=cur-config-faces.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-faces.el
:ID:       c81f0f60-e024-4cf2-944d-259a037dfa7e
:END:

I think that Emacs should have a lot of eye candy, especially since I spend so much time in it. These are my configurations for Emacs' faces, theming and ui settings essentially.

*** =cur-config-faces.el= section on setting the default font and ~fontaine~
:PROPERTIES:
:ID:       e47e4025-4113-407a-a0a7-f37c4f2b94c7
:END:

JetBrains Mono supremacy.

#+begin_src text :tangle ./packages.txt :padline no
fontaine
#+end_src

#+begin_src emacs-lisp
;; ===Default Font===

(use-package fontaine
  :demand t
  :bind ( :map cur/toggle-map
	  ("C-s" . fontaine-set-preset))
  :custom
  (fontaine-presets '((regular)
		      (extra-small
		       :default-height 100)
		      (small
		       :default-height 107)
		      (large
		       :default-height 140)
		      (t
		       :default-family "JetBrainsMono Nerd Font"
		       :default-weight regular
		       :default-height 110

		       :fixed-pitch-family nil
		       :fixed-pitch-weight nil
		       :fixed-pitch-height 1.0

		       :fixed-pitch-serif-family nil
		       :fixed-pitch-serif-weight nil
		       :fixed-pitch-serif-height 1.0

		       :mode-line-active-height 1.0
		       :mode-line-inactive-height 1.0)))
  :config
  (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))
  (fontaine-mode 1))
#+end_src

*** =cur-config-faces.el= section on setting the default opacity
:PROPERTIES:
:ID:       7ef99fe8-31fa-4dfe-bfa5-068a69938a2f
:END:

I have this transparency set to be the same as with my Alacritty config. This adds more consistency to my computing experience. It also just looks really cool.

#+begin_src emacs-lisp
;; ===Default Opacity===
(add-to-list 'default-frame-alist
             '(alpha-background . 85))

(use-package emacs
  :preface
  (defun cur/toggle-frame-opacity ()
    (interactive)
    (let ((current-alpha (frame-parameter nil 'alpha-background)))
      (cond ((eq current-alpha 100)
	     (set-frame-parameter nil 'alpha-background 85))
	    (t
	     (set-frame-parameter nil 'alpha-background 100)))))
  :bind ( :map cur/toggle-map
	  ("C-o" . cur/toggle-frame-opacity)))
#+end_src

*** TODO =cur-config-faces.el= section on custom themes
:PROPERTIES:
:ID:       0cfecd63-934e-47cb-bf5e-e82c478ee0c2
:END:

I have several custom themes in a directory weirdly named themes. These are the =everforest= and =kanagawa= themes. I have changed these from the originals. TODO: add the links to the original themes.

#+begin_src emacs-lisp
;; ===Themes Path===
(add-to-list 'custom-theme-load-path (locate-user-emacs-file "themes"))

;; ===Theme Library===
(use-package cur-theme
  :bind ( :map cur/toggle-map
          ("C-t" . cur-override-theme-load-theme))
  :custom
  (cur-override-theme-overrides
   '((catppuccin (company-preview :foreground (catppuccin-color 'overlay0)
                                  :background (if (eq catppuccin-flavor 'latte)
                                                  (catppuccin-darken (catppuccin-color 'base) 12)
                                                (catppuccin-lighten (catppuccin-color 'base) 17)))
                 (cur-mode-line-meow-state :background (catppuccin-color 'lavender)
                                           :foreground (catppuccin-color 'base))
                 (cur-mode-line-major-mode-active :foreground (catppuccin-color 'blue) :weight 'bold)
                 (flycheck-info :underline (list :style 'wave :color (catppuccin-color 'green)))
                 (flycheck-warning :underline (list :style 'wave :color (catppuccin-color 'yellow)))
                 (flycheck-error :underline (list :style 'wave :color (catppuccin-color 'red))))
     (doom-gruvbox (secondary-selection :background "#504945")
                   (cur-mode-line-major-mode-active :foreground "#83a598"
                                                    :weight 'bold))
     (doom-oceanic-next (cur-mode-line-major-mode-active :foreground "#6699CC"
                                                         :weight 'bold)
                        (elpher-gemini-heading1 :foreground "#ec5f67" :height 1.8 :inherit 'bold)
                        (elpher-gemini-heading2 :foreground "#6699cc" :height 1.4 :inherit 'bold)
                        (elpher-gemini-heading3 :foreground "#c594c5" :height 1.2 :inherit 'bold)
			(elpher-gemini-preformatted :foreground "#65737e" :inhert 'fixed-pitch)
			(hl-line :background "#343D46"))
     (doom-flatwhite (haskell-operator-face :background "#f7f3ee"
                                            :foreground "#605a52")
                     (haskell-type-face :background "#d2ebe3"
                                        :foreground "#465953")
                     (haskell-constructor-face :background "#f7e0c3"
                                               :foreground "#5b5143")
                     (completions-common-part :background "#dde4f2"
                                              :foreground "#7382a0"
                                              :weight 'bold)
                     (org-dispatcher-highlight :background "#f7e0c3"
                                               :foreground "#957f5f")
                     (help-key-binding :background "#f7f3ee"
                                       :foreground "#7382a0")
                     (fill-column-indicator :foreground "#b9a992")
                     (org-block :foreground "#93836c"
                                :background "#f1ece4"))
     (doom-nord (mode-line :background "#3b4252")
                (mode-line-inactive :foreground "#88c0d0"
                                    :background "#3b4252")
                (hl-line :background "#3b4252")
                (font-lock-comment-face :foreground "#4c566a")
                (org-block-begin-line :foreground "#d8dee9"
                                      :background "#3b4252"
                                      :inherit 'org-block
                                      :extend t)
                (org-block :background "#2e3440")
                (dired-broken-symlink :foreground "#ebcb8b"
                                      :background "#bf616a")
                (meow-beacon-fake-selection :foreground "#d8dee9"
                                            :weight 'bold)
                (secondary-selection :background "#3b4252")
                (vertical-border :foreground "#3b4252"
                                 :background "#3b4252")
                (help-key-binding :foreground "#88c0d0"
                                  :background "#2e3440"
                                  :box '(:line-width 1 :color "#4c566a")
                                  :inherit 'fixed-pitch)
                (corfu-default :foreground "#eceff4"
                               :background "#3b4252")
                (corfu-current :foreground "#eceff4"
                               :background "#434c5e")
                (aw-leading-char-face :foreground "#bf616a" :height 1.3)
                (aw-background-face :foreground "#4c566a"))
     (doom-tomorrow-night (mode-line-inactive :background "#0f1011")))))
#+end_src

*** =cur-config-faces.el= section on ~doom-themes~
:PROPERTIES:
:ID:       124c6009-9efd-4ca6-9a0a-14ffc0659d00
:END:

Doom themes are a theme pack specifically for the Doom Emacs distribution, but work well without doom as well. I have a function that sets some faces based on the theme in ~custom-enabled-themes~. This function is more than just a little jank and I plan on creating my own themes instead of trying to hack around ones made by someone else.

#+begin_src text :tangle ./packages.txt :padline no
doom-themes
#+end_src

#+begin_src emacs-lisp
;; ===Doom Emacs Themes===
(use-package doom-themes
  :demand t)
  ;; :config
  ;; (cur-override-theme-load-theme 'doom-flatwhite))
#+end_src

*** =cur-config-faces.el= section on ~autothemer~
:PROPERTIES:
:ID:       27ab6486-0928-425f-b089-1c42129fff25
:END:

A library used by =catppuccin= and =kanagawa=.

#+begin_src text :tangle ./packages.txt :padline no
autothemer
#+end_src

#+begin_src emacs-lisp
;; ===Autothemer===
(use-package autothemer)
#+end_src

*** =cur-config-faces.el= section on catppuccin theme
:PROPERTIES:
:ID:       805fb865-4448-4d17-a5f2-831af0ad02b5
:END:

[[https:github.com/catppuccin/catppuccin][Link]] to the catppuccin theme.

#+begin_src text :tangle ./packages.txt :padline no
catppuccin-theme
#+end_src

#+begin_src emacs-lisp
;; ===Catppuccin Theme===
(use-package catppuccin-theme
  :after (autothemer cur-theme))
#+end_src

*** =cur-config-faces.el= section on setting the default theme
:PROPERTIES:
:ID:       ceb49ec5-0266-4bca-9bfb-cbcba2d2dcce
:END:

#+begin_src emacs-lisp
(cur-override-theme-load-theme 'catppuccin)
#+end_src

*** =cur-config-faces.el= section on ~ef-themes~
:PROPERTIES:
:ID:       950fc8af-3791-4cd9-8bb0-35a9915cf659
:END:

Themes made by Protesilaos, also known as Prot.

#+begin_src text :tangle ./packages.txt :padline no
ef-themes
#+end_src

#+begin_src emacs-lisp
;; ===Ef-Themes===
(use-package ef-themes)
;; :config
;; (cur/load-theme 'ef-tritanopia-dark))
#+end_src

*** =cur-config-faces.el= section on ~nerd-icons-ibuffer~
:PROPERTIES:
:ID:       dd3258a6-a2e7-4fcf-beb8-a6d213380dc7
:END:

Adds Icons to ~ibuffer~. Not really a face thing but I don't have a dedicated ~ibuffer~ module so it goes here instead.

#+begin_src text :tangle ./packages.txt :padline no
nerd-icons-ibuffer
#+end_src

#+begin_src emacs-lisp
;; ===Ibuffer Icons===
(use-package nerd-icons-ibuffer
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** =cur-config-faces.el= section on custom mode-line
:PROPERTIES:
:ID:       9eae8c72-8268-41ee-9f37-ccd18fa50f26
:END:

#+begin_src emacs-lisp
(use-package cur-mode-line
  :custom
  (mode-line-right-align-edge 'right-fringe)
  (cur-mode-line-exclude-narrow-inidcator '(Info-mode))
  :config
  (setq-default mode-line-end-spaces
		'(""
		  cur-mode-line-flycheck-indicator
		  (:eval (when (cur-mode-line-flycheck-display-p) "  "))
		  cur-mode-line-eat-indicator
		  (:eval (when (cur-mode-line-eat-display-p) "  "))
		  cur-mode-line-eat-eshell-indicator
		  (:eval (when (cur-mode-line-eat-eshell-display-p) "  "))
		  cur-mode-line-major-mode-indicator
		  cur-mode-line-end-padding))
  (setq-default mode-line-format
		'("%e"
                  cur-mode-line-kmacro-indicator
                  cur-mode-line-narrowed-indicator
                  "  "
                  cur-mode-line-buffer-status-indicator
		  (:eval (when (cur-mode-line-meow-display-p) "  "))
                  cur-mode-line-meow-state-indicator
                  "  "
		  cur-mode-line-buffer-name-indicator
		  (:eval (when (mode-line-window-selected-p) "  "))
		  cur-mode-line-postion-indicator
		  cur-mode-line-right-align
		  mode-line-end-spaces)))
#+end_src

*** =cur-config-faces.el= section on ~page-break-lines~ and making page breaks pretty
:PROPERTIES:
:ID:       3ce920f3-5990-4aa3-bb9e-6deb0de1c2c3
:END:

#+begin_src text :tangle ./packages.txt :padline no
page-break-lines
#+end_src

#+begin_src emacs-lisp
(use-package page-break-lines
  :defer t)
#+end_src

*** =cur-config-faces.el= section on ~dashboard~ and startup overview
:PROPERTIES:
:ID:       bbc53d0c-2f80-4cf3-8685-ae56f65ad9aa
:END:

#+begin_src text :tangle ./packages.txt :padline no
dashboard
nerd-icons
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package dashboard
  :custom
  (dashboard-items '((projects . 5)
		     (recents . 5)
		     (bookmarks . 5)))
  (dashboard-startupify-list '(dashboard-insert-banner
			       dashboard-insert-newline
			       dashboard-insert-init-info
			       dashboard-insert-items
			       dashboard-insert-newline
			       dashboard-insert-footer))
  (dashboard-center-content t)
  :config
  ;; These make it really easy to accidentally delete projects and bookmarks
  (dolist (c '(dashboard-remove-item-under
	       dashboard-remove-item-agenda
	       dashboard-remove-item-recentf
	       dashboard-remove-item-projects
	       dashboard-remove-item-bookmarks))
    (put c 'disabled t))
  (setopt dashboard-heading-icons '((recents . "nf-oct-history")
				    (bookmarks . "nf-oct-bookmark")
				    (agenda . "nf-oct-calendar")
				    (projects . "nf-oct-rocket")
				    (registers . "nf-oct-database")))
  (setopt dashboard-startup-banner (concat (expand-file-name user-emacs-directory) "dashboard-banners/nocturne-fraktur.txt"))
  (dashboard-setup-startup-hook))

(use-package dashboard
  :if (locate-library "nerd-icons.el")
  :custom
  (dashboard-display-icons-p t)
  (dashboard-icon-type 'nerd-icons)
  (dashboard-set-file-icons t)
  (dashboard-set-heading-icons t))

(use-package dashboard
  :if (locate-library "page-break-lines.el")
  :hook (dashboard-before-initialize . (lambda (&rest _)
					(page-break-lines-mode +1)))
  :custom
  (dashboard-page-separator "\n"))
#+end_src

*** =cur-config-faces.el= call to ~provide~
:PROPERTIES:
:ID:       e6cb8999-24b0-4b75-b6fa-5d7168ee0a8a
:END:

#+begin_src emacs-lisp
(provide 'cur-config-faces)
#+end_src

** Completion system configurations (=cur-config-completion.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-completion.el
:ID:       54d4323e-5f7a-49bf-85d0-a14d3f6e291f
:END:

This section is not about code completion. Rather, this is my configuration for Emacs' completion system and the main interfaces that use them. For code completion please go see =cur-config-ide.el= and ~company-mode~.

Currently I am using the [[https:github.com/abo-abo/swiper/][ivy/counsel/swiper]] suite for doing completions in Emacs. I like it but I know that the vertico/marginelia/consult/embark chain is better, faster, and more modern. I plan to make the switch at some point but for now I sticking with ivy.

#+begin_src text :tangle ./packages.txt :padline no
embark
embark-consult
#+end_src

*** =cur-config-completion.el= section on minibuffer settings
:PROPERTIES:
:ID:       a93b748d-4a45-48d4-a12a-8d319f367fae
:END:

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :custom
  (minibuffer-follows-selected-frame nil "Display the minibuffer on a per-frame basis"))
#+end_src

*** =cur-config-completion.el= section on completions styles
:PROPERTIES:
:ID:       9b8572d1-ff66-4710-8752-9625b34f1485
:END:

#+begin_src text :tangle ./packages.txt :padline no
orderless
#+end_src

#+begin_src emacs-lisp
(use-package minibuffer
  :config
  (setq completion-styles '(basic substring orderless))
  (setq completion-category-overrides
        '((file      (styles . (basic partial-completion orderless)))
          (kill-ring (styles . (emacs22 orderless))))))

(use-package orderless
  :bind ( :map minibuffer-local-completion-map
          ("SPC" . nil)
          ("?" . nil))
  :config
  (setq orderless-matching-styles '(orderless-prefixes orderless-regexp)))
#+end_src

*** =cur-config-completion.el= section on ~vertico~ and better completion UI
:PROPERTIES:
:ID:       ddcb7c19-0dd0-422c-9890-06d1b9d70b5e
:END:

#+begin_src text :tangle ./packages.txt :padline no
vertico
#+end_src

#+begin_src emacs-lisp
(use-package vertico
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :bind ( :map vertico-map
	  ("M-e" . vertico-next-group)
	  ("M-a" . vertico-previous-group))
  :init
  (vertico-mode 1))
#+end_src

*** =cur-config-completion.el= section on ~marginalia~ and providing additional completion info
:PROPERTIES:
:ID:       3a1b87c1-c40d-4453-b404-7448840c2a79
:END:

#+begin_src text :tangle ./packages.txt :padline no
marginalia
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode 1))
#+end_src

*** =cur-config-completion.el= section on ~consult~ and richer interactive commands
:PROPERTIES:
:ID:       519e9743-b1eb-4987-90d0-37be93b6219a
:END:

#+begin_src text :tangle ./packages.txt :padline no
consult
#+end_src

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :bind (("C-x b"               . consult-buffer)
         ("M-g i"               . consult-imenu)
         ("M-y"                 . consult-yank-pop)
         ([remap goto-line]     . consult-goto-line)
         ([remap bookmark-jump] . consult-bookmark)
         ([remap rg-project]    . consult-ripgrep)
         ([remap rg]            . consult-ripgrep)
         ([remap project-switch-to-buffer] . consult-project-buffer)
         :map consult-narrow-map
         ("?" . consult-narrow-help)
         :map goto-map
         ("m" . consult-mark)
         ("M" . consult-global-mark)
         ("o" . consult-outline)
         :map search-map
         ("l" . consult-line)
         ("L" . consult-line-multi)
	 :map cur/register-map
	 ("C-s" . consult-register-store)
	 ("C-l" . consult-register-load)
	 ("C-v" . consult-register))
  :custom
  (consult-preview-allowed-hooks '(global-font-lock-mode
                                   save-place-find-file-hook
                                   ;; Dired
                                   dired-hide-details-mode
                                   hl-line-mode
                                   nerd-icons-dired-mode))

  :config
  (setq xref-show-xrefs-function       #'consult-xref
        xref-show-definitions-function #'consult-xref))

(use-package consult
  :after (org)
  :bind ( :map org-mode-map
          ([remap consult-imenu] . consult-org-heading)))

(use-package cur-consult
  :after (consult)
  :custom
  (cur-override-theme-load-function #'cur-consult-theme))
#+end_src

*** =cur-config-completion.el= section on quick directory jumping with ~consult-dir~
:PROPERTIES:
:ID:       bf673606-06f4-48f5-ba60-32dbe1dfb18b
:END:
#+begin_src text :tangle ./packages.txt :padline no
consult-dir
#+end_src

#+begin_src emacs-lisp
(use-package consult-dir
  :bind ( :map global-map
	  ("C-x C-d" . consult-dir)
	  :map minibuffer-local-completion-map
	  ("C-x C-d" . consult-dir)
	  ("C-x C-j" . consult-dir-jump-file)))

(use-package consult-dir
  :after vertico
  :bind ( :map vertico-map
	  ("C-x C-d" . consult-dir)
	  ("C-x C-j" . consult-dir-jump-file)))

(use-package consult-dir
  :after meow
  :bind ( :map cur/sub-leader-keymap
	  ("C-d" . consult-dir)))
#+end_src

*** TODO =cur-config-completion.el= section on ~embark~ and mini-buffer actions
:PROPERTIES:
:ID:       89487c3d-ae1e-443c-9fbf-99e7042e33f5
:END:

#+begin_src text :tangle ./packages.txt :padline no
embark
embark-consult
#+end_src

#+begin_src emacs-lisp
(use-package emabark
  :bind ( :map global-map
          ("C-." . embark-act)
          :map minibuffer-local-map
          ("C-." . embark-act)
          :map dired-mode-map
          ("'"  . embark-act)
          ("\"" . embark-dwim)))
#+end_src

*** TODO =cur-config-completion.el= section on ~corfu~ and in-buffer completions
:PROPERTIES:
:ID:       9b2c6589-f87c-411a-b302-7424f24f24a8
:END:

#+begin_src text :tangle ./packages.txt :padline no
corfu
#+end_src

#+begin_src emacs-lisp
(use-package corfu
  :bind
  (:map corfu-map
	("TAB"       . corfu-next)
	("<tab>"     . corfu-next)
	("S-TAB"     . corfu-previous)
	("<backtab>" . corfu-previous)
	("<escape>"  . corfu-quit) ; note: cannot bind "ESC" because it causes errors
	("M-SPC"     . corfu-insert-separator))
  :custom
  (corfu-auto t)
  (corfu-preview-current 'insert)
  (corfu-auto-delay 0.1)
  (corfu-auto-prefix 3)
  (corfu-max-width 40)
  (corfu-popupinfo-delay '(2.0 . 1.0))
  (tab-always-indent 'complete)
  :hook
  (corfu-mode . corfu-popupinfo-mode))
#+end_src

*** TODO =cur-config-completion.el= section on ~cape~ and making completion at point functions (capfs)
:PROPERTIES:
:ID:       64087654-2ad5-4dba-8de8-91b572720ca2
:END:

#+begin_src text :tangle ./packages.txt :padline no
cape
#+end_src

*** =cur-config-completion.el= call to ~provide~
:PROPERTIES:
:ID:       ee9fb108-8f60-46d1-8b23-b3799f30716f
:END:

#+begin_src emacs-lisp
(provide 'cur-config-completion)
#+end_src

** Window management configurations (=cur-config-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-window.el
:ID:       a4ff1a2a-9b63-4fca-98d7-2a7d5433fa12
:END:

*** =cur-config-window.el= section on ~display-buffer-alist~ and default window behavior
:PROPERTIES:
:ID:       b363dfea-a062-4803-a381-66c9eb9674ff
:END:

These are my settings for ~display-buffer-alist~ so windows just Do What I Mean.

#+begin_src emacs-lisp
(use-package cur-window
  :config
  (setq window-sides-slots
        '(1 1 1 1))
  (setq display-buffer-alist
        '(("\\`\\*Async Shell Command.*\\'"
           (display-buffer-no-window))
          ("\\*Org Src.*"
           (display-buffer-same-window))
          ((or (derived-mode . compilation-mode)
               (derived-mode . geiser-mode)
               (derived-mode . grep-mode)
               (derived-mode . help-mode)
               (derived-mode . Info-mode)
               (derived-mode . rg-mode)
               (derived-mode . woman-mode))
           (cur-window-display-buffer-below-or-pop)
           (body-function . cur-window-select-fit-to-size))
	  ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))
	  ("\\*Register Preview\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
	   (window-parameters . ((mode-line-format . none))))
          ((or (derived-mode . occur-mode)
               (derived-mode . xref--xref-buffer-mode))
           (display-buffer-reuse-window
            display-buffer-below-selected)
           (dedicated . t)
           (body-function . cur-window-select-fit-to-size))
          ((or (derived-mode . justl-mode)
               "justl - .*")
           (display-buffer-reuse-window
            display-buffer-at-bottom)
           (dedicated . t)
           (window-height . 0.25))
	  ((or "\\*eshell .*"
               "\\*.*-eshell*"
               "\\*.*-eat\\*")
           (display-buffer-reuse-window
            display-buffer-at-bottom)
           (window-height . 0.25))
          ((or (derived-mode . vterm-mode)
               "\\*vterm.*\\*"
               "\\*.*-vterm\\*")
           (display-buffer-reuse-mode-window
            display-buffer-same-window))
	  ((or (derived-mode . reb-mode)
	       (derived-mode . reb-lisp-mode)
	       "\\*RE-Builder\\*")
	   (display-buffer-reuse-mode-window
	    display-buffer-at-bottom)
	   (window-height . 0.25))
	  (".*"
	   (display-buffer-same-window)))))
#+end_src

*** =cur-config-window.el= section on ~ace-window~ and O(1) window switching/actions
:PROPERTIES:
:ID:       bbb30d94-91c8-49b8-ae87-22bb1f228e26
:END:

#+begin_src text :tangle ./packages.txt :padline no
ace-window
#+end_src

#+begin_src emacs-lisp
(use-package ace-window
  :custom
  (aw-keys '(?n ?h ?j ?k ?l ?i ?u ?y ?r ?e))
  (aw-dispatch-always t)
  :config
  (setq aw-dispatch-alist '((?d delete-window)
			    (?D aw-delete-window "Delete Window")
			    (?m aw-swap-window "Swap Window")
			    (?w aw-flip-window)
			    (?b cur-aw-switch-buffer-in-window "Select Buffer")
			    (?s aw-split-window-horz "Split Horizonally")
			    (?v aw-split-window-vert "Split Vertically")
			    (?o delete-other-windows)
			    (?O delete-other-windows "Delete Other Windows")
			    (?? aw-show-dispatch-help))))

(use-package cur-aw
  :after ace-window)
#+end_src

*** =cur-config-window.el= section on ~popper~ and pop windows
:PROPERTIES:
:ID:       79bfcbf0-8a10-4ef9-9d39-04e21e7fd1a9
:END:

#+begin_src text :tangle ./packages.txt :padline no
popper
#+end_src

#+begin_src emacs-lisp
(use-package popper
  :demand t
  :bind ( :map cur/toggle-map
	  ("w" . popper-toggle-type))
  :config
  (setopt popper-reference-buffers '("\\*eat\\*" "\\*.*-eat\\*$" eat-mode
				     "\\*eshell\\*" "\\*.*-eshell\\*$" eshell-mode
				     compilation-mode
				     occur-mode
				     geiser-mode
				     grep-mode
				     rg-mode
				     xref--xref-buffer-mode
				     reb-mode
				     reb-lisp-mode)))

(use-package popper-echo
  :after popper
  :hook (after-init . popper-echo-mode))

(use-package popper
  :after project
  :demand t
  :config
  (setopt popper-group-function #'popper-group-by-project))

(use-package popper
  :if (not (locate-library "cur-popper.el"))
  :config
  (setopt popper-display-function #'display-buffer-below-selected)
  (progn
    (popper-mode -1)
    (popper-mode +1)))

(use-package cur-popper
  :after (popper)
  :config
  (setopt popper-display-function #'cur-popper-display-buffer-dwim)
  (setopt popper-window-height #'cur-popper-fit-window-height)
  (setopt cur-popper-stay-conditions '())
  (progn
    (popper-mode -1)
    (popper-mode +1)))
#+end_src

*** =cur-config-window.el= section on paging up and down
:PROPERTIES:
:ID:       19429233-7dd7-4404-a925-90cd2267fa37
:END:

#+begin_src emacs-lisp
(use-package emacs
  :after repeat
  :preface
  (defvar cur/scroll-up-repeat-map
    (let ((map (make-sparse-keymap)))
      map)
    "The keymap to repeat scrolling up.")
  (defvar cur/scroll-down-repeat-map
    (let ((map (make-sparse-keymap)))
      map)
    "The keymap to repeat scrolling down.")
  :bind ( :repeat-map cur/scroll-down-repeat-map
	  ("v" . scroll-down-command)
	  :repeat-map cur/scroll-up-repeat-map
	  ("v" . scroll-up-command)))
#+end_src

*** =cur-config-window.el= call to ~provide~
:PROPERTIES:
:ID:       445fb6c0-bb89-463f-a8dc-b5185b1e3e97
:END:

#+begin_src emacs-lisp
(provide 'cur-config-window)
#+end_src

** IDE configurations (=cur-config-ide.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-ide.el
:ID:       20083d39-e9a2-4e1c-8fd0-c84993b8730c
:END:

Emacs can be made to have all the features of a modern text editor and then some.

*** =cur-config-ide.el= section on ~display-fill-column-indicator~
:PROPERTIES:
:ID:       4d229324-b82e-45e1-8886-3e9b1d702650
:END:

This is just a minor mode that shows a small bar at a certain column position. It's useful for a quick eyeball test if the line is too big but sometimes hurts readability.

#+begin_src emacs-lisp
(use-package emacs
  :custom
  (display-fill-column-indicator-column 81)
  ;; Enable this hook for it to show up in prog-mode
  ;; :hook (prog-mode . (lambda (&rest _)
  ;; 		       (display-fill-column-indicator-mode +1)))
  )
#+end_src

*** =cur-config-ide.el= section on ~lsp-mode~ and lsp
:PROPERTIES:
:ID:       b0b77539-5afd-4043-987e-557363d778bc
:END:

Lsp-mode is my chosen language server protocol support package. I chose this over eglot because of the richer features and (at the time that I started using lsp) more mature state. I will revisit elgot in the future but for now I am perfectly happy with lsp-mode.

#+begin_src text :tangle ./packages.txt :padline no
lsp-mode
#+end_src

#+begin_src emacs-lisp
;; ===LSP Mode===
(use-package lsp-mode
  :demand t
  :hook
  (lsp-mode  . lsp-enable-which-key-integration)
  :custom
  (lsp-keymap-prefix "C-c C-M-l" "lsp mode keymap")
  (lsp-file-watch-threshold 1750)
  (lsp-headerline-breadcrumb-enable nil)
  :bind (:map lsp-mode-map
              ("C-c C-a" . lsp-execute-code-action)  ; code actions
              ("C-c C-e" . lsp-treemacs-errors-list) ; treemacs error list
              ("C-c f"   . lsp-find-references)      ; find references
              ("C-c r"   . lsp-find-definition))     ; find definitions
  :config
  (lsp-deferred)
  (setq gc-cons-threshold (* 100 1024 1024))
  (setq read-process-output-max (* 3 1024 1024))
  (setq lsp-idle-delay 0.500)
  (setq lsp-lens-enable nil)
  (lsp-enable-which-key-integration t))
#+end_src

*** =cur-config-ide.el= section on ~lsp-ui~
:PROPERTIES:
:ID:       9b8b7653-7f3f-47f8-a5a1-e41c0fd07407
:END:

Lsp-ui provides some ui enhancements and extra features to lsp. Probably the best one is the doc feature to view documentation in the editor.

#+begin_src text :tangle ./packages.txt :padline no
lsp-ui
#+end_src

#+begin_src emacs-lisp
(use-package lsp-ui
  :after (lsp-mode)
  :custom
  (lsp-ui-doc-enable nil "lsp-ui doc disabled by default")
  (lsp-ui-doc-show-with-cursor t "lsp-ui doc follows cursor")
  (lsp-ui-doc-show-with-mouse t "lsp-ui doc follows mouse")
  (lsp-ui-doc-position 'at-point "lsp-ui doc shows at cursor")
  :bind (:map lsp-ui-mode-map
              ("C-c C-f" . lsp-ui-peek-find-references)  ; find references ui
              ("C-c C-r" . lsp-ui-peek-find-definitions) ; find definitions ui
              ("C-c C-d" . lsp-ui-doc-mode) ; toggle doc mode
              :map lsp-ui-peek-mode-map
              ("ESC" . lsp-ui-peek--abort)             ; toggle doc mode
              ("g"   . lsp-ui-peek--abort)             ; toggle doc mode
              ("j"   . lsp-ui-peek--select-next)       ; toggle doc mode
              ("k"   . lsp-ui-peek--select-prev)       ; toggle doc mode
              ("C-j" . lsp-ui-peek--select-next-file)  ; toggle doc mode
              ("C-k" . lsp-ui-peek--select-prev-file)) ; toggle doc mode
  :hook
  (lsp-mode . lsp-ui-mode))
#+end_src

*** TODO =cur-config-ide.el= section on ~eglot~ and lsp
:PROPERTIES:
:ID:       73015191-0919-4808-8b8b-377c9e3682f8
:END:

*** =cur-config-ide.el= section on ~company~ and auto-complete
:PROPERTIES:
:ID:       4ce88735-e016-41ec-890c-26fac1907c9a
:END:

The code completion system. This is different from completions systems like ivy or vertico, this is for interactively completing a symbol while programming.

#+begin_src text :tangle ./packages.txt :padline no
company
#+end_src

#+begin_src emacs-lisp
;; ===Company Mode===
(use-package company
  :hook
  (prog-mode . company-mode)
  (lsp-mode . company-mode)
  :bind ( :map company-active-map
          ("<tab>" . company-complete-common-or-cycle)
          ("<return>" . company-complete-selection)
	  :map company-mode-map
	  ("<tab>" . company-indent-or-complete-common))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))
;;(company-tng-configure-default))
#+end_src

*** =cur-config-ide.el= section on ~flycheck~ and in-buffer error messages
:PROPERTIES:
:ID:       5aa2456b-f94d-4151-83e2-f56995516dce
:END:

Code error checking with a nice UI.

#+begin_src text :tangle ./packages.txt :padline no
flycheck
#+end_src

#+begin_src emacs-lisp
;; ===Flycheck===
(use-package flycheck
  :hook
  (prog-mode . flycheck-mode)
  (lsp-mode  . flycheck-mode))
#+end_src

*** TODO =cur-config-ide.el= section on ~flymake~ and in-buffer error messages
:PROPERTIES:
:ID:       cfbd2b8f-7860-4c1f-b54c-c81664bd499a
:END:

*** =cur-config-ide.el= section on ~magit~ and quick git interface
:PROPERTIES:
:ID:       c4b9aa02-bb0d-429c-88c1-780057bdac94
:END:

Magit is a git interface, probably the best one I have ever seen or had the pleasure of using. I consider magit to be one of Emacs' "killer features", right up there with org-mode.

#+begin_src text :tangle ./packages.txt :padline no
magit
#+end_src

#+begin_src emacs-lisp
;; ===Magit===
(use-package magit
  :bind ( :map cur/sub-leader-keymap
          ("C-v" . magit)
          :map project-prefix-map
          ("C-v" . nil)
          ("v" . magit-project-status)
          ("V" . project-vc-dir))
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (transient-default-level 5 "Allowing for commit signing"))
#+end_src

*** =cur-config-ide.el= section on ~project~ and project related functions
:PROPERTIES:
:ID:       ee41e6f2-1b63-4438-b3b0-bd8c6082a4ef
:END:

#+begin_src emacs-lisp
(use-package project
  :bind ( :map project-prefix-map
          ("d"   . project-dired)
          ("D"   . project-find-dir)
          ("C-b" . nil)
          ("b"   . project-switch-to-buffer)
          ("l"   . project-list-buffers))
  :custom
  (project-buffers-viewer #'project-list-buffers-ibuffer)
  (project-switch-use-entire-map t))
#+end_src

*** =cur-config-ide.el= section on using ~ripgrep~ in Emacs
:PROPERTIES:
:ID:       a8175c44-4cf2-4b2d-b7be-9eec48a2f1a5
:END:

Ripgrep go burrr.

#+begin_src text :tangle ./packages.txt :padline no
rg
#+end_src

#+begin_src emacs-lisp
(use-package rg)
#+end_src

*** =cur-config-ide.el= section on ~rainbow-delimiters~
:PROPERTIES:
:ID:       9586f275-5609-4e85-bfc8-4f3e621fb7d0
:END:

This color codes opening and closing delimiters such as parentheses and square brackets.

#+begin_src text :tangle ./packages.txt :padline no
rainbow-delimiters
#+end_src

#+begin_src emacs-lisp
;; ===rainbow-delimiters===
(use-package rainbow-delimiters
  ;; :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** =cur-config-ide.el= section on ~paredit~
:PROPERTIES:
:ID:       a0bb932b-650d-45d1-b0d2-e8d673408d41
:END:

#+begin_src text :tangle ./packages.txt :padline no
paredit
#+end_src

#+begin_src emacs-lisp
;; ===Paredit===
(use-package paredit
  :hook ((emacs-lisp-mode lisp-interaction-mode scheme-mode) .
         (lambda () (paredit-mode 1))))
#+end_src

*** =cur-config-ide.el= section on ~geiser~ and working with schemes
:PROPERTIES:
:ID:       b44c76ac-9660-4cc5-80d6-81112a734185
:END:

#+begin_src text :tangle ./packages.txt :padline no
geiser
geiser-chez
geiser-chibi
geiser-chicken
geiser-gambit
geiser-gauche
geiser-guile
geiser-kawa
geiser-mit
geiser-racket
geiser-stklos
macrostep
macrostep-geiser
#+end_src

*** =cur-config-ide.el= section on java programming
:PROPERTIES:
:ID:       9f889f1e-d963-46ae-af5f-77fd0ba59779
:END:

My configurations for working with the Java language. I have ~java-ts-mode~, the tree sitter version of the normal ~java-mode~, as the mode for editing =.java= files. I have found that either tree sitter provides exactly the same or better syntax highlighting and the possibility of better movement once it gets better integrated into emacs.

I also have lsp-java set up for better integrating ~lsp-mode~ into ~java-ts-mode~. Note because I have =direnv= integration with ~envrc~, the hooks I add to start ~lsp~ must be ~lsp-defered~. ~lsp-defered~ does not start ~lsp-mode~ until after the buffer has visually loaded. We want this because ~envrc~ will change the ~exec-path~ to what =direnv= would change it to. For instance, if I have a devshell that says "here is the lsp-server, the build tool, and external libraries with these exact versions", envrc will make sure that ~exec-path~ contains exactly those versions of those programs in the nix store.

#+begin_src text :tangle ./packages.txt :padline no
lsp-java
#+end_src

#+begin_src emacs-lisp
;; ===Java Tree-Sitter Mode===
(use-package java-ts-mode
  :mode "\\.java\\'"
  :custom (java-ts-mode-indent-offset 8))

;; ===lsp-java===
(use-package lsp-java
  :after (lsp-mode cc-mode)
  :init
  :hook
  (envrc-mode . (lambda ()
                  (when (equal major-mode 'java-ts-mode)
                    (setq lsp-java-server-install-dir (concat (getenv "JDTLS_PATH") "/share/java/jdtls/")))))
  (java-ts-mode . lsp-deferred)
  :config
  (defun lsp-java--ls-command ()
    (let ((jdtls-path (getenv "JDTLS_PATH"))
          (jdtls-exec-options (list
                               "-configuration"
                               (concat (getenv "HOME") "/.jdtls/config_linux")
                               "-data"
                               (concat (getenv "HOME") "/.jdtls/java-workspace"))))
      (message (concat jdtls-path "/share/java/"))
      (append (list (concat jdtls-path "/bin/jdtls")) jdtls-exec-options))))
#+end_src

*** =cur-config-ide.el= section on working with justfiles
:PROPERTIES:
:ID:       8e3e0c17-47b3-4a83-a4f2-381ab03727ef
:END:

#+begin_src text :tangle ./packages.txt :padline no
just-mode
#+end_src

#+begin_src emacs-lisp
(use-package just-mode
  :defer t)
#+end_src

*** =cur-config-ide.el= section on yaml files
:PROPERTIES:
:ID:       40209140-b2b5-4a24-94b3-fa14ffa2c7d7
:END:
#+begin_src text :tangle ./packages.txt :padline no
yaml-mode
#+end_src

#+begin_src emacs-lisp
;; ===YAML===
(use-package yaml-mode
  :commands (yaml-mode))
#+end_src

*** =cur-config-ide.el= configurations for nix
:PROPERTIES:
:ID:       2736a16d-403e-4b3e-bc6a-6be6e3cdd679
:END:

My configurations for the Nix language, which boils down to "start the lsp server".

#+begin_src text :tangle ./packages.txt :padline no
nix-mode
nix-ts-mode
#+end_src

#+begin_src emacs-lisp
;; ===nix-mode===
(use-package nix-mode
  :hook
  (nix-mode . lsp-deferred)) ;; So that envrc mode will work

(use-package nix-mode
  :after lsp-mode
  :custom
  (lsp-disabled-clients '((nix-mode . nix-nil)) "disable nil so that nixd will be used as lsp-server")
  (lsp-nix-nixd-server-path "nixd" "set nixd binary path to be use from current $PATH"))
#+end_src

*** =cur-config-ide.el= configurations for rust
:PROPERTIES:
:ID:       5faeccc8-de89-47ac-bd25-43fe3df10b9a
:END:

#+begin_src text :tangle ./packages.txt :padline no
rustic
#+end_src

#+begin_src emacs-lisp
;; ===Rust-Mode===
(use-package rustic
  :after (lsp-mode)
  :hook (rustic . lsp-deferred))
#+end_src

*** =cur-config-ide.el= configurations for haskell
:PROPERTIES:
:ID:       36eb4cf2-82a0-4de6-a27c-d56413744789
:END:

#+begin_src text :tangle ./packages.txt :padline no
haskell-mode
company-ghci
#+end_src

#+begin_src emacs-lisp
;; ===Haskell-Mode===
(use-package haskell-mode)

;; ===LSP-Haskell===
(use-package lsp-haskell
  :hook
  ((haskell-mode) . lsp-deferred))

;; ===Company-GHCI===
(use-package company-ghci
  :after (company)
  :custom (company-ghc-show-info t)
  :config
  (push 'company-ghci company-backends))
#+end_src

*** =cur-config-ide.el= configurations for ocaml
:PROPERTIES:
:ID:       b17c9828-12cb-4ccf-b7a8-6dd60f1bfe29
:END:

#+begin_src text :tangle ./packages.txt :padline no
tuareg
utop
merlin
merlin-company
#+end_src

#+begin_src emacs-lisp
;; ===Tuareg===
(use-package tuareg
  :hook (tuareg-mode . merlin-mode)
  :defer t)

;; ===Utop===
(use-package utop
  :commands (utop utop-mode)
  :config
  (advice-add 'utop :around 'inheritenv-apply))

(use-package merlin
  :defer t)

(use-package merlin-company
  :after (merlin))
#+end_src

*** =cur-config-ide.el= configurations for C lang
:PROPERTIES:
:ID:       45a60406-d36b-4649-a0b3-0bd4a2135470
:END:

I use tree-sitter for C, which unfortunately is not currently integrated into the default C major mode for Emacs. I have also changed the ~c-default-style~ for C to be "linux", which is 8 spaces for indentation instead of the default of 2.

#+begin_src text :tangle ./packages.txt :padline no
ccls
#+end_src

#+begin_src emacs-lisp
;; ===C Tree-Sitter Mode===
(use-package c-ts-mode
  :after (cc-mode)
  :mode
  ("\\.c\\'" . c-ts-mode)
  ("\\.h\\'" . c-ts-mode)
  :custom
  (c-default-style '((c-ts-mode . "linux")
                     (java-mode . "java")
                     (awk-mode  . "awk")
                     (other     . "gnu"))
		   "default style for c programs is linux")
  :hook
  (c-ts-mode . (lambda () (require 'ccls) (lsp-deferred))))

;; ===CCLS Mode===
(use-package ccls
  :after (cc-mode c-ts-mode))
#+end_src

*** =cur-config-ide.el= configurations for zig
:PROPERTIES:
:ID:       cd00a97f-9707-4b53-9700-fe0342382691
:END:

#+begin_src text :tangle ./packages.txt :padline no
zig-mode
#+end_src

#+begin_src emacs-lisp
;; ===Zig Mode===
(use-package zig-mode
  :hook (zig-mode . lsp-deferred))
#+end_src

*** =cur-config-ide.el= configurations for go
:PROPERTIES:
:ID:       378f48d2-ab20-4851-8837-69e6793830f0
:END:

#+begin_src emacs-lisp
;; ===Go Tree-Sitter Mode===
(use-package go-ts-mode
  :mode
  ("\\.go\\'" . go-ts-mode)
  ("go\\.mod\\'" . go-mod-ts-mode)
  :custom
  (go-ts-mode-indent-offset 4 "Set the indentation to 4")
  :hook
  (go-ts-mode . lsp-deferred)
  (go-ts-mode . (lambda () (setq tab-width 4))))
#+end_src

*** =cur-config-ide.el= call to ~provide~
:PROPERTIES:
:ID:       94476685-e2fc-4e23-999d-66c68818fecd
:END:

#+begin_src emacs-lisp
(provide 'cur-config-ide)
#+end_src

** Terminal emulation and Eshell configuration (=cur-config-shell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-shell.el
:ID:       c6096b33-de53-4f61-b021-add1e4449984
:END:

*** =cur-config-shell.el= section on ~vterm~ and fast, accurate terminal emulation
:PROPERTIES:
:ID:       de664b6d-e7b6-4ef2-b418-b1e91baef0a9
:END:

Vterm is a terminal emulator for Emacs. It is faster than ~term~ and ~ansi-term~ but the downside is that it is not written entirely in elisp so its cross platform. ~cur/meow-vterm~ and ~cur/meow-vterm-other-window~ help make vterm more "intuitive". ~cur/vterm-kill~ kills the vterm buffer cleanly and without prompting.

#+begin_src text :tangle ./packages.txt :padline no
vterm
#+end_src

#+begin_src emacs-lisp
;; ===Vterm===
(use-package vterm
  :bind ( :map cur/sub-leader-keymap
          ("C-S-t" . vterm))
  :custom
  (vterm-shell "fish")
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
  (setq vterm-max-scrollback 10000))

(use-package cur-vterm
  :bind ( :map vterm-mode-map
          ("C-c C-RET"      . cur-vterm-enter-password)
          ("C-c C-<return>" . cur-vterm-enter-password)
          :map project-prefix-map
          ("T" . cur-vterm-project-other-window)))
#+end_src

*** =cur-config-shell.el= section on ~eat~ and terminal emulation
:PROPERTIES:
:ID:       522c5038-171d-4163-9bce-7b36e5cbded8
:END:

Eat is just a better elisp terminal emulator. I mostly use this so that eshell can run TUI programs.

#+begin_src text :tangle ./packages.txt :padline no
eat
#+end_src

#+begin_src emacs-lisp
;; ===Eat===
(use-package eat
  :hook (eat-exec . (lambda (&rest _) (eat-line-mode)))
  :bind ( :map eat-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password)
	  :map project-prefix-map
	  ("t" . eat-project)
	  :map cur/sub-leader-keymap
	  ("C-t" . eat))
  :custom
  (eat-kill-buffer-on-exit t)
  (eat-enable-directory-tracking t))

(use-package eat
  :after meow
  :hook
  (eat--char-mode . (lambda (&rest _)
		      (if eat--char-mode
			  (meow-mode -1)
			(unless meow-mode
			  (meow-mode +1))))))

(use-package eat
  :after eshell
  :hook (eat-eshell-exec . (lambda (&rest _) (eat-eshell-emacs-mode)))
  :bind ( :map eat-eshell-emacs-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password)
	  :map eat-eshell-semi-char-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password))
  :custom
  (eshell-visual-commands nil "nil because using `eat-eshell-mode'")
  (eshell-visual-subcommands nil "nil because using `eat-eshell-mode'")
  :config
  (eat-eshell-mode 1))

(use-package eat
  :if (locate-library "corfu.el")
  :hook (eat-mode . (lambda (&rest _)
		      (setq-local corfu-auto nil)
		      (setq-local corfu-quit-at-boundary nil)
		      (corfu-mode +1))))
#+end_src

*** =cur-config-shell.el= section on ~eshell~, the Emacs Shell
:PROPERTIES:
:ID:       6f582490-9acf-4e04-8253-ec2a3bc2ed24
:END:

Eshell is an shell for Emacs like bash or sh, but written in elisp and has its own ways of doing things. Note: not POSIX compliant.

#+begin_src text :tangle ./packages.txt :padline no
eshell-syntax-highlighting
#+end_src

#+begin_src emacs-lisp
;; ===Eshell===
(use-package eshell
  :bind ( :map cur/sub-leader-keymap
          ("C-e" . eshell)))

(use-package eshell
  :if (locate-library "corfu.el")
  :hook
  (eshell-mode . (lambda (&rest _)
		   (setq-local corfu-auto nil)
		   (setq-local corfu-quit-at-boundary nil)
		   (corfu-mode +1))))

(use-package eshell-syntax-highlighting
  :after eshell
  :config
  (eshell-syntax-highlighting-global-mode +1))

(use-package cur-eshell
  :after (eshell)
  :custom
  (eshell-prompt-function 'cur-eshell-prompt "Set custom prompt for eshell")
  :config
  (setopt eshell-prompt-regexp cur-eshell-prompt-regexp))
#+end_src

*** =cur-config-shell.el= call to ~provide~
:PROPERTIES:
:ID:       8ddb6cc7-67d2-414d-a5cc-ffdcb3ea2d9c
:END:

#+begin_src emacs-lisp
(provide 'cur-config-shell)
#+end_src

** Org-mode (=cur-config-org.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-org.el
:ID:       280d85c5-9e50-4048-9e1a-269c8b711ff5
:END:

#+begin_src text :tangle ./packages.txt :padline no
org-bullets
#+end_src

#+begin_src emacs-lisp
;; ===Org-Mode===
(use-package org
  :ensure nil
  :defer t
  :hook (org-mode . cur/org-mode-setup)
  :bind ( :map org-mode-map
          ("C-S-h" . outline-promote)
          ("C-S-j" . outline-move-subtree-down)
          ("C-S-k" . outline-move-subtree-up)
          ("C-S-l" . outline-demote))
  :init
  (defun cur/org-mode-setup ()
    (org-indent-mode 1)
    (variable-pitch-mode 0)
    (visual-line-mode 1)
    (flyspell-mode 1))
  :custom
  (org-ellipsis " ▾" "Readable ellipsis")
  (org-adapt-indentation nil)
  (org-special-ctrl-a/e nil)
  (org-M-RET-may-split-line '((default . nil)))
  (org-hide-emphasis-markers nil)
  (org-hide-macro-markers nil)
  (org-hide-leading-stars nil)
  (org-agenda-start-with-log-mode t)
  (org-src-window-setup 'plain) ; don't override `display-buffer-alist'
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-agenda-window-setup 'current-window "Have org-agenda pop up in the current window")
  (org-imenu-depth 4)
  (org-edit-src-content-indentation 0)
  :config
  (load-library "find-lisp")
  ;; (setq org-agenda-files (find-lisp-find-files "~/dox/agenda" "\.org$"))
  (setq org-agenda-time-grid '((daily today require-timed)
                               (400 600 800 1000 1200 1400 1600 1800 2000 2200)
                               "......" "----------------"))
  (setq org-format-latex-options '(:foreground "#e5e9e9" :scale 1.0)))
;; (cur/org-font-setup))
#+end_src

#+begin_src emacs-lisp
;; ===Org Tempo and SRC Blocks===
(use-package org-tempo
  :after org
  :custom
  (org-structure-template-alist
   '(("s" . "src")
     ("e" . "src emacs-lisp")
     ("t" . "src emacs-lisp :tangle FILENAME")
     ("T" . "src text :tangle FILENAME")
     ("P" . "src text :tangle ./packages.txt :padline no")
     ("x" . "export")
     ("X" . "example")
     ("q" . "quote")
     ("v" . "verse"))))
#+end_src

#+begin_src emacs-lisp
;; ===Org Babel===
(use-package ob
  :after org)
;; TODO: fix this so I can still auto tangle on saving
;; :init
;; (defun cur/org-babel-tangle-config ()
;;   (when (string-equal (file-name-directory (buffer-file-name))
;;                       (expand-file-name user-emacs-directory))
;;     ;; Dynamic scoping to the rescue
;;     (let ((org-confirm-babel-evaluate nil))
;;       (org-babel-tangle))))
;; 
;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'cur/org-babel-tangle-config))))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell
  :bind ( :map flyspell-mode-map
          ("C-." . nil)
          ("C-," . nil)))

(provide 'cur-config-org)
#+end_src

** Configurations for working with the Internet (=cur-config-net.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-net.el
:ID:       0dfed815-701f-4f77-8ec3-ab921c88a7ca
:END:

*** =cur-config-net.el= section on gemini and the smolnet
:PROPERTIES:
:ID:       03175fe0-f192-4307-b2c2-24669236c508
:END:

#+begin_src text :tangle ./packages.txt :padline no
gemini-mode
ox-gemini
elpher
#+end_src

#+begin_src emacs-lisp
;; ===Gemini-Mode===
(use-package gemini-mode
  :defer t)

;; ===Org Gemini Exporter==
(use-package ox-gemini
  :after org
  :commands (org-gemini-export-to-file org-gemini-export-to-buffer))

;; ===Elpher Gemini/Gopher Client===
(use-package elpher
  :defer t
  :custom
  (elpher-default-url-type "gemini"))
#+end_src

*** =cur-config-net.el= section on ~elfeed~, and rss/atom feed reader
:PROPERTIES:
:ID:       08dfceb3-1c1c-482e-a3fb-c94151a7d1b9
:END:

#+begin_src text :tangle ./packages.txt :padline no
elfeed
#+end_src

#+begin_src emacs-lisp
;;; cur-config-elfeed.el --- Links for elfeed -*- lexical-binding: t -*-

(use-package elfeed
  :defer t
  :bind ( :map elfeed-show-mode-map
	  ("w" . elfeed-show-visit)
	  ("e" . eww)
	  :map elfeed-search-mode-map
	  ("w" . elfeed-search-browse-url)
	  ("e" . eww))
  :config
  (setopt elfeed-search-filter "@2-weeks-ago")
  (setopt elfeed-db-directory (concat (abbreviate-file-name (expand-file-name user-emacs-directory)) "elfeed-db")))

(let ((cur-links-path (locate-user-emacs-file "cur-elfeed-links")))
  (use-package elfeed
    :if (file-readable-p cur-links-path)
    :config
    (setopt elfeed-feeds (car (read-from-string (with-temp-buffer
						  (insert-file-contents cur-links-path)
						  (buffer-substring-no-properties (point-min) (point-max))))))))
#+end_src

*** =cur-config-net.el= section on ~elfeed~ integration with youtube and ~yt-dlp~
:PROPERTIES:
:ID:       6f6b6415-898e-4e38-9a0f-c314470e382a
:END:

#+begin_src text :tangle ./packages.txt :padline no
elfeed-tube
elfeed-tube-mpv
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-tube
  :after elfeed
  :demand t
  :bind ( :map elfeed-show-mode-map
	  ("F" . elfeed-tube-fetch)
	  ([remap save-buffer] . elfeed-tube-save)
	  :map elfeed-search-mode-map
	  ("F" . elfeed-tube-fetch)
	  ([remap save-buffer] . elfeed-tube-save))
  :config
  (setopt elfeed-tube-auto-fetch-p t
	  elfeed-tube-auto-save-p nil)
  (elfeed-tube-setup))

(use-package elfeed-tube-mpv
  :after (elfeed-tube elfeed)
  :demand t
  :bind ( :map elfeed-show-mode-map
	  ("v"       . elfeed-tube-mpv)
	  ("C-c C-f" . elfeed-tube-mpv-follow-mode)
	  ("C-c C-w" . elfeed-tube-mpv-where)
	  :map elfeed-search-mode-map
	  ("v" . elfeed-tube-mpv)))

(provide 'cur-config-elfeed)
#+end_src

*** =cur-config-net.el= section on playing youtube videos
:PROPERTIES:
:ID:       3ec2df0a-91ea-4e95-b3e3-fc950c5153c6
:END:

#+begin_src emacs-lisp
(use-package cur-yt
  :commands (cur-yt-play-video))

(use-package cur-yt
  :after (elfeed elfeed-tube)
  :bind ( :map elfeed-show-mode-map
	  ("V" . cur-yt-play-video)
	  :map elfeed-search-mode-map
	  ("V" . cur-yt-play-video)))
#+end_src

*** =cur-config-net.el= section on ~elcord~ and making myself look productive to my friends
:PROPERTIES:
:ID:       7184df32-7e9e-4a3a-8621-8a89077c34d6
:END:

#+begin_src text :tangle ./packages.txt :padline no
elcord
#+end_src

#+begin_src emacs-lisp
(use-package elcord
  :custom
  (elcord-boring-buffers-regexp-list '("^ " "\\\\*Messages\\\\*"
				       "\\\\*Help\\\\*" "\\\\*elpher\\\\*"
				       "\\\\*Org Src .*\\\\*"
				       "\\\\*Occur\\\\*"
				       "\\\\*Embark Collect .*\\\\*")))
#+end_src

*** =cur-config-net.el= call to ~provide~
:PROPERTIES:
:ID:       6a681b64-ee9c-4c07-85be-b8c60a83164b
:END:

#+begin_src emacs-lisp
(provide 'cur-config-net)
#+end_src

** Direnv integration (=cur-config-direnv.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-direnv.el
:ID:       95bc6815-90f6-4630-83b0-fd87e98204b4
:END:

#+begin_src text :tangle ./packages.txt :padline no
envrc
inheritenv
#+end_src

#+begin_src emacs-lisp
;; ===Envrc===
(use-package envrc
  :config
  (envrc-global-mode))

(provide 'cur-config-direnv)
#+end_src

* Custom Library Modules (=cur-lisp=)
:PROPERTIES:
:ID:       154b7ee9-1ad9-4e58-93e5-07dff545776f
:END:

** Ace Window Extensions (=cur-aw.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-aw.el
:ID:       03e2b639-de95-4cd4-bc24-89745ad8908a
:END:

#+begin_src emacs-lisp
;;; cur-aw.el --- The extensions for ace-window -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'ace-window)

(defgroup cur-aw ()
  "Base functions and variables for my Emacs configuration."
  :group 'windows)

(defun cur-aw--switch-buffer ()
  "Call `consult-buffer' if it is bound.
Call `switch-to-buffer' if it is not."
  (cond ((fboundp 'consult-buffer)
	 (call-interactively 'consult-buffer))
	(t
	 (call-interactively 'switch-to-buffer))))

(defun cur-aw-switch-buffer-in-window (window)
  "Switch to buffer in WINDOW.
Prefer the use of `consult-buffer'."
  (aw-switch-to-window window)
  (cur-aw--switch-buffer))

(provide 'cur-aw)
;;; cur-aw.el ends here
#+end_src

** Base Values and Functions (=cur-base.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-base.el
:ID:       39558113-15a3-49d8-a8b8-6821a24685fe
:END:

#+begin_src emacs-lisp
;;; cur-base.el --- The base of my customizations for emacs -*- lexical-binding: t -*-

;;; Commentary:
;; This is the base of my extensions to Emac's functionality.
;; Do try this at home kids.

;;; Code:

(defgroup cur-base ()
  "Base functions and variables for my Emacs configuration."
  :group 'editing)

(provide 'cur-base)
;;; cur-base.el ends here
#+end_src

** Consult Extensions (=cur-consult.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-consult.el
:ID:       474fa162-b8f9-4441-92cc-b949de18f0b0
:END:

#+begin_src emacs-lisp
;;; cur-consult-el --- Extending and Customizing Consult -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'consult)

(defgroup cur-consult ()
  "Integrate Consult and Projectile."
  :group 'consult
  :prefix "cur-consult-")

(defun cur-consult-theme (theme)
  "Disable current themes and enable THEME from `consult-themes'.

If THEME is a list of symbols, go through and enable each theme in reverse
order.  The command supports previewing the currently selected theme."
  (interactive
   (list
    (let* ((regexp (consult--regexp-filter
                    (mapcar (lambda (x) (if (stringp x) x (format "\\`%s\\'" x)))
                            consult-themes)))
           (avail-themes (seq-filter
                          (lambda (x) (string-match-p regexp (symbol-name x)))
                          (cons 'default (custom-available-themes))))
           (saved-theme (if (< (length custom-enabled-themes) 2)
                            (car custom-enabled-themes)
                          custom-enabled-themes)))
      (consult--read
       (mapcar #'symbol-name avail-themes)
       :prompt "Theme: "
       :require-match t
       :category 'theme
       :history 'consult--theme-history
       :lookup (lambda (selected &rest _)
                 (setq selected (and selected (intern-soft selected)))
                 (or (and selected (car (memq selected avail-themes)))
                     saved-theme))
       :state (lambda (action theme)
                (pcase action
                  ('return (cur-consult-theme (or theme saved-theme)))
                  ((and 'preview (guard theme)) (cur-consult-theme theme))))
       :default (symbol-name (or (if (and saved-theme (listp saved-theme))
                                     (car (last saved-theme))
                                   saved-theme)
                                 'default))))))
  (when (or (eq theme 'default)
            (when (listp theme)
              (member 'default theme)))
    (setq theme nil))
  (cond ((symbolp theme)
         (unless (eq theme (car custom-enabled-themes))
           (mapc #'disable-theme custom-enabled-themes)
           (when theme
             (if (custom-theme-p theme)
                 (enable-theme theme)
               (load-theme theme :no-confirm)))))
        ((listp theme)
         (unless (equal theme custom-enabled-themes)
           (let ((themes (reverse theme)))
             (mapc #'disable-theme custom-enabled-themes)
             (when themes
               (mapc (lambda (theme)
                       (if (custom-theme-p theme)
                           (enable-theme theme)
                         (load-theme theme :no-confirm)))
                     themes)))))))

(provide 'cur-consult)
;;; cur-consult.el ends here
#+end_src

** Custom Mode Line (=cur-modline.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-mode-line.el
:ID:       f36c824e-ce05-40b8-88b0-599ad5bf3418
:END:

#+begin_src emacs-lisp
;;; cur-mode-line.el --- My custom mode-line -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(eval-when-compile
  (require 'cl-lib))

;;;;; Custom Groups

(defgroup cur-mode-line nil
  "My custom mode-line that tries to be minimal."
  :group 'mode-line)

(defgroup cur-mode-line-faces nil
  "The faces for my custom mode-line."
  :group 'cur-mode-line)

(defface cur-mode-line-active
  '((t :inherit mode-line-active))
  "Face for active mode-line."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-inactive
  '((t :inherit mode-line-inactive))
  "Face for inactive mode-line."
  :group 'cur-mode-line-faces)

(unless (boundp 'mode-line-right-align-edge)
  (defcustom mode-line-right-align-edge 'right-fringe
    "Where mode-line should align to.
This will be defined in Emacs 30."
    :type '(choice (const right-margin)
                   (const right-fringe)
                   (const window))
    :group 'mode-line))

;;;;; Modeline Padding For Right Alignment

(defun cur-mode-line-right-align-space (arg)
  "Return a space right alligned to before where ARG should begin.
ARG should be a list parseable by `format-mode-line'."
  (let* ((end-string (format-mode-line arg))
	 (end-string-length (length end-string))
	 (end-length (if (> end-string-length 0)
			 (progn
			   (add-face-text-property
			    0 end-string-length 'mode-line t end-string)
			   (string-pixel-width end-string))
		       0)))
    (propertize " " 'display
		(if (and (display-graphic-p)
			 (not (eq mode-line-right-align-edge 'window)))
		    `(space :align-to (- ,mode-line-right-align-edge
					 (,end-length)))
		  `(space :align-to
			  (,(- (window-pixel-width)
			       (window-scroll-bar-width)
			       (window-right-divider-width)
			       (* (or (car (window-margins)) 0)
				  (frame-char-width))
			       (or (cadr (window-fringes)) 0)
			       (pcase mode-line-right-align-edge
				 ('right-margin (or (cdr (window-margins)) 0))
				 (_ 0))
			       end-length)))))))

(defvar cur-mode-line-right-align
  '(:eval (cur-mode-line-right-align-space mode-line-end-spaces))
  "Puts a space right alligned to before where `mode-line-end-spaces' should begin.
This should ALWAYS come before `mode-line-end-spaces' otherwise the
spacing will be messed up.")

(defun cur-mode-line-end-space-conditionally (arg)
  "Return a list of space characters based on `mode-line-right-align-edge' and ARG.
If `mode-line-right-align-edge' is \\='right-align or \\='window, return a single
space character plus ARG addtional space characters.  Otherwise, just return ARG
space characters."
  (pcase mode-line-right-align-edge
    ((or 'right-margin 'window)
     (let ((spaces " "))
       (dotimes (_ arg spaces)
	 (setq spaces (concat spaces " ")))))
    (_
     (let (spaces )
       (dotimes (_ arg spaces)
	 (setq spaces (concat spaces " ")))))))

(defvar cur-mode-line-end-padding
  '(:eval (cur-mode-line-end-space-conditionally 0))
  "This is a value used to add some padding for `mode-line-end-spaces'.
This is supposed to go at the end of `mode-line-end-spaces'.
To create add more padding you can use the `cur-mode-line-end-space-dwim'
 function and input the amount of extra space you would like at the end.")

;;;;; Kmacro Indicator

(defface cur-mode-line-kmacro
  '((t :inherit font-lock-string-face))
  "Face for when KMacros are being defined."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--kmacro ()
  "Return a propertized string if defining a kmacro."
  (when (and (mode-line-window-selected-p) defining-kbd-macro)
    (propertize "  KMACRO  " 'face 'cur-mode-line-kmacro)))

(defvar cur-mode-line-kmacro-indicator
  '(:eval (cur-mode-line--kmacro))
  "Indicator for KMacro definitions.")

;;;;; Narrowed Indicator

(defface cur-mode-line-narrowed
  '((t :inherit font-lock-constant-face))
  "Face for current window is narrowed."
  :group 'cur-mode-line-faces)

(defcustom cur-mode-line-exclude-narrow-inidcator '()
  "Which modes to exclude from showing the narrow indicator."
  :type '(repeat symbol)
  :group 'cur-mode-line)

(defun cur-mode-line--narrowed ()
  "Return a propertized string if current window is narrowed."
  (when (and (mode-line-window-selected-p)
             (buffer-narrowed-p)
             (not (apply #'derived-mode-p cur-mode-line-exclude-narrow-inidcator)))
    (propertize "  NARROWED  " 'face 'cur-mode-line-narrowed)))

(defvar cur-mode-line-narrowed-indicator
  '(:eval (cur-mode-line--narrowed))
  "Indicator for window narrowing.")

;;;;; Meow Indicator

(defface cur-mode-line-meow-state
  '((t :inherit highlight))
  "Face for showing meow state."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-meow-display-p ()
  "Return whether or not meow related indicators should be displayed."
  (and (member 'meow features)
       (mode-line-window-selected-p)
       meow-mode))

(defun cur-mode-line--meow ()
  "Return a propertized string of the current meow state."
  (when (cur-mode-line-meow-display-p)
    (propertize (format "  %s  " (substring-no-properties
				  (upcase (symbol-name meow--current-state))
				  0 3))
		'face 'cur-mode-line-meow-state)))

(defvar cur-mode-line-meow-state-indicator
  '(:eval (cur-mode-line--meow))
  "Indicator for current meow state.")

;;;;; Buffer Status

(defface cur-mode-line-buffer-status
  '((t :inherit bold))
  "Face for the file indicator."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--buffer-status-indicator ()
  "Return a propertized string for file indicator."
  ;; TODO: make these clickable
  (propertize
   (concat "%z" (mode-line-eol-desc) "%1*" "%1+" "%@")
   'face 'cur-mode-line-buffer-status))

(defvar cur-mode-line-buffer-status-indicator
  '(:eval (cur-mode-line--buffer-status-indicator))
  "Indicator for file coding system, editing status, and remote status.")

;;;;; Buffer Name

(defface cur-mode-line-buffer-name
  '((t ()))
  "Face for the buffer name indicator."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--buffer-name ()
  "Return a propertized string of the current buffer's name."
  (propertize (format "%s" (buffer-name)) 'face 'cur-mode-line-buffer-name))

(defvar cur-mode-line-buffer-name-indicator
  '(:eval (cur-mode-line--buffer-name))
  "Indicator for current buffer name.")

;;;;; Major Mode

(defface cur-mode-line-major-mode-active
  '((t :inherit (mode-line-emphasis bold)))
  "Face for major mode indicator when active."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-major-mode-inactive
  '((t :inherit bold))
  "Face for major mode indicator when inactive."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--major-mode ()
  "Return a propertized string of current `major-mode'."
  (let ((face (if (mode-line-window-selected-p)
		  'cur-mode-line-major-mode-active
		'cur-mode-line-major-mode-inactive)))
    (propertize
     (capitalize
      (string-replace
       "-" " " (string-replace
		"-mode" "" (symbol-name major-mode))))
     'face face)))

(defvar cur-mode-line-major-mode-indicator
  '(:eval (cur-mode-line--major-mode))
  "Indicator for current buffer's major mode.")

;;;;; Eat

(defface cur-mode-line-eat
  '((t :inherit (bold eat-shell-prompt-annotation-success)))
  "Face for position when active."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-eat-display-p ()
  "Return whether or not eat related indicators should be displayed."
  (and (member 'eat features)
       (mode-line-window-selected-p)
       (eq major-mode 'eat-mode)))

(defun cur-mode-line--eat ()
  "Return propertized string of current eat mode."
  (when (cur-mode-line-eat-display-p)
   (propertize
    (cond (eat--line-mode "(Line Mode)")
	  ((or eat--char-mode eat--eshell-char-mode) "(Char Mode)")
	  ((or eat--semi-char-mode eat--eshell-semi-char-mode)
	   "(Semi-Char Mode)")
	  (t "(Emacs Mode)"))
    'face 'cur-mode-line-eat)))

(defvar cur-mode-line-eat-indicator
  '(:eval (cur-mode-line--eat))
  "Indicator for Eat's current mode.")

;;;;; Eat Eshell

(defface cur-mode-line-eat-eshell
  '((t :inherit (bold eat-shell-prompt-annotation-success)))
  "Face for displaying current `eat-eshell-mode' minor mode."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-eat-eshell-display-p ()
  "Return whether or not it is appropriate to display eat indicator in eshell."
  (and (member 'eat features)
       (member 'eshell features)
       (mode-line-window-selected-p)
       (eq major-mode 'eshell-mode)
       eat-terminal))

(defun cur-mode-line--eat-eshell ()
  "Return propertized string of current eat mode."
  (when (cur-mode-line-eat-eshell-display-p)
    (propertize
     (cond ((or eat--char-mode eat--eshell-char-mode) "(Char Mode)")
	   ((or eat--semi-char-mode eat--eshell-semi-char-mode)
	    "(Semi-Char Mode)")
	   (t "(Emacs Mode)"))
     'face 'cur-mode-line-eat)))

(defvar cur-mode-line-eat-eshell-indicator
  '(:eval (cur-mode-line--eat-eshell))
  "Indicator for eat-eshell's current mode.")

;;;;; Position

(defface cur-mode-line-postion
  '((t ()))
  "Face for position when active."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--position ()
  "Return a propertized string with the position of point in current buffer."
  (when (mode-line-window-selected-p)
    (concat "(%p" (when column-number-mode ", %c") ")")))

(defvar cur-mode-line-postion-indicator
  '(:eval (cur-mode-line--position))
  "Indicator for current buffer's position.")

;;;;; Flycheck

(defun cur-mode-line-flycheck-display-p ()
  "Whether or not to display flycheck indicator."
  (and (member 'flycheck features)
       flycheck-mode
       (mode-line-window-selected-p)))

(defun cur-mode-line--flycheck-num-errors (level face)
  "Return a string of number of errors in LEVEL with FACE applied conditionally."
  (when (cur-mode-line-flycheck-display-p)
    (let* ((error-nums (or (cdr (assoc level (flycheck-count-errors
					      flycheck-current-errors))) 0))
	   (icon (pcase level
		   ('info "󰋽")
		   ('warning "")
		   ('error "")))
	   (string (format "%s %s" icon error-nums)))
      (if flycheck-mode-line-color
	  (propertize string 'face face)
	string))))

(cur-mode-line--flycheck-num-errors 'info 'cur-mode-line-flycheck-info)
(cur-mode-line--flycheck-num-errors 'warning 'cur-mode-line-flycheck-warning)
(cur-mode-line--flycheck-num-errors 'error 'cur-mode-line-flycheck-error)

(defface cur-mode-line-flycheck-info
  '((t :inherit (flycheck-error-list-info mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-flycheck-warning
  '((t :inherit (flycheck-error-list-warning mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-flycheck-error
  '((t :inherit (flycheck-error-list-error mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defvar cur-mode-line-flycheck-indicator
  '((:eval (cur-mode-line--flycheck-num-errors 'error
					       'cur-mode-line-flycheck-error))
    " "
    (:eval (cur-mode-line--flycheck-num-errors 'warning
					       'cur-mode-line-flycheck-warning))
    " "
    (:eval (cur-mode-line--flycheck-num-errors 'info
					       'cur-mode-line-flycheck-info)))
  "Indicator for flycheck errors.")

(format-mode-line cur-mode-line-flycheck-indicator)

;;;;; Add Variables To Risky
(dolist (var '(cur-mode-line-right-align
	       cur-mode-line-end-padding
	       cur-mode-line-kmacro-indicator
	       cur-mode-line-narrowed-indicator
	       cur-mode-line-meow-state-indicator
	       cur-mode-line-buffer-status-indicator
	       cur-mode-line-buffer-name-indicator
	       cur-mode-line-major-mode-indicator
	       cur-mode-line-postion-indicator
	       cur-mode-line-flycheck-indicator
	       cur-mode-line-eat-indicator
	       cur-mode-line-eat-eshell-indicator))
  (put var 'risky-local-variable t))

(provide 'cur-mode-line)
;;; cur-mode-line.el ends here
#+end_src

** Dired Extensions (=cur-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-dired.el
:ID:       4bb3fd54-986d-43e7-b408-2ed2fb272ac5
:END:

#+begin_src emacs-lisp
;;; cur-dired.el --- My extensions to dired -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

;;;###autoload
(defun cur-dired-maybe-insert-subdir-or-find-file (&optional other-window)
  (interactive "P")
  (let ((file (dired-get-file-for-visit)))
    (if (file-directory-p file)
	(if other-window
	    (dired-other-window file)
	  (dired-maybe-insert-subdir file nil t))
      (if other-window
	  (find-file-other-window file)
	(dired--find-possibly-alternative-file file)))))

;;;###autoload
(defun cur-dired-find-file-dwim (&optional other-window)
  (interactive "P")
  (let* ((file (dired-get-file-for-visit)))
    (if (file-directory-p file)
	(or (when other-window
	      (progn
		(dired-other-window file)	
		(dired-goto-file file)))
	    (when (and (cdr dired-subdir-alist)
		       (dired-goto-subdir file))
	      (when dired-trivial-filenames
		(dired-goto-next-nontrivial-file))
	      (run-hooks 'dired-initial-position-hook)
	      t)
	    (dired--find-possibly-alternative-file file))
      (progn
	(if other-window
	    (dired-find-file-other-window file)
	  (dired--find-possibly-alternative-file file))))))

(provide 'cur-dired)
;;; cur-dired.el ends here

#+end_src

** Eshell aliases and extensions (=cur-eshell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-eshell.el
:ID:       f776fb00-2e8b-4936-9e75-62ca15f268cb
:END:

#+begin_src emacs-lisp
;;; cur-eshell.el --- My exensions of the Emacs Shell -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'eshell)
(require 'em-dirs)
(require 'em-unix)
(require 'files)
(require 'dired)

(defun cur-eshell-prompt ()
  "A minimal and colourful prompt for `eshell'.
Set `eshell-prompt-function' to this function to enable."
  (let* ((red     (face-foreground 'ansi-color-red))
         (green   (face-foreground 'ansi-color-green))
         (yellow  (face-foreground 'ansi-color-yellow))
         (blue    (face-foreground 'ansi-color-blue))
         (magenta (face-foreground 'ansi-color-magenta))
         ;; (cyan    (face-foreground 'ansi-color-cyan))
         (white   (face-foreground 'ansi-color-white)))
    (concat
     (propertize "["                   'face `(:weight bold :foreground ,red))
     (propertize (eshell/whoami)       'face `(:weight bold :foreground ,yellow))
     (propertize "@"                   'face `(:weight bold :foreground ,green))
     (propertize (system-name)         'face `(:weight bold :foreground ,blue))
     " "
     (propertize (concat (abbreviate-file-name (eshell/pwd))) 'face `(:weight bold :foreground ,magenta))
     (propertize "]"                   'face `(:weight bold :foreground ,red))
     (propertize "λ "                  'face `(:weight bold :foreground ,white)))))

(defun eshell/i (fn)
  "Call FN interactively.
FN should be a string."
  (let ((user-fn (intern-soft fn)))
    (cond ((and user-fn (commandp user-fn))
	   (call-interactively user-fn))
	  (user-fn
	   (user-error "Function is not an interactive function"))
	  (t
	   (user-error "There was no function with that name")))))

(defun eshell/ff (&optional file)
  "Eshell alias to open FILE.
Will call `find-file' interactively if no file is specified."
  (cond (file
         (find-file file))
        (t
         (call-interactively 'find-file))))

(defun eshell/lf (&optional dir)
  "Eshell alias to open `dired' at DIR.
Will call `dired' on current directory if no directory is specified."
  (cond (dir
         (dired dir))
        (t
         (dired "."))))

(defun eshell/icd (&optional _)
  "Interactively change directories with `read-file-name'.
This function ignores its argument."
  (let* ((default-dir (read-file-name "Switch To: " nil nil t nil #'file-directory-p)))
    (unless (string-empty-p default-dir)
      (eshell/cd default-dir))))

(defvar cur-eshell-prompt-regexp
  "^\\[.*?@.*? [/~].*\\]?[#$λ] "
  "Regex for the `cur-eshell-prompt' prompt.")

(provide 'cur-eshell)
;;; cur-base.el ends here
#+end_src

** Meow Extension (=cur-meow.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-meow.el
:ID:       4aa1f51c-204e-4479-8295-d0522d178789
:END:

#+begin_src emacs-lisp
;;; cur-meow.el --- Extending Meow's Capabilities -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:
(require 'meow)

(defun cur-meow-toggle-temp-normal-motion ()
  "Toggle normal and motion mode.
If in neither of the two states, return nil."
  (interactive)
  (cond ((meow-normal-mode-p) (call-interactively 'meow-motion-mode))
        ((meow-motion-mode-p) (call-interactively 'meow-normal-mode))
        (t nil)))

(provide 'cur-meow)
;;; cur-meow.el ends here
#+end_src

** Popper Extensions (=cur-popper.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-popper.el
:ID:       3ad0cb08-93dd-43db-9522-fa21cf32b4c6
:END:

#+begin_src emacs-lisp
;;; cur-popper.el --- Extending Popper's capabilities -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:
(require 'popper)

(defgroup cur-popper ()
  "Base functions and variables for my Emacs configuration."
  :group 'popper)

(defcustom cur-popper-stay-conditions '()
  "A list of `buffer-match-p' conditions that determine if a popped buffer is focused."
  :type '(repeat (choice (cons (choice (const derived-mode) (const major-mode)) symbol)
			 string))
  :group 'cur-popper)

(defcustom cur-popper-select-window 'dwim
  "Whether to select a popped buffer with `cur-popper-dispaly-buffer-dwim'."
  :type '(choice (const :tag "Always" t)
		 (const :tag "Sometimes" dwim)
		 (const :tag "Never" nil))
  :group 'cur-popper)

(defun cur-popper-display-buffer-dwim (buffer &optional alist)
  "Display BUFFER at the bottom of the frame and conditonally select the window.
ALIST is passed to `dispaly-buffer-at-bottom'."
  (let* ((nalist (append alist `((window-height . ,popper-window-height))))
	 (window (display-buffer-at-bottom buffer nalist)))
    (pcase cur-popper-select-window
      (`nil window)
      (`dwim (if (not (buffer-match-p `(or . ,cur-popper-stay-conditions) (window-buffer window)))
		 (select-window window)
	       window))
      (_ (select-window window)))))

(defun cur-popper-fit-window-height (win)
  (fit-window-to-buffer
   win
   (floor (frame-height) 3)
   (floor (frame-height) 5)))

(provide 'cur-popper)
;;; cur-popper.el ends here
#+end_src

** Theme Helpers (=cur-theme.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-theme.el
:ID:       41ff5a19-e301-487f-9bf8-493c0f2f681f
:END:

#+begin_src emacs-lisp
;;; cur-theme.el --- Helper functions for theming -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:

(require 'cl-lib)

(defgroup cur-theme nil
  "A themeing library for creating simple and extensible themes."
  :group 'faces)

(defgroup cur-override-theme nil
  "A theme that will conditionally override aspects of your current theme."
  :group 'cur-theme)

(defvar cur-theme--default-face-defs
  '(())
  "The default definitions for theme faces.")

(defun cur-theme-name-to-rgb (color)
  "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")
for FRAME (defaults to the current frame)."
  (cl-loop with div = (float (car (tty-color-standard-values "#ffffff")))
           for x in (tty-color-standard-values (downcase color))
           collect (/ x div)))

(defun cur-theme-blend (color1 color2 alpha)
  "Blend COLOR1 with COLOR2 with ALPHA.
Both COLOR1 and COLOR2 must be strings in hexidecimal form, prepended
with a \"#\"."
  (if (and (string-prefix-p "#" color2) (string-prefix-p "#" color2))
      (apply (lambda (r g b) (format "#%02x%02x%02x" (* r 255) (* g 255) (* b 255)))
             (cl-loop for it    in (cur-theme-name-to-rgb color1)
                      for other in (cur-theme-name-to-rgb color2)
                      collect (+ (* alpha it) (* other (- 1 alpha)))))
    (error "No \"#\" prefix for \"%s\" and \"%s\"" color2 color2)))

(defun cur-theme-lighten (color alpha)
  "Blend COLOR with \"#FFFFFF\" and ALPHA."
  (cur-theme-blend color "#FFFFFF" (- 1 alpha)))

(defun cur-theme-darken (color alpha)
  "Blend COLOR with \"#000000\" and ALPHA."
  (cur-theme-blend color "#000000" (- 1 alpha)))

(defvar cur-theme--schema-names
  '(base00
    base01
    base02))

(defun cur-theme--check-default-schema (colors)
  "Take COLORS and check if it has all of the default schema values defined.
The names of the default schema are in `cur-theme--schema-names'.
Note, this will not check recursively defined colors.  For example, something
like ((thing1 thing2) (thing2 thing1)) will be considered valid."
  (let ((color-names (mapcar (lambda (x) (car x)) colors)))
    (dolist (color-name cur-theme--schema-names)
      (unless (member color-name color-names)
        (error "Color %s is not defined in theme" color-name)))
    (dolist (color colors)
      (unless (equal (length color) 2)
        (error "Color %s has several definitions" (car color)))
      (let ((name (car color))
            (value (car (last color))))
        (cond ((stringp value)
               (unless (equal (length value) 7)
                 (error "Color %s's value is too long: %s" name value))
               (unless (string-match-p (rx "#" (repeat 6 (any "A-F" "a-f" "0-9"))) value)
                 (error "Color %s does not have a proper hex value: %s" name value)))
              ((symbolp value)
               (unless (member value color-names)
                 (error "Color %s references a nondefined color %s" name value)))
              (t
               (error "Color %s has nonsensical definition %s" name value)))))))

(defun cur-theme--expand-faces (face-defs)
  "Take FACE-DEFS and return faces that can be used by `custom-theme-set-faces'."
  (mapcar
   (lambda (face-def)
     (let* ((face (car face-def))
            (def  (cdr face-def)))
       `(list ',face ,`(list (list t (list ,@def))))))
   face-defs))

(defun cur-theme--get-face (face-name face-defs)
  "Return face-def with FACE-NAME in FACE-DEFS.
FACE-NAME should be a symbol."
  (cl-loop for face-def in face-defs
           when (equal face-name (car face-def))
           return face-def))

(defun cur-theme--merge-faces (prev-list new-list)
  "Take PREV-LIST of face defs and overlay NEW-LIST on top."
  (let (overridden)
    (setq overridden prev-list)
    (dolist (face-override new-list)
      (let ((face (car face-override))
            (definition (cdr face-override)))
        (if (assoc face overridden)
            (setcdr (cur-theme--get-face face overridden) definition)
          (push face-override overridden))))
    overridden))

(defun cur-theme--option-plist-get (plist prop default)
  "Get PROP from PLIST if PLIST has PROP, otherwise returning DEFAUlT."
  (if (plist-member plist prop)
      (plist-get plist prop)
    default))

(defmacro cur-theme-def (theme-name doc options-plist colors &rest faces)
  "Generate custom theme named THEME-NAME.
DOC is the documentation string.
OPTIONS-PLIST is an plist of optionional parameters that change the behavior of
different parts of the macro.  They are as follows:
,* :merge - When t, merge FACES with `cur-theme--default-face-defs'.  When nil,
  do not perform any merging.  Defaults to t.
,* :color-check - When set to t, check COLORS for conforming to schema.  When
  nil preform no checks.  Defaults to t.

COLORS is a list of lists, where the first element is a symbol and the second is
a string that is the hex value of the color or the name of another color in the
list.  COLORS must define all names in `cur-theme--schema-names' are defined.
OPTIONS-PLIST will affect this behavior.

FACES is a list of faces in the form (FACE PROPERTIES).  For example, (bold
:background bg :foreground fg :weight \\='bold).  OPTIONS-PLIST will affect
this behavior."
  (declare (indent 1))
  (let* ((merge (cur-theme--option-plist-get options-plist :merge t))
         (color-check (cur-theme--option-plist-get options-plist :color-check t)))
    (cond (color-check
           (cur-theme--check-default-schema colors))
          (t (when (eq merge t)
               (warn "Theme defined with no default schema but still merges with default faces defs which require the default schema"))))

    `(let* (,@colors)
       (deftheme ,theme-name
         ,doc)
       ,(unless (and (equal (length faces) 1)
                     (equal (car faces) nil))
          `(custom-theme-set-faces
            ',theme-name
            ,@(if merge
                  (cur-theme--expand-faces
                   (cur-theme--merge-faces cur-theme--default-face-defs faces))
		(cur-theme--expand-faces faces)))))))

(defcustom cur-override-theme-overrides
  '((doom-gruvbox (secondary-selection :background "#504945")))
  "The overrides for cur-override-theme."
  :group 'cur-override-theme
  :type '(alist :key-type symbol :value-type sexp))

(defcustom cur-override-theme-theme-priority
  'single
  "The priority for which theme has its overrides applied.
`first' means apply the override of the first theme if it has one.  `last' means
apply the override of the last theme if it has one.  `single' means expect only
a single theme to be enabled and signal a user error if multiple are enabled."
  :group 'cur-override-theme
  :type '(choice (const :tag "Use First Enabled Theme" first)
                 (const :tag "Use Last Enabled Theme" last)
                 (const :tag "Expect a Single Enabled Theme" single)))

(defun cur-theme--get-overrides (theme)
  "Return the overrides for THEME from `cur-override-theme-overrides'."
  (cdr (assoc theme cur-override-theme-overrides)))

(defmacro cur-override-theme-def ()
  "Define the override theme."
  (let ((overrides
         (cond ((eq cur-override-theme-theme-priority 'single)
                (when (> (length custom-enabled-themes) 1)
                  (user-error "More than one theme enabled.
Please disable all but one theme or change the value of `cur-override-theme-theme-priority'"))
                (cur-theme--get-overrides (car custom-enabled-themes)))
	       ((eq cur-override-theme-theme-priority 'first)
		(cur-theme--get-overrides (car (last custom-enabled-themes))))
               ((eq cur-override-theme-theme-priority 'last)
                (cur-theme--get-overrides (car custom-enabled-themes))))))
    `(cur-theme-def cur-override
       "A theme to override defintions another theme."
       ( :merge nil
         :color-check nil)
       nil
       ,@ (if overrides
              overrides
            '(nil)))))

(defun cur-theme-load-theme (theme)
  "Load THEME, disabling all other currently enabled themes."
  (interactive
   (list
    (intern (completing-read "Custom Themes: "
                             (mapcar #'symbol-name
                                     (custom-available-themes))))))
  (condition-case nil
      (progn
        (mapc #'disable-theme custom-enabled-themes)
        (load-theme theme t)
	(load-theme 'cur-override t))
    (error "Problem loading theme %s" theme)))

(defcustom cur-override-theme-load-function
  #'cur-theme-load-theme
  "The function to set a theme or themes."
  :group 'cur-override-theme
  :type '(function))

(defun cur-override-theme-load-theme (theme)
  "Load a THEME and then load the `cur-override' theme.
If THEME is nil then call interactively the function
`cur-override-theme-load-function'."
  (interactive (list nil))
  (if theme
      (cur-theme-load-theme theme)
    (call-interactively cur-override-theme-load-function))
  (load-theme 'cur-override t))

(provide 'cur-theme)
;;; cur-theme.el ends here
#+end_src

#+begin_src emacs-lisp :tangle ./themes/cur-override-theme.el
;;; cur-override-theme.el --- Theme that will override other themes -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:
(require 'cur-theme)

(cur-override-theme-def)

(provide 'cur-override)
;; cur-override-theme.el ends here
#+end_src

** Wallpaper Functions (=cur-wallpaper.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-wallpaper.el
:ID:       9b1350bf-332a-4f8a-a4cb-821486adf8e4
:END:

#+begin_src emacs-lisp
;;; cur-wallpaper.el --- Setting wallpaper through dired -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'dired)
(require 'image-dired)

(defun cur-wallpaper-set-wallpaper (arg)
  "Set wallpaper as ARG."
  (interactive (list (image-dired-original-file-name)))
  (call-process-shell-command
   (concat "swww img -t any " arg " &")))

(defun cur-wallpaper-set-wallpaper-dired (arg)
  "Set wallpaper as ARG."
  (interactive (list (dired-get-filename)))
  (call-process-shell-command
   (concat "swww img -t any " arg " &")))

(provide 'cur-wallpaper)
;;; cur-wallpaper.el ends here
#+end_src

** Window Management (=cur-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-window.el
:ID:       f7a52192-5fe8-45e6-a541-1139216007bd
:END:

#+begin_src emacs-lisp
;;; cur-window.el --- Customization and helper functions for window management -*- lexical-binding: t -*-

;;; Commentary:
;; Custom functions and variables for managing windows.  In particular, setting `display-buffer-alist'
;; so that windows are just placed how I want.
;;
;; Much of this was shamelessly stolen from Protesilaos Stavrou, who greatly inspired much of my config.
;; Please see https://protesilaos.com/emacs/dotemacs#h:35b8a0a5-c447-4301-a404-bc274596238d for his window
;; management section of his Emacs config.

;;; Code:

(defun cur-window--window-small-p ()
  "Return non-nil if window is small.
Check if the `window-width' or `window-height' is less than
`split-width-threshold' and `split-height-threshold',
respectively."
  (or (and (numberp split-width-threshold)
           (< (window-total-width) split-width-threshold))
      (and (numberp split-height-threshold)
           (> (window-total-height) split-height-threshold))))

(defun cur-window--three-or-more-windows-p (&optional frame)
  "Return non-nil if three or more windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (>= (length (window-list frame :no-minibuffer)) 3))

(defun cur-window--get-display-buffer-below-or-pop ()
  "Return list of functions for `cur-window-display-buffer-below-or-pop'."
  (list
   #'display-buffer-reuse-mode-window
   (if (or (cur-window--window-small-p)
           (cur-window--three-or-more-windows-p))
       #'display-buffer-below-selected
     #'display-buffer-pop-up-window)))

(defun cur-window-display-buffer-below-or-pop (&rest args)
  "Display buffer below current window or pop a new window.
The criterion for choosing to display the buffer below the
current one is a non-nil return value for
`prot-common-window-small-p'.

Apply ARGS expected by the underlying `display-buffer' functions.

This as the action function in a `display-buffer-alist' entry."
  (let ((functions (cur-window--get-display-buffer-below-or-pop)))
    (catch 'success
      (dolist (fn functions)
        (when (apply fn args)
          (throw 'success fn))))))

(defvar cur-window-window-sizes
  '( :max-height (lambda () (floor (frame-height) 3))
     :min-height 10
     :max-width (lambda () (floor (frame-width) 3))
     :min-width 20)
  "This is a property list of max and min values for window sizes.
This value is used by `cur-window-select-fit-to-size' to set the
size of the window.")

(defun cur-window--get-window-size (key)
  "Use KEY to extract the value from `cur-window-window-sizes'.
If the value is a number return it, if it is a function, call
it and return it's value."
  (when-let ((value (plist-get cur-window-window-sizes key)))
    (cond
     ((functionp value)
      (funcall value))
     ((numberp value)
      value)
     (t
      (error "The value of %s is not a number or function" key)))))

(defun cur-window-select-fit-to-size (window)
  "Select WINDOW and fit it to the buffer.
The minimum and maximum height and width is determined by
`cur-window-window-sizes'."
  (select-window window)
  (fit-window-to-buffer
   window
   (cur-window--get-window-size :max-height)
   (cur-window--get-window-size :min-height)
   (cur-window--get-window-size :max-width)
   (cur-window--get-window-size :min-width)))

(defvar cur-window-same-window-modes-list
  '(justl-mode)
  "List of major modes that should have their window reused.
The function `cur-window-display-buffer-below-or-pop' uses this variable to
determine if it will create a new window or reuse the current one.")

(defun cur-window--get-display-buffer-same-window-or-below ()
  "Return a list of functions for `cur-window-display-buffer-same-window-or-below'."
  (list
   #'display-buffer-reuse-window
   (if (memq major-mode cur-window-same-window-modes-list)
       #'display-buffer-same-window
     #'display-buffer-below-selected)))

(defun cur-window-display-buffer-same-window-or-below (&rest args)
  "Display buffer either reusing the current window or bellow."
  (let ((functions (cur-window--get-display-buffer-same-window-or-below)))
    (catch 'success
      (dolist (fn functions)
        (when (apply fn args)
          (throw 'success fn))))))

(provide 'cur-window)
;;; cur-window.el ends here
#+end_src

** Vterm extension (=cur-vterm.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-vterm.el
:ID:       7c12cb33-ff1d-4aff-a0af-aa6d0023efe0
:END:

#+begin_src emacs-lisp
;;; cur-vterm.el --- Customization and helper functions for vterm

;;; Commentary:

;;; Code:

(require 'vterm)

(defun cur-vterm-enter-password ()
  (declare (interactive-only t))
  (interactive)
  (unless (equal major-mode 'vterm-mode)
    (user-error "Not in a VTerm Terminal"))
  (vterm-insert (read-passwd "Password: "))
  (vterm-send-return))

(defun cur-vterm-project (&optional other-window)
  (interactive)
  (if-let* ((current-project (project-current))
            (default-directory (project-root current-project))
            (buffer-name (format "*%s-%s*" (project-name current-project) "vterm")))
      (if (buffer-live-p (get-buffer buffer-name))
          (if other-window
              (switch-to-buffer-other-window buffer-name)
            (switch-to-buffer buffer-name))
        (if other-window
            (vterm-other-window buffer-name)
          (vterm buffer-name)))
    (user-error "Cannot create vterm buffer in %s" (cdr current-project))))

(defun cur-vterm-project-other-window ()
  (interactive)
  (cur-vterm-project t))

(provide 'cur-vterm)
;;; cur-vterm.el ends here
#+end_src

** Playing YouTube Videos
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-yt.el
:ID:       2cd99819-9dc4-40d5-87ba-fdb2a878d8d2
:END:

#+begin_src emacs-lisp
;;; cur-yt.el --- a front end for playing YouTube videos with mpv -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'rx)

(defgroup cur-yt ()
  "UI for working with YouTube videos in Emacs."
  :group 'external)

;;; Helper Functions

(defvar cur-yt--youtube-view-key-regexp
  (rx bol
      (*? not-newline)
      "watch?v="
      (group-n 1 (= 11 anything))
      (*? not-newline)
      eol)
  "Regexp used to get view key from a YouTube URL.")

(defun cur-yt--get-view-key (url)
  "Get view key from URL."
  (save-match-data
    (string-match cur-yt--youtube-view-key-regexp url)
    (match-string-no-properties 1 url)))

(defun cur-yt--convert-to-yt-link (url)
  "Convert URL to a YouTube link."
  (let ((key (cur-yt--get-view-key url)))
    (when key
	(format "https://www.youtube.com/watch?v=%s" key))))

(defun cur-yt--mpv-ytdl-format (height)
  "Return the `mpv' option to get the best video of HEIGHT."
  (pcase height
      ("best" "--ytdl-format=bestvideo+bestaudio/best")
      ("worst" "--ytdl-format=worstvideo+worstaudio/worst")
      ((guard (string-match-p (rx (+ (any "0-9"))) height))
       (format "--ytdl-format=bestvideo[height<=?%s]+bestaudio/best" height))
      (_ (error "Cannot format option for mpv, '%s' is not a number" height))))

;;; Play Video

(defcustom cur-yt-play-default-resolution "1080"
  "The default video resolution for `cur-yt-play-video'.
If this video resolution is not available the next best resolution will be
downloaded instead.  It should be one of the common resolution heights YouTube
uses, \"best\" or \"worst\"."
  :type '(choice (const "best")
		 (const "2160")
		 (const "1440")
		 (const "1080")
		 (const "720")
		 (const "480")
		 (const "360")
		 (const "240")
		 (const "144")
		 (const "worst"))
  :group 'cur-yt)

(defvar cur-yt-play-url-history nil
  "Previous YouTube URLs played with `cur-yt-play-video'.")

(defun cur-yt--play-check-exetutables ()
  "Check if `mpv' and `yt-dlp'/`youtube-dl' are installed.
This function with error if it finds a missing program."
  (unless (executable-find "mpv")
    (error "`mpv' is not installed on the system, please install it"))
  (unless (or (executable-find "yt-dlp")
	      (executable-find "youtube-dl"))
    (error "Neither `yt-dlp' nor `youtube-dl' are installed, please install one of them"))
  t)

(defcustom cur-yt-play-always-prompt-resolution nil
  "Whether or not `cur-yt-play-video' should always prompt for resolution."
  :type '(boolean)
  :group 'cur-yt)

;;;###autoload
(defun cur-yt-play-video (url &optional resolution)
  "Play video URL at RESOLUTION."
  (interactive
   (list (read-string "YouTube URL: " nil
		      cur-yt-play-url-history
		      (when kill-ring
			(cur-yt--convert-to-yt-link (substring-no-properties (car kill-ring)))))
	 (when (or cur-yt-play-always-prompt-resolution current-prefix-arg)
	   (completing-read "Resolution: "
			    '("worst" "144" "240" "360" "480" "720" "1080" "1440" "2160" "best")
			    nil 'confirm nil t))))
  (cur-yt--play-check-exetutables)
  (let ((res (or resolution cur-yt-play-default-resolution))
	(yt-url (cur-yt--convert-to-yt-link url)))
    (unless yt-url
      (user-error "URL did not contain a YouTube view key"))
    (start-process "my-process" (get-buffer-create "sugma")
		   "mpv" (cur-yt--mpv-ytdl-format res) yt-url)
    (message "Playing %s at %s" yt-url (pcase res
					 ((or "best" "worst") (concat res " resolution"))
					 (_ (concat res "p"))))))

(provide 'cur-yt)
;;; cur-yt.el ends here
#+end_src

* Themes
:PROPERTIES:
:ID:       8a389991-b8c2-478c-b691-a5edace0a55c
:END:

** Gruvbox
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:ID:       0f2eba32-600b-486d-a387-382e5c1f00d6
:END:

#+begin_src emacs-lisp
;;; cur-gruvbox-theme.el --- My custom gruvbox theme

;;; Commentary:

;;; Code:

(require 'cur-theme)

;; (add-to-list 'custom-theme-load-path (locate-user-emacs-file "/home/recur/cfg/home/programs/emacs/themes"))
;; (load-theme 'cur-gruvbox t)

(defun cur-theme-name-to-rgb (color)
  "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")
for FRAME (defaults to the current frame)."
  (cl-loop with div = (float (car (tty-color-standard-values "#ffffff")))
           for x in (tty-color-standard-values (downcase color))
           collect (/ x div)))

(defun cur-theme-blend (color1 color2 alpha)
  ""
  (if (and (string-prefix-p "#" color2) (string-prefix-p "#" color2))
      (apply (lambda (r g b) (format "#%02x%02x%02x" (* r 255) (* g 255) (* b 255)))
             (cl-loop for it    in (cur-theme-name-to-rgb color1)
                      for other in (cur-theme-name-to-rgb color2)
                      collect (+ (* alpha it) (* other (- 1 alpha)))))
    (error "No \"#\" prefix for \"%s\" and \"%s\"" color2 color2)))

(defun cur-theme-lighten (color alpha)
  ""
  (cur-theme-blend color "#FFFFFF" (- 1 alpha)))

(defun cur-theme-darken (color alpha)
  ""
  (cur-theme-blend color "#000000" (- 1 alpha)))

(deftheme cur-gruvbox
  "Asdf.")

(let* (
       ;; Normal colours
       (red        "#cc241d")
       (green      "#98971a")
       (yellow     "#d79921")
       (blue       "#458588")
       (purple     "#b16286")
       (aqua       "#689d6a")
       (orange     "#d65d0e")

       ;; Bright colours
       (light-red        "#fb4934")
       (light-green      "#b8bb26")
       (light-yellow     "#fabd2f")
       (light-blue       "#83a598")
       (light-purple     "#d3869b")
       (light-aqua       "#8ec07c")
       (light-orange     "#fe8019")

       ;; Colored Background
       (bg-red    (cur-theme-blend "#cc241d" "#282828" 0.1)) ; red
       (bg-green  (cur-theme-blend "#b8bb26" "#282828" 0.1)) ; light-green
       (bg-yellow (cur-theme-blend "#fabd2f" "#282828" 0.1)) ; light-yellow
       (bg-blue   (cur-theme-blend "#83a598" "#282828" 0.1)) ; light-blue
       (bg-purple (cur-theme-blend "#d3869b" "#282828" 0.1)) ; light-purple
       (bg-aqua   (cur-theme-blend "#8ec07c" "#282828" 0.1)) ; light-aqua
       (bg-orange (cur-theme-blend "#fe8019" "#282828" 0.1)) ; light-orange

       ;; Pale Colors
       (pale-red    (cur-theme-blend "#cc241d" "#ebdbb2" 0.6))
       (pale-green  (cur-theme-blend "#b8bb26" "#ebdbb2" 0.6))
       (pale-yellow (cur-theme-blend "#fabd2f" "#ebdbb2" 0.6))
       (pale-blue   (cur-theme-blend "#83a598" "#ebdbb2" 0.6))
       (pale-purple (cur-theme-blend "#d3869b" "#ebdbb2" 0.6))
       (pale-aqua   (cur-theme-blend "#8ec07c" "#ebdbb2" 0.6))
       (pale-orange (cur-theme-blend "#fe8019" "#ebdbb2" 0.6))

       ;; Background colours
       (bg-sp1   "#0d1011")
       (bg0h     "#1d2021") ;; Darkest
       (bg0      "#282828") ;; Default bg
       (bg0s     "#32302f")
       (bg1      "#3c3836")
       (bg2      "#504945")
       (bg3      "#665c54")
       (bg4      "#7c6f64")
       (grey     "#928374") ;; Lightest

       ;; Foreground colours
       (fg4     "#a89984") ;; Darkest
       (fg3     "#bdae93")
       (fg2     "#d5c4a1")
       (fg1     "#ebdbb2") ;; Default fg
       (fg0     "#fbf1c7") ;; Lightest
       )
  (custom-theme-set-faces
   'cur-gruvbox
   `(default             ((t (:foreground ,fg1 :background ,bg0))))
   `(success             ((t (:foreground ,light-green))))
   `(warning             ((t (:foreground ,light-yellow))))
   `(error               ((t (:foreground ,light-red))))
   `(link                ((t (:foreground ,light-aqua :underline t :weight bold))))
   `(link-visited        ((t (:foreground ,aqua :underline t :weight bold))))
   `(cursor              ((t (:background ,fg0))))
   `(fringe              ((t (:distant-foreground ,fg1 :background ,bg0))))
   `(region              ((t (:background ,bg3))))
   `(highlight           ((t (:foreground ,bg-sp1 :distant-foreground ,fg0 :background ,light-yellow))))
   `(hl-line             ((t (:background ,bg1))))
   `(header-line         ((t (:inherit (mode-line)))))
   `(vertical-border     ((t (:foreground ,bg0 :background ,bg0))))
   `(secondary-selection ((t (:background ,bg2))))
   `(query-replace       ((t (:inherit isearch))))
   `(minibuffer-prompt   ((t (:foreground ,aqua))))
   `(tooltip             ((t (:foreground ,fg1 :background ,bg0h))))
   `(shadow              ((t (:foreground ,bg4))))

   ;; Font Lock Faces

   `(font-lock-builtin-face           ((t (:foreground ,light-orange))))
   `(font-lock-comment-face           ((t (:foreground ,grey :slant italic))))
   `(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
   `(font-lock-doc-face               ((t (:foreground ,fg2))))
   `(font-lock-function-name-face     ((t (:foreground ,light-green))))
   `(font-lock-function-call-face     ((t (:inherit font-lock-function-name-face))))
   `(font-lock-keyword-face           ((t (:foreground ,light-red))))
   `(font-lock-preprocessor-face      ((t (:foreground ,fg1 :weight bold))))
   `(font-lock-string-face            ((t (:foreground ,light-green))))
   `(font-lock-type-face              ((t (:foreground ,light-yellow))))
   `(font-lock-constant-face          ((t (:foreground ,light-purple))))
   `(font-lock-variable-name-face     ((t (:foreground ,light-blue))))
   `(font-lock-warning-face           ((t (:inherit warning))))
   `(font-lock-negation-char-face     ((t (:foreground ,fg1 :weight bold))))
   `(font-lock-number-face            ((t (:foreground ,light-purple))))

   ;; Mode Line

   `(mode-line           ((t (:background ,bg1))))
   `(mode-line-active    ((t (:inherit mode-line))))
   `(mode-line-emphasis  ((t (:foreground ,light-blue :distant-foreground ,bg4))))
   `(mode-line-inactive  ((t (:foreground ,bg4 :background ,bg0s))))
   `(mode-line-buffer-id ((t (:weight bold))))

   ;; Line Number

   `(line-number              ((t (:foreground ,bg4 :background ,bg0 :inherit default :slant italic :weight normal))))
   `(line-number-current-line ((t (:foreground ,light-yellow :background ,bg1 :inherit (hl-line default) :slant italic :weight normal))))

   ;; Isearch

   `(isearch         ((t (:foreground ,bg0h :background ,light-orange))))
   `(isearch-fail    ((t (:foreground ,fg0 :background ,light-red))))
   `(isearch-group-1 ((t (:foreground ,bg0h :background ,light-orange))))
   `(isearch-group-2 ((t (:foreground ,bg0h :background ,orange))))
   `(lazy-highlight  ((t (:foreground ,bg0h :background ,light-yellow))))

;;; Minibuffer and Completions

   ;; Match and Completions

   `(match                   ((t (:foreground ,pale-orange :background ,bg-orange))))
   `(completions-common-part ((t (:foreground ,pale-aqua :background ,bg-aqua))))

   ;; Orderless

   `(orderless-match-face-0 ((t (:foreground ,pale-blue :background ,bg-blue))))
   `(orderless-match-face-1 ((t (:foreground ,pale-red :background ,bg-red))))
   `(orderless-match-face-2 ((t (:foreground ,pale-green :background ,bg-green))))
   `(orderless-match-face-3 ((t (:foreground ,pale-yellow :background ,bg-yellow))))

   ;; Vertico

   `(vertico-current         ((t (:background ,bg2))))
   `(vertico-group-separator ((t (:strike-through t :inherit (shadow)))))
   `(vertico-group-title     ((t (:slant italic :inherit (shadow)))))
   `(vertico-multiline       ((t (:inherit (shadow)))))

   ;; Vertico Posframe

   `(vertico-posframe                 ((t (:inherit (default)))))
   `(vertico-posframe-border          ((t (:background ,grey))))
   `(vertico-posframe-border-2        ((t (:background ,light-red))))
   `(vertico-posframe-border-3        ((t (:background ,light-green))))
   `(vertico-posframe-border-4        ((t (:background ,light-blue))))
   `(vertico-posframe-border-fallback ((t (:background ,light-yellow))))


;;; Terminal and Shell Colors

   ;; Ansi Colors

   `(ansi-color-black          ((t (:foreground ,bg0h :background ,bg0h))))
   `(ansi-color-red            ((t (:foreground ,light-red :background ,light-red))))
   `(ansi-color-green          ((t (:foreground ,light-green :background ,light-green))))
   `(ansi-color-yellow         ((t (:foreground ,light-yellow :background ,light-yellow))))
   `(ansi-color-blue           ((t (:foreground ,light-blue :background ,light-blue))))
   `(ansi-color-magenta        ((t (:foreground ,light-purple :background ,light-purple))))
   `(ansi-color-cyan           ((t (:foreground ,light-aqua :background ,light-aqua))))
   `(ansi-color-white          ((t (:foreground ,fg4 :background ,fg4))))
   `(ansi-color-bright-black   ((t (:foreground ,grey :background ,grey))))
   `(ansi-color-bright-red     ((t (:foreground ,light-red :background ,light-red))))
   `(ansi-color-bright-green   ((t (:foreground ,light-green :background ,light-green))))
   `(ansi-color-bright-yellow  ((t (:foreground ,light-yellow :background ,light-yellow))))
   `(ansi-color-bright-blue    ((t (:foreground ,light-blue :background ,light-blue))))
   `(ansi-color-bright-magenta ((t (:foreground ,light-purple :background ,light-purple))))
   `(ansi-color-bright-cyan    ((t (:foreground ,light-aqua :background ,light-aqua))))
   `(ansi-color-bright-white   ((t (:foreground ,fg1 :background ,fg1))))

;;; Programming Auxiliary

   ;; Paren Mode

   `(show-paren-match            ((t (:background ,bg4))))
   `(show-paren-match-expression ((t (:inherit show-paren-match))))
   `(show-paren-mismatch         ((t (:foreground ,fg0 :background ,light-red :weight bold))))

   ;; Rainbow Delimiters

   `(rainbow-delimiters-base-face       ((t (:inherit default))))
   `(rainbow-delimiters-base-error-face ((t (:foreground ,light-red :background ,bg0h))))
   `(rainbow-delimiters-unmatched-face  ((t (:foreground ,bg0h :background ,light-red :weight bold))))
   `(rainbow-delimiters-mismatched-face ((t (:inherit rainbow-delimiters-base-unmatched-face))))
   `(rainbow-delimiters-depth-1-face    ((t (:foreground ,light-orange))))
   `(rainbow-delimiters-depth-2-face    ((t (:foreground ,light-red))))
   `(rainbow-delimiters-depth-3-face    ((t (:foreground ,light-green))))
   `(rainbow-delimiters-depth-4-face    ((t (:foreground ,light-blue))))
   `(rainbow-delimiters-depth-5-face    ((t (:foreground ,light-aqua))))
   `(rainbow-delimiters-depth-6-face    ((t (:foreground ,light-purple))))
   `(rainbow-delimiters-depth-7-face    ((t (:foreground ,orange))))
   `(rainbow-delimiters-depth-8-face    ((t (:foreground ,red))))
   `(rainbow-delimiters-depth-9-face    ((t (:foreground ,green))))

   ;; Magit
   `(magit-branch-local ((t (:foreground ,light-aqua))))
   `(magit-section-heading ((t (:foreground ,light-aqua :bold t))))

;;; Languages and IDE Packages

   ;; Flycheck
   `(flycheck-error          ((t (:background ,bg1 :underline (:style wave :color ,light-red)))))
   `(flycheck-info           ((t (:background ,bg1 :underline (:style wave :color ,light-blue)))))
   `(flycheck-warning        ((t (:background ,bg1 :underline (:style wave :color ,light-yellow)))))
   `(flycheck-fringe-error   ((t (:inherit fringe :foreground ,light-red))))
   `(flycheck-fringe-info    ((t (:inherit fringe :foreground ,light-yellow))))
   `(flycheck-fringe-warning ((t (:inherit fringe :foreground ,light-green))))

   ;; Flyspell
   `(flyspell-duplicate ((t (:underline (:style wave :color ,light-yellow)))))
   `(flyspell-incorrect ((t (:underline (:style wave :color ,light-red)))))


;;; Internet Modes

   ;; Elpher

   `(elpher-binary                     ((t (:inherit (elpher-unknown)))))
   `(elpher-gemini                     ((t (:foreground ,light-aqua :weight normal :inherit (link)))))
   `(elpher-gemini-heading1            ((t (:foreground ,light-red :height 1.8 :inherit (default)))))
   `(elpher-gemini-heading2            ((t (:foreground ,light-yellow :height 1.4 :inherit (default)))))
   `(elpher-gemini-heading3            ((t (:foreground ,light-orange :height 1.2 :inherit (default)))))
   `(elpher-gemini-preformatted        ((t (:foreground ,grey :inherit (fixed-pitch)))))
   `(elpher-gemini-preformatted-toggle ((t (:inherit (button)))))
   `(elpher-gemini-quoted              ((t (:inherit (italic)))))
   `(elpher-html                       ((t (:inherit (elpher-other-url)))))
   `(elpher-image                      ((t (:inherit (elpher-other-url)))))
   `(elpher-index                      ((t (:foreground ,light-red))))
   `(elpher-info                       ((t (:inherit (elpher-text)))))
   `(elpher-margin-brackets            ((t (:inherit (bold)))))
   `(elpher-margin-key                 ((t (:inherit (shadow)))))
   `(elpher-other-url                  ((t (:foreground ,bg4 :slant italic))))
   `(elpher-search                     ((t (:foreground ,light-yellow))))
   `(elpher-telnet                     ((t (:inherit (elpher-unknown)))))
   `(elpher-text                       ((t (:inherit (bold)))))
   `(elpher-unknown                    ((t (:foreground ,bg4))))

   ;; Gemini

   `(gemini-heading-face-1    ((t (:foreground ,light-red :height 1.8 :inherit (default)))))
   `(gemini-heading-face-2    ((t (:foreground ,light-yellow :height 1.4 :inherit (default)))))
   `(gemini-heading-face-3    ((t (:foreground ,light-orange :height 1.2 :inherit (default)))))
   `(gemini-heading-face-rest ((t (:inherit (bold)))))
   `(gemini-preformatted-face ((t (:foreground ,grey :inherit (fixed-pitch)))))
   `(gemini-quote-face        ((t (:inherit (italic)))))
   `(gemini-ulist-face        ((t (:inherit (default)))))

;;; Org

   ;; Org General
   `(org-archived                 ((t (:foreground ,bg4))))
   `(org-block                    ((t (:background ,bg1 :extend t))))
   `(org-block-begin-line         ((t (:foreground ,grey :inherit (org-block)))))
   `(org-block-end-line           ((t (:inherit (org-block-begin-line)))))
   `(org-code                     ((t (:foreground ,light-orange :inherit org-block))))
   `(org-checkbox-statistics-done ((t (:inherit org-done))))
   `(org-checkbox-statistics-todo ((t (:inherit org-todo))))
   `(org-checkbox                 ((t (:inherit org-todo))))
   `(org-date                     ((t (:foreground ,light-green))))
   `(org-drawer                   ((t (:foreground ,(cur-theme-lighten light-aqua 0.4)))))
   `(org-done                     ((t (:inherit org-headline-done :weight bold))))
   `(org-ellipsis                 ((t (:foreground ,light-orange))))
   `(org-footnote                 ((t (:foreground ,light-orange))))
   `(org-formula                  ((t (:foreground ,light-green))))
   `(org-headline-done            ((t (:foreground ,bg4))))
   `(org-headline-todo            ((t (:foreground ,light-green))))
   `(org-link                     ((t (:foreground ,light-yellow :inherit link))))
   `(org-list-dt                  ((t (:foreground ,light-aqua))))
   `(org-meta-line                ((t (:foreground ,grey))))
   `(org-priority                 ((t (:foreground ,light-red))))
   `(org-property-value           ((t (:inherit default))))
   `(org-quote                    ((t (:foreground ,fg2  :inherit (italic org-block)))))
   `(org-special-keyword          ((t (:foreground ,(cur-theme-lighten light-aqua 0.15)))))
   `(org-table                    ((t (:foreground ,light-aqua))))
   `(org-tag                      ((t (:foreground ,bg4 :weight normal))))
   `(org-todo                     ((t (:inherit org-headline-todo :weight bold))))
   `(org-verbatim                 ((t (:foreground ,light-yellow))))

   ;; Outline N and Org Heading Levels
   `(outline-1 ((t (:foreground ,light-purple :weight bold :extend t))))
   `(outline-2 ((t (:foreground ,light-aqua :weight bold :extend t))))
   `(outline-3 ((t (:foreground ,light-green :weight bold :extend t))))
   `(outline-4 ((t (:foreground ,(cur-theme-lighten light-purple 0.2) :weight bold :extend t))))
   `(outline-5 ((t (:foreground ,(cur-theme-lighten aqua 0.25) :weight bold :extend t))))
   `(outline-6 ((t (:foreground ,(cur-theme-lighten light-purple 0.4) :weight bold :extend t))))
   `(outline-7 ((t (:foreground ,(cur-theme-lighten aqua 0.5) :weight bold :extend t))))
   `(outline-8 ((t (:foreground ,(cur-theme-lighten light-aqua 0.6) :weight bold :extend t))))

   `(nerd-icons-blue       ((t (:foreground ,light-blue))))
   `(nerd-icons-blue-alt   ((t (:foreground ,light-aqua))))
   `(nerd-icons-cyan       ((t (:foreground ,light-aqua))))
   `(nerd-icons-cyan-alt   ((t (:foreground ,light-aqua))))
   `(nerd-icons-dblue      ((t (:foreground ,blue))))
   `(nerd-icons-dcyan      ((t (:foreground ,aqua))))
   `(nerd-icons-dgreen     ((t (:foreground ,(cur-theme-darken light-green 0.3)))))
   `(nerd-icons-dmaroon    ((t (:foreground ,(cur-theme-darken red 0.3)))))
   `(nerd-icons-dorange    ((t (:foreground ,(cur-theme-darken light-orange 0.3)))))
   `(nerd-icons-dpink      ((t (:foreground ,(cur-theme-lighten light-red 0.15)))))
   `(nerd-icons-dpurple    ((t (:foreground ,(cur-theme-darken light-purple 0.3)))))
   `(nerd-icons-dred       ((t (:foreground ,(cur-theme-darken light-red 0.3)))))
   `(nerd-icons-dsilver    ((t (:foreground ,(cur-theme-lighten grey 0.1)))))
   `(nerd-icons-dyellow    ((t (:foreground ,(cur-theme-darken yellow 0.3)))))
   `(nerd-icons-green      ((t (:foreground ,light-green))))
   `(nerd-icons-lblue      ((t (:foreground ,(cur-theme-lighten light-blue 0.3)))))
   `(nerd-icons-lcyan      ((t (:foreground ,(cur-theme-lighten light-aqua 0.3)))))
   `(nerd-icons-lgreen     ((t (:foreground ,(cur-theme-lighten light-green 0.3)))))
   `(nerd-icons-lmaroon    ((t (:foreground ,(cur-theme-lighten red 0.3)))))
   `(nerd-icons-lorange    ((t (:foreground ,(cur-theme-lighten light-orange 0.3)))))
   `(nerd-icons-lpink      ((t (:foreground ,(cur-theme-lighten light-red 0.55)))))
   `(nerd-icons-lpurple    ((t (:foreground ,(cur-theme-lighten light-purple 0.3)))))
   `(nerd-icons-lred       ((t (:foreground ,(cur-theme-lighten light-red 0.3)))))
   `(nerd-icons-lsilver    ((t (:foreground ,(cur-theme-lighten grey 0.7)))))
   `(nerd-icons-lyellow    ((t (:foreground ,(cur-theme-lighten yellow 0.3)))))
   `(nerd-icons-maroon     ((t (:foreground ,red))))
   `(nerd-icons-orange     ((t (:foreground ,light-orange))))
   `(nerd-icons-pink       ((t (:foreground ,(cur-theme-lighten light-red 0.35)))))
   `(nerd-icons-purple     ((t (:foreground ,light-purple))))
   `(nerd-icons-purple-alt ((t (:foreground ,(cur-theme-blend light-purple grey 0.15)))))
   `(nerd-icons-red        ((t (:foreground ,light-red))))
   `(nerd-icons-red-alt    ((t (:foreground ,(cur-theme-blend light-red grey 0.15)))))
   `(nerd-icons-silver     ((t (:foreground ,(cur-theme-lighten grey 0.45)))))
   `(nerd-icons-yellow     ((t (:foreground ,yellow))))
   )
  )

(provide-theme 'cur-gruvbox)
;;; cur-gruvbox-theme.el ends here
#+end_src
