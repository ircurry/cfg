#+title: Emacs Configuration
#+author: icurry
#+language: en
#+options: toc:2 num:t author:t
#+startup: content

* Introduction and Overview

* Initialization of Emacs (=init.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./init.el
:END:

** Emacs Version Check

I have not tested this config on any emacs version less than 29.1.

#+begin_src emacs-lisp
  ;; ===Check Emacs Version===
  (when (version< emacs-version "29.1")
    (error "This setup is only guarunteed to work on 29.1, disable this line to load anyways."))
#+end_src

** Some Basic Settings

These are some basic settings that don't really fit anywhere else in my config.

#+begin_src emacs-lisp
  ;; ===Basic Settings===
  (setq frame-title-format "%b")      ;; Set window title to buffer name
  (setq initial-scratch-message ";; Scratch Buffer\n\n")
  (setq initial-buffer-choice t)      ;; Scratch as initial buffer
  (setq make-backup-files nil)        ;; No more file~ everywhere
  (setq inhibit-startup-message t)    ;; Starts on blank screen
  (scroll-bar-mode -1)                ;; Disable visible scrollbar
  (tool-bar-mode -1)                  ;; Disable tool bar
  (menu-bar-mode -1)                  ;; Disable menu bar
  (tooltip-mode -1)                   ;; Disable tooltips
  (set-fringe-mode 10)                ;; No idea what this does
#+end_src

** Enabling Disabled Functions

These functions I want enabled and not asking me if I want to run the command every single time.

#+begin_src emacs-lisp
  ;; ===Enable Disabled Functions===
  (dolist (c '(narrow-to-region narrow-to-page upcase-region downcase-region))
    (put c 'disabled nil))
#+end_src

** "Disabling" Custom

Set it to a temp file so I don't have to deal with custom, lol.

#+begin_src emacs-lisp
  ;; ===Disable Custom===
  (setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Package.el and Package Archives

This is only used if I find myself on a non-nixos system, as I have nixos manage my emacs packages instead.

#+begin_src emacs-lisp
  ;; ===Package Initialization===
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/"))) ;; Setting Repos
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

** Use-package

Setting up use package. Not sure if all of this is necessary now since ~use-package~ comes with base emacs now.

#+begin_src emacs-lisp
  ;; ===use-package Initialization===
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+end_src

** Configuration modules.

First, I add the =cur-lisp= and =cur-config= to the ~load-path~. Then its just as simple as ~(require 'module)~.

#+begin_src emacs-lisp
  ;; ===Load Modules and Packages===
  (dolist (path '("cur-lisp" "cur-config"))
    (add-to-list 'load-path (locate-user-emacs-file path)))

  ;; =====================
  ;; == Loading Modules ==
  ;; =====================

  ;; ===Essentials===
  (require 'cur-config-essentials)
  (require 'cur-config-isearch)
  (require 'cur-config-bindings)
  (require 'cur-config-help)
  (require 'cur-config-dired)

  ;; ===Interfaces===
  (require 'cur-config-faces)
  (require 'cur-config-completion)
  (require 'cur-config-windows)
  (require 'cur-modeline)

  ;; ===Languages===
  (require 'cur-config-ide)
  (require 'cur-config-elisp)
  (require 'cur-config-java)
  (require 'cur-config-markup)
  (require 'cur-config-nix)
  (require 'cur-config-rust)
  (require 'cur-config-haskell)
  (require 'cur-config-c)
  (require 'cur-config-zig)
  (require 'cur-config-go)

  ;; ===Terminal Apps===
  (require 'cur-config-shell)

  ;; ===Word Processing===
  (require 'cur-config-org)

  ;; ===Misc===
  (require 'cur-config-smol-net)
  (require 'cur-config-elcord)

  ;; ===Direnv is Last===
  (require 'cur-config-direnv)

  (provide 'init)
#+end_src

* Configuration Modules

** Essential configuration (=cur-config-essentials.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-essentials.el
:END:

These are the basic configurations that I have done in emacs. Its sort of a hodge-podge of fixing/changing things that are built emacs. They aren't strictly essential so the name is kind of a misnomer.

*** Parentheses highlighting

Removing the weird delay for highlighting the opposite parenthesis.

#+begin_src emacs-lisp
  ;; ===Parens===
  (use-package paren
    :ensure nil
    :demand t
    :custom
    (show-paren-delay 0 "No delay for paren highlighting"))
#+end_src

*** Line numbers

I like having absolute line numbers, especially since the meow number selection makes relative line numbers not as useful. Some modes, especially terminal and shell modes, look weird with line numbers so I disable them. Org-mode also has them disabled because they make the document look kind of weird, especially with images or non-text.

#+begin_src emacs-lisp
  ;; ===Line Numbers===
  (column-number-mode)
  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type t)
  ;; Disable line numbers for terminal modes
  (dolist (mode '(org-mode-hook
                  dired-mode-hook
                  term-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  eshell-mode-hook
                  eat-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  (provide 'cur-config-essentials)
#+end_src

** Isearch (=cur-config-isearch.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-isearch.el
:END:

#+begin_src emacs-lisp
  (use-package isearch
    :custom
    (isearch-wrap-pause 'no-ding)
    (isearch-repeat-on-direction-change t))

  (use-package cur-isearch-meow)

  (provide 'cur-config-isearch)
#+end_src

** Key bindings configurations (=cur-config-bindings.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-bindings.el
:END:

I use [[https:github.com/meow-edit/meow][meow]], a modal editing layer designed to be integrate well into emacs. It's very easy to hack on and extend and just feels more emacsy. I have had almost no issues with this, compared to evil which just felt sluggish and was hard to customize. The object-verb syntax is also really great and I prefer it to the verb-object of vim/nvim.

*** Hydra 

I use hydras for repeat keybindings. I plan to switch to use the built in repeat keymap more in the future but they are very helpful for creating something almost like a mini meow state, just for one particular task.

#+begin_src emacs-lisp
  ;; ===Hydra===
  (use-package hydra
    :demand t)
#+end_src

*** Meow

This is the meat and potatoes of my keybindings. First I have several keymaps: sub-leader, projectile, toggle, and alignment. Sub leader is for more miscellaneous one-off commands, such as ~ibuffer~. Projectile is for, you guessed it, projectile related commands. Toggle is for quick, on the fly, changing of settings, such as the font size. The alignment is currently unused as of now but will have commands to change how text is currently being viewed without actually modifying the text of the buffer, think ~recenter-top-bottom~ like commands and more.

I try to keep the leader key map as static as possible, with no keybindings being changed with the mode. If I want something to change with the mode I will put it under C-c, which I can access from =RET= via normal mode. The leader key primarily has things for interacting with general emacs constructs, like buffers, universal arg, =M-x=, etc.

The meow states, what vim/nvim call modes, are as follows:
  - *Normal* - The main state that is used. Used for navigation, selection, and editing. Basically vim's normal and visual mode in one.
  - *Insert* - Insert text, esc to go back to normal state.
  - *Motion* - A minimal state used when you don't know what the major-mode does. I have only =j=, =k=, and =SPC= bound to down, up, and leader respectively. Everything else is as the major mode defines it. It's just there so I'm still able to interface with emacs like I normally would, just with a minimal interface.
  - *Keypad* - Leader key map.
  - *Beacon* - Multi-cursor in a region. Very convenient but kmacros are GOATed.

Also of note, I find it easier to think about the cursor in normal mode as being a single character selection. This is how helix does it and I really like it so I have a lot of the meow fallback commands to operate on the char after the cursor.

A cheatsheet for the normal state can be accessed via =M-x meow-cheatsheet RET=.
  
#+begin_src emacs-lisp
  ;; ===Meow Setup===
  (use-package meow
    :after (hydra)
    :demand t
    :preface
    (defvar cur/sub-leader-keymap
      (let ((map (make-sparse-keymap)))
        map)
      "The keymap for quick command/function execution.")
    (defvar cur/projectile-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for projectile command execution from the leader key.")
    (defvar cur/toggle-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for commands that change settings from the leader key.")
    (defvar cur/alignment-map
      (let ((map (make-sparse-keymap)))
        map)
      "Keymap for commands that change alignment and cursor display.")
    (defun cur/kmacro-toggle ()
      (interactive)
      (cond
       (defining-kbd-macro
        (call-interactively #'meow-end-kmacro))
       (t
        (call-interactively #'meow-start-kmacro))))
    (defhydra cur/window (:hint nil)
      "
  ^Movement^            ^Splitting^               ^Manipulation
  ^--------^------------^---------^---------------^--------------
  _h_: left             _1_: only window          _H_: swap left
  _j_: down             _2_: split vertical       _J_: swap down
  _k_: up               _3_: split horizontal     _K_: swap up
  _l_: right            _0_: close window         _L_: swap right
  _o_: other window
  "
      ("RET" ignore "finished" :exit t)
      ("w" other-window "other window" :exit t)
      ("." delete-other-windows "only window" :exit t)
      ("f" find-file-other-window "file in new window" :exit t)
      ("v" cur/split-and-follow-vertically "split vertical" :exit t)
      (";" cur/split-and-follow-horizontally "split horizontal" :exit t)
      ("c" delete-window "delete window" :exit t)

      ("o" other-window)
      ("h" windmove-left)
      ("j" windmove-down)
      ("k" windmove-up)
      ("l" windmove-right)

      ("1" delete-other-windows)
      ("2" cur/split-and-follow-vertically)
      ("3" cur/split-and-follow-horizontally)
      ("0" delete-window)

      ("H" windmove-swap-states-left)
      ("J" windmove-swap-states-down)
      ("K" windmove-swap-states-up)
      ("L" windmove-swap-states-right))
    (defhydra cur/goto (:hint nil)
      "
  _g_:  goto line         _a_:  beginning of line     _,_: buffer start     _n_: next buffer hydra
  _s_: to indentation     _e_:  end of line           _._: buffer end       _p_: prev buffer hydra
  "
      ("g" meow-goto-line :exit t)
      ("a" move-beginning-of-line :exit t)
      ("e" move-end-of-line :exit t)
      ("m" back-to-indentation :exit t)
      ("s" back-to-indentation :exit t)
      ("," beginning-of-buffer :exit t)
      ("." end-of-buffer :exit t)
      ("n" cur/hydra-buffer-cycle/next-buffer :exit t)
      ("p" cur/hydra-buffer-cycle/previous-buffer :exit t))
    (defun meow-setup ()
      (meow-motion-overwrite-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("<escape>" . ignore))
      (meow-leader-define-key
       ;; ===Top Row===
       '("1" . delete-other-windows)
       '("2" . cur/split-and-follow-vertically)
       '("3" . cur/split-and-follow-horizontally)
       ;'("4" . )
       ;'("5" . )
       ;'("6" . )
       ;'("7" . )
       ;'("8" . )
       ;'("9" . )
       '("0" . delete-window)

       ;; ===2nd Row===
       ;'("TAB"  . )
       '("q" . comment-dwim)
       '("w" . cur/window/body)
       ;'("e" . )
       '("r" . query-replace)
       (cons "t" cur/toggle-map)
       ;'("y" . )
       '("u" . universal-argument)
       ;'("i" . )
       ;'("o" . )
       (cons "p" cur/projectile-map)
       ;'("-" . )

       ;; ===3rd Row===
       ;'("<escape>" . )
       ;'("a" . )
       '("s" . save-buffer)
       '("d" . kill-current-buffer)
       '("f" . counsel-find-file)
       ;'("g" . )
       ;'("h" . )
       '("j" . other-window)
       '("k" . cur/other-window-reverse)
       ;'("l" . )
       (cons ";" cur/sub-leader-keymap)
       '("RET"   . counsel-M-x)

       ;; ===4th Row===
       (cons "z" cur/alignment-map)
       ;'("x" . )
       ;'("c" . )
       ;'("v" . )
       '("b" . counsel-switch-buffer)
       '("B" . ibuffer)
       ;'("n" . )
       ;'("m" . )
       '("," . meow-bounds-of-thing)
       '("." . meow-inner-of-thing)
       '("/" . rg)
       ;'("'"  . )
       )
      (meow-normal-define-key
       ;; ===Top Row===
       '("1" . meow-expand-1)
       ;'("!" . )
       '("2" . meow-expand-2)
       ;'("@" . )
       '("3" . meow-expand-3)
       ;'("#" . )
       '("4" . meow-expand-4)
       ;'("$" . )
       '("5" . meow-expand-5)
       ;'("%" . )
       '("6" . meow-expand-6)
       ;'("^" . )
       '("7" . meow-expand-7)
       ;'("&" . )
       '("8" . meow-expand-8)
       ;'("*" . )
       '("9" . meow-expand-9)
       ;'("(" . )
       '("0" . meow-expand-0)
       ;'(")" . )

       ;; ===2nd Row===
       ;'("TAB"  . )
       ;'("BTAB" . )
       '("q" . kmacro-end-and-call-macro)
       '("Q" . cur/kmacro-toggle)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("r" . meow-replace)
       ;'("R" . )
       '("t" . meow-till)
       '("T" . meow-till-expand)
       '("y" . meow-save)
       '("Y" . meow-clipboard-save)
       '("u" . meow-undo)
       ;'("U" . )
       '("i" . meow-insert)
       ;'("I" . )
       '("o" . meow-open-below)
       '("O" . meow-open-above)
       '("p" . meow-yank)
       '("P" . meow-clipboard-yank)
       '("-" . negative-argument)
       ;'("_" . )

       ;; ===3rd Row===
       '("<escape>" . keyboard-quit)
       '("a" . meow-append)
       ;'("A" . )
       '("s" . repeat)
       ;'("S" . )
       '("d" . meow-kill)
       '("D" . meow-c-k)
       '("f" . meow-find)
       '("F" . meow-find-expand)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '(";" . meow-reverse)
       '(":" . meow-page-up)
       '("RET" . "C-c")
       ;'("S-RET" . )

       ;; ===4th Row===
       '("z" . meow-pop-selection)
       ;'("Z" . )
       '("x" . meow-line)
       '("X" . meow-line-expand)
       '("c" . meow-change)
       ;'("C" . )
       ;'("v" . )
       ;'("V" . )
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("n" . meow-search)
       '("N" . meow-goto-line)
       '("m" . meow-join)
       ;'("M" . )
       '("," . meow-beginning-of-thing)
       '("<" . meow-bounds-of-thing)
       '("." . meow-end-of-thing)
       '(">" . meow-inner-of-thing)
       '("/" . isearch-meow-wrapper)
       '("?" . meow-page-down)
       '("'"  . meow-block)
       '("\"" . meow-to-block)))
    :init
    (defhydra cur/hydra-buffer-cycle (:timeout 4)
      "tab through buffers"
      ("n" next-buffer "next buffer")
      ("p" previous-buffer "previous buffer")
      ("f" nil "finished" :exit t)
      ("RET" nil "finished" :exit t))
    :custom
    (meow-mode-state-list
     '((authinfo-mode . normal)
       (beancount-mode . normal)
       (bibtex-mode . normal)
       (cider-repl-mode . normal)
       (cider-test-report-mode . normal)
       (cider-browse-spec-view-mode . motion)
       (cargo-process-mode . normal)
       (conf-mode . normal)
       (deadgrep-edit-mode . normal)
       (deft-mode . normal)
       (diff-mode . normal)
       (dired-mode . motion)
       (eat-mode . insert)
       (ediff-mode . motion)
       (eshell-mode . insert)
       (gud-mode . normal)
       (haskell-interactive-mode . normal)
       (help-mode . normal)
       (helpful-mode . normal)
       (json-mode . normal)
       (jupyter-repl-mode . normal)
       (mix-mode . normal)
       (occur-edit-mode . normal)
       (pass-view-mode . normal)
       (prog-mode . normal)
       (py-shell-mode . normal)
       (restclient-mode . normal)
       (telega-chat-mode . normal)
       (term-mode . normal)
       (text-mode . normal)
       (vterm-mode . normal)
       (Custom-mode . normal))
     "Default meow states for modes")
    (meow-selection-command-fallback
     '((meow-change . meow-change-char)
       (meow-kill . meow-C-d)
       (meow-cancel-selection . keyboard-quit)
       (meow-pop-selection . meow-pop-grab)
       (meow-beacon-change . meow-beacon-change-char))
     "Meow fallback commands")
    (meow-keypad-describe-delay 0.0 "No delay in keypad help popup")
    (meow-cheats-layout meow-cheatsheet-layout-qwerty "Meow qwerty layout for the cheatsheet")
    :bind (:map cur/sub-leader-keymap
                ("C-b"   . ibuffer))
    :config
    (setq meow-kteypad-leader-dispatch nil)
    (meow-setup)
    (meow-global-mode 1))

  (provide 'cur-config-bindings)
#+end_src

** Help configurations (=cur-config-help.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-help.el
:END:

Enhancing the help mechanisms in emacs.

*** Which-key

Which-key shows you what keybindings are available in a keychord. Super helpful and a must have in emacs.

#+begin_src emacs-lisp
  ;; ===which-key===
  (use-package which-key
    :demand t
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.0001))
#+end_src

*** Helpful

Provides additional info help.

#+begin_src emacs-lisp
  ;; ===helpful===
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src

*** Info

Info is emacs' built in manual system. In essence, its a more feature rich =man= (which emacs also has easy access to with =woman=). Right now I have a custom meow state for keybindings. However, this kind of sucks and I will eventually switch to just changing the default keybindings.

#+begin_src emacs-lisp
  ;; ===Info===
  (use-package info
    :config
    (setq meow-info-keymap (make-keymap))
    (meow-define-state info
      "meow state for interacting with Info"
      :lighter "INFO"
      :keymap meow-info-keymap)
    (meow-define-keys 'info
      '(":" . meow-page-up)
      '("?" . meow-page-down)
      '("," . beginning-of-buffer)
      '("." . end-of-buffer)
      ; '("a" . )
      ; '("b" . )
      ; '("c" . Info-follow-reference)
      ; '("d" . )
      ; '("e" . )
      '("f" . Info-menu)
      '("g" . keyboard-quit)
      '("h" . Info-backward-node)
      '("H" . meow-left)
      '("i" . Info-index)
      '("j" . meow-next)
      '("k" . meow-prev)
      '("l" . Info-forward-node)
      '("L" . meow-right)
      '("m" . meow-join)
      '("n" . Info-next)
      ; '("o" . )
      '("p" . Info-prev)
      '("q" . meow-goto-line)
      '("r" . Info-follow-reference)
      ; '("s" . )
      '("t" . Info-toc)
      '("u" . Info-up)
      '("v" . meow-visit)
      ; '("w" . )
      ; '("x" . )
      '("y" . Info-copy-current-node-name)
      '("z" . info-display-manual)
      '("RET" . Info-follow-nearest-node)
      '("SPC" . meow-keypad)
      '("TAB" . Info-next-reference)
      '("<backtab>" . Info-prev-reference)
      '("<escape>" . keyboard-quit))
    (add-hook 'Info-mode-hook #'meow-info-mode))

  (provide 'cur-config-help)
#+end_src

** Dired configuration (=cur-config-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-dired.el
:END:

Dired is the built in file manager in emacs. Its very capable and very hackable although it lacks good file previewing solutions

*** Nerd Icons Dired

Adds icons to make dired a bit more pretty and gives a visual sense of what files are what. 

#+begin_src emacs-lisp
  ;; ===Dired Icons===
  (use-package nerd-icons-dired
    :after (dired)
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** Main Dired Configuration

By default, I want dired to look very minimal. This lack of clutter makes it easier to focus on what I am doing in the file manager. This is also the approach I try to take with other parts of emacs as well. By default, I have file details (owner, permissions, last modified, etc.) hidden. I have other changes as well, use the system trash can instead of deleting, that are under the ~:config~ part of the ~use-package~ declaration.

The keybindings are a hybrid of my normal state and the default dired keybindings.

#+begin_src emacs-lisp
  ;; ===Dired===
  (use-package dired
    :hook
    (dired-mode . dired-hide-details-mode) ; don't show file details by default
    (dired-mode . hl-line-mode) ; Highlight the line the cursor is on
    ;; TODO: create a dired-find-file-dwim for external programs
    :bind (:map dired-mode-map
                ;; ===Top Row===
                ;; ("1" . )
                ;; ("!" . )
                ;; ("2" . )
                ;; ("@" . )
                ;; ("3" . )
                ;; ("#" . )
                ;; ("4" . )
                ;; ("$" . )
                ;; ("5" . )
                ;; ("%" . )
                ;; ("6" . )
                ;; ("^" . )
                ;; ("7" . )
                ;; ("&" . )
                ;; ("8" . )
                ;; ("*" . )
                ;; ("9" . )
                ;; ("(" . )
                ;; ("0" . )
                ;; (")" . )

                ;; ===2nd Row===
                ;; ("TAB"  . )
                ;; ("BTAB" . )
                ("q" . kmacro-end-and-call-macro)
                ("Q" . cur/kmacro-toggle)
                ;; ("w" . )
                ;; ("W" . )
                ;; ("e" . )
                ;; ("E" . )
                ("r" . dired-do-rename)
                ("R" . dired-toggle-read-only)
                ("t" . dired-toggle-marks)
                ;; ("T" . )
                ;; ("y" . )
                ;; ("Y" . )
                ("u" . dired-unmark)
                ("U" . dired-unmark-all-marks)
                ("i" . dired-isearch-filenames-regexp)
                ("I" . dired-do-isearch-regexp)
                ;; ("o" . )
                ("O" . dired-do-chown)
                ("p" . dired-previous-line)
                ;; ("P" . )
                ("-" . negative-argument)
                ;; ("_" . )

                ;; ===3rd Row===
                ("<escape>" . keyboard-quit)
                ;; ("a" . )
                ;; ("A" . )
                ;; ("s" . )
                ;; ("S" . )
                ("d" . dired-do-kill-lines)
                ("D" . dired-do-delete)
                ("f" . find-file)
                ;; ("F" . )
                ("g" . revert-buffer)
                ;; ("G" . )
                ("h" . dired-up-directory)
                ;; ("H" . )
                ("j" . dired-next-line)
                ;; ("J" . )
                ("k" . dired-previous-line)
                ;; ("K" . )
                ("l" . dired-find-file)
                ("L" . dired-find-file-other-window)
                ;; (";" . )
                ;; (":" . )
                ("RET" . dired-find-file)
                ;; ("S-RET" . )

                ;; ===4th Row===
                ("z" . dired-undo)
                ;; ("Z" . )
                ("x" . dired-mark)
                ;; ("X" . )
                ("c" . dired-do-copy)
                ("C" . dired-do-copy-regexp)
                ("v" . dired-find-file-other-window)
                ;; ("V" . )
                ;; ("b" . )
                ;; ("B" . )
                ("n" . dired-next-line)
                ;; ("N" . )
                ("m" . dired-mark-files-regexp)
                ("M" . dired-do-chmod)
                ;; ("," . )
                ;; ("<" . )
                ;; ("." . )
                ;; (">" . )
                ("/" . dired-goto-file)
                ;; ("?" . )
                ;; ("'"  . )
                ;; ("\"" . )
                )
    :config
    (setq delete-by-moving-to-trash t)
    (setq dired-recursive-copies t)
    (setq dired-recursive-deletes t)
    (setq dired-listing-switches "-A -G -F -h -l -v --group-directories-first --time-style=long-iso")
    (setq dired-dwim-target t)
    (setq dired-auto-revert-buffer #'dired-directory-changed-p)
    (setq dired-free-space nil)
    (setq dired-make-directory-clickable t)
    (setq dired-mouse-drag-files t))

  (provide 'cur-config-dired)
#+end_src

** Faces, themes, and eye candy configurations (=cur-config-faces.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-faces.el
:END:

I think that emacs should have a lot of eye candy, especially since I spend so much time in it. These are my configurations for emacs' faces, theming and ui settings essentially.

*** Default Font

JetBrains Mono supremacy.

#+begin_src emacs-lisp
  ;; ===Default Font===
  (add-to-list 'default-frame-alist
               '(font . "JetBrains Mono Nerd Font-11"))
#+end_src

*** TODO Custom themes

I have several custom themes in a directory weirdly named themes. These are the =everforest= and =kanagawa= themes. I have changed these from the originals. TODO: add the links to the original themes.

#+begin_src emacs-lisp
  ;; ===Themes Path===
  (add-to-list 'custom-theme-load-path (locate-user-emacs-file "themes"))
#+end_src

*** Doom themes

Doom themes are a theme pack specifically for the Doom Emacs distribution, but work well without doom as well. I have a function that sets some faces based on the theme in ~custom-enabled-themes~. This function is more than just a little jank and I plan on creating my own themes instead of trying to hack around ones made by someone else.

#+begin_src emacs-lisp
  ;; ===Doom Emacs Themes===
  (use-package doom-themes
    :demand t
    :init
    (defun cur/theme-override ()
      "Change faces depending on what the value of `custom-enabled-themes' is."
      (cond ((member 'doom-gruvbox custom-enabled-themes)
             (set-face-attribute 'secondary-selection nil
                                 :background "#504945"))
            ((member 'doom-flatwhite custom-enabled-themes)
             (set-face-attribute 'haskell-operator-face nil
                                 :background (doom-color 'bg)
                                 :foreground (doom-color 'fg))
             (set-face-attribute 'haskell-type-face nil
                                 :background (doom-color 'fw-teal-blend)
                                 :foreground (doom-color 'fw-teal-text))
             (set-face-attribute 'haskell-constructor-face nil
                                 :background (doom-color 'fw-orange-blend)
                                 :foreground (doom-color 'fw-orange-text)))
            (t t)))
    (defun cur/load-theme (theme)
      "Load THEME, disabling all other currently enabled themes. Then
  check for overrides with `cur/theme-override'."
      (interactive
       (list
        (intern (completing-read "Cur Custom Themes: "
                                 (mapcar #'symbol-name
                                         (custom-available-themes))))))
      (condition-case nil
          (progn
            (mapc #'disable-theme custom-enabled-themes)
            (load-theme theme t)
            (cur/theme-override))
        (error "Problem loading theme %s" theme)))
    :bind (:map cur/toggle-map
                ("C-t" . cur/load-theme))
    :config
    (cur/load-theme 'doom-nord-aurora))
#+end_src

*** Autothemer

A library used by =catppuccin= and =kanagawa=.

#+begin_src emacs-lisp
  ;; ===Autothemer===
  (use-package autothemer)
#+end_src

*** Catppuccin Theme

[[https:github.com/catppuccin/catppuccin][Link]] to the catppuccin theme.

#+begin_src emacs-lisp
  ;; ===Catppuccin Theme===
  (use-package catppuccin-theme
    :after (autothemer))
#+end_src

*** Text Scaling Hydra

A simple hydra that allows me to interactively set the size of the text in a buffer.

#+begin_src emacs-lisp
  ;; ===Text Scaling===
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("k" text-scale-increase "in")
    ("j" text-scale-decrease "out")
    ("f" nil "finished" :exit t)
    ("RET" nil "finished" :exit t))
  (define-key cur/toggle-map (kbd "C-s") 'hydra-text-scale/body)
#+end_src

*** Ef-themes

Themes made by Protesilaos, also known as Prot. I like them and use them from time to time.

#+begin_src emacs-lisp
  ;; ===Ef-Themes===
  (use-package ef-themes)
#+end_src

*** Nerd Icons Ibuffer

Adds Icons to ~ibuffer~. Not really a face thing but I don't have a dedicated ~ibuffer~ module so it goes here instead.

#+begin_src emacs-lisp
  ;; ===Ibuffer Icons===
  (use-package nerd-icons-ibuffer
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** Spacious Padding

It adds padding and makes emacs look better.

#+begin_src emacs-lisp
  ;; ===Spacious Padding===
  (use-package spacious-padding
    :config
    (setq spacious-padding-widths
          '(:internal-border-width 8
            :header-line-width 0
            :mode-line-width 0
            :tab-width 0
            :right-divider-width 18
            :scroll-bar-width 0
            :fringe-width 0))
    (setq spacious-padding-subtle-mode-line nil)
    (spacious-padding-mode 1))

  (provide 'cur-config-faces)
#+end_src

** Completion system configurations (=cur-config-completion.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-completion.el
:END:

This section is not about code completion. Rather, this is my configuration for Emacs' completion system and the main interfaces that use them. For code completion please go see =cur-config-ide.el= and ~company-mode~.

Currently I am using the [[https:github.com/abo-abo/swiper/][ivy/counsel/swiper]] suite for doing completions in emacs. I like it but I know that the vertico/marginelia/consult/embark chain is better, faster, and more modern. I plan to make the switch at some point but for now I sticking with ivy.

*** Counsel

Counsel is a package that provides replacement functions for common emacs tasks that better integrates with ivy.

#+begin_src emacs-lisp
  ;; ===Counsel==
  (use-package counsel
    :demand t
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-switch-buffer)
           ("C-x C-f" . counsel-find-file)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))
#+end_src

*** Swiper

Basically isearch with a nice ui.

#+begin_src emacs-lisp
  ;; ===Swiper===
  (use-package swiper
    :commands (swiper))
#+end_src

*** Ivy

A better completion system for emacs. Much of the ivy config is just setting keybindings for the minibuffer.

#+begin_src emacs-lisp
  ;; ===Ivy===
  (use-package ivy
    :demand t
    :after (counsel)
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))
#+end_src

*** Ivy-rich

A better interface for ivy.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :after (counsel ivy)
    :config
    (ivy-rich-mode 1))

  (provide 'cur-config-completion)
#+end_src

** Window management configurations (=cur-config-windows.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-windows.el
:END:

The default window functions only split the window and don't jump to the newly created window like you would expect in say a tiling window manager. These functions are provide that kind of functionality.

#+begin_src emacs-lisp
  ;;; cur-config-windows.el --- emacs windows configuration

  ;;; Commentary:

  ;;; Code:

  ;; ===Window Functions===
  (defun cur/split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun cur/split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (defun cur/other-window-reverse ()
    (interactive)
    (other-window -1))

  (provide 'cur-config-windows)
  ;;; cur-config-windows.el ends here
#+end_src

** IDE configurations (=cur-config-ide.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-ide.el
:END:

Emacs can be made to have all the features of a modern text editor and then some.

*** LSP-mode

Lsp-mode is my chosen language server protocol support package. I chose this over eglot because of the richer features and (at the time that I started using lsp) more mature state. I will revisit elgot in the future but for now I am perfectly happy with lsp-mode.

#+begin_src emacs-lisp
  ;; ===LSP Mode===
  (use-package lsp-mode
    :demand t
    :hook
    (lsp-mode  . lsp-enable-which-key-integration)
    :custom
    (lsp-keymap-prefix "C-c C-M-l" "lsp mode keymap")
    :bind (:map lsp-mode-map
                ("C-c C-a" . lsp-execute-code-action)  ; code actions
                ("C-c C-e" . lsp-treemacs-errors-list) ; treemacs error list
                ("C-c f"   . lsp-find-references)      ; find references
                ("C-c r"   . lsp-find-definition))     ; find definitions
    :config
    (lsp-deferred)
    (setq gc-cons-threshold (* 100 1024 1024))
    (setq read-process-output-max (* 3 1024 1024))
    (setq lsp-idle-delay 0.500)
    (setq lsp-lens-enable nil)
    (lsp-enable-which-key-integration t))
#+end_src

*** LSP UI

Lsp-ui provides some ui enhancements and extra features to lsp. Probably the best one is the doc feature to view documentation in the editor.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :after (lsp-mode)
    :custom
    (lsp-ui-doc-enable nil "lsp-ui doc disabled by default")
    (lsp-ui-doc-show-with-cursor t "lsp-ui doc follows cursor")
    (lsp-ui-doc-show-with-mouse t "lsp-ui doc follows mouse")
    (lsp-ui-doc-position 'at-point "lsp-ui doc shows at cursor")
    :bind (:map lsp-ui-mode-map
                ("C-c C-f" . lsp-ui-peek-find-references)  ; find references ui
                ("C-c C-r" . lsp-ui-peek-find-definitions) ; find definitions ui
                ("C-c C-d" . lsp-ui-doc-mode) ; toggle doc mode
                :map lsp-ui-peek-mode-map
                ("ESC" . lsp-ui-peek--abort)             ; toggle doc mode
                ("g"   . lsp-ui-peek--abort)             ; toggle doc mode
                ("j"   . lsp-ui-peek--select-next)       ; toggle doc mode
                ("k"   . lsp-ui-peek--select-prev)       ; toggle doc mode
                ("C-j" . lsp-ui-peek--select-next-file)  ; toggle doc mode
                ("C-k" . lsp-ui-peek--select-prev-file)) ; toggle doc mode
    :hook
    (lsp-mode . lsp-ui-mode))
#+end_src

*** Company

The code completion system. This is different from completions systems like ivy or vertico, this is for interactively completing a symbol while programming.

#+begin_src emacs-lisp
  ;; ===Company Mode===
  (use-package company
    :hook
    (prog-mode . company-mode)
    (lsp-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-common-or-cycle)
                ("<return>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))
  ;;(company-tng-configure-default))
#+end_src

*** Flycheck

Code error checking with a nice UI.

#+begin_src emacs-lisp
  ;; ===Flycheck===
  (use-package flycheck
    :hook
    (prog-mode . flycheck-mode)
    (lsp-mode  . flycheck-mode))
#+end_src

*** Treemacs

Project tree, I don't use this all that often.

#+begin_src emacs-lisp
  ;; ===Treemacs==
  (use-package treemacs
    :bind
    (:map cur/sub-leader-keymap
          ("C-t" . treemacs-select-window))
    :config
    (treemacs-follow-mode))
#+end_src

*** Ivy-xref

This lets us use ivy to select xref candidates.

#+begin_src emacs-lisp
  ;; ===xref-ivy===
  (use-package ivy-xref
    :after (ivy)
    :init
    (setq xref-show-definitions-function #'ivy-xref-show-defs)
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+end_src

*** Magit

Magit is a git interface, probably the best one I have ever seen or had the pleasure of using. I consider magit to be one of emacs' "killer features", right up there with org-mode.

#+begin_src emacs-lisp
  ;; ===Magit===
  (use-package magit
    :bind (:map cur/sub-leader-keymap
                ("C-M-g" . magit))
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    (transient-default-level 5 "Allowing for commit signing"))
#+end_src

*** Projectile

Projectile provides many commands to help manage and do things in a project, such as compile a project from its root, list all files in the project, or run grep or ripgrep on all the files in the project. I also use it's project switching aspect as sort of a bookmark like system.

#+begin_src emacs-lisp
  ;; ===Projectile===
  (use-package projectile
    :after (rg)
    :bind (:map cur/projectile-map
                ("C-p"   . projectile-switch-project)
                ("C-a"   . projectile-add-known-project)
                ("C-d"   . projectile-find-dir)
                ("d"     . projectile-dired)
                ("C-f"   . projectile-find-file)
                ("C-r"   . projectile-ripgrep)
                ("C-c"   . projectile-compile-project)
                ("C-b"   . projectile-switch-to-buffer)
                ("C-l"   . projectile-ibuffer)
                ("C-k"   . projectile-kill-buffers)
                ("C-v"   . projectile-vc)
                ("C-e"   . projectile-run-eshell))
    :config
    (projectile-mode 1))

  ;; Need ripgrep wrapper for `projectile-ripgrep'
  (use-package rg)

  (provide 'cur-config-ide)
#+end_src

** Configurations for Emacs Lisp (=cur-config-elisp.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-elisp.el
:END:

These are my configurations for working with emacs lisp. Truth be told, a lot could be improved here and I intend to do so eventually.

*** Rainbow Delimiters

This color codes opening and closing delimiters such as parentheses and square brackets.

#+begin_src emacs-lisp
  ;; ===rainbow-delimiters===
  (use-package rainbow-delimiters
    ;:ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Helper Functions

These are some helper functions that I don't really use anymore. They are mostly about alists and I think some of them just replicate behavior of built in functions. I plan to either fix and move or just remove them at some point.

#+begin_src emacs-lisp
  ;; ===Helpful Emacs-Lisp Functions===
  (defun cur/alist-add-or-replace (pair alist)
    "Function to add or replace a PAIR to ALIST and return ALIST.

  This does not set the variable to be a new value."
    (let* ((pair-key     (car pair))
           (alist-result (assoc pair-key alist)))
      (if alist-result
          (let ((new-alist (assoc-delete-all pair-key alist)))
            (push pair new-alist))
        (push pair alist))))

  (defun cur/alist-add-if-pair-not-exist (pair alist)
    "Function to add a PAIR to ALIST if PAIR is not in ALIST and return ALIST.

  This does not set the variable to be a new value."
    (let* ((pair-key     (car pair))
           (pair-value   (cdr pair))
           (alist-result (assoc pair-key alist)))
      (if (and alist-result (equal pair-value alist-result))
          nil
        (push pair alist))))

  (defun cur/alist-add-if-key-not-exist (pair alist)
    "Function to add a PAIR to ALIST if the key in PAIR is not in ALIST.
  Returns ALIST.

  This does not set the variable to be a new value."
    (let* ((pair-key     (car pair))
           (alist-result (assoc pair-key alist)))
      (if alist-result
          nil
        (push pair alist))))

  (provide 'cur-config-elisp)
#+end_src

** Configurations for Java (=cur-config-java.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-java.el
:END:

My configurations for working with the Java language. I have ~java-ts-mode~, the tree sitter version of the normal ~java-mode~, as the mode for editing =.java= files. I have found that either tree sitter provides exactly the same or better syntax highlighting and the possibility of better movement once it gets better integrated into emacs.

I also have lsp-java set up for better integrating ~lsp-mode~ into ~java-ts-mode~. Note because I have =direnv= integration with ~envrc~, the hooks I add to start ~lsp~ must be ~lsp-defered~. ~lsp-defered~ does not start ~lsp-mode~ until after the buffer has visually loaded. We want this because ~envrc~ will change the ~exec-path~ to what =direnv= would change it to. For instance, if I have a devshell that says "here is the lsp-server, the build tool, and external libraries with these exact versions", envrc will make sure that ~exec-path~ contains exactly those versions of those programs in the nix store.

#+begin_src emacs-lisp
  ;; ===Java Tree-Sitter Mode===
  (use-package java-ts-mode
    :mode "\\.java\\'")

  ;; ===lsp-java===
  (use-package lsp-java
    :after (lsp-mode cc-mode)
    :init
    :hook
    (envrc-mode . (lambda ()
                    (when (equal major-mode 'java-ts-mode)
                      (setq lsp-java-server-install-dir (concat (getenv "JDTLS_PATH") "/share/java/jdtls/")))))
    (java-ts-mode . lsp-deferred)
    :config
    (defun lsp-java--ls-command ()
      (let ((jdtls-path (getenv "JDTLS_PATH"))
            (jdtls-exec-options (list
                                 "-configuration"
                                 (concat (getenv "HOME") "/.jdtls/config_linux")
                                 "-data"
                                 (concat (getenv "HOME") "/.jdtls/java-workspace"))))
        (message (concat jdtls-path "/share/java/"))
        (append (list (concat jdtls-path "/bin/jdtls")) jdtls-exec-options))))

  (provide 'cur-config-java)
#+end_src

** Configurations for Mark-up Languages (=cur-config-markup.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-markup.el
:END:

Mostly just ~yaml-mode~.

#+begin_src emacs-lisp
  ;; ===YAML===
  (use-package yaml-mode
    :commands (yaml-mode))

  (provide 'cur-config-markup)
#+end_src

** Configurations for Nix (=cur-config-nix.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-nix.el
:END:

My configurations for the Nix language, which mostly boils down to "start the lsp server".

#+begin_src emacs-lisp
  ;; ===nix-mode===
  (use-package nix-mode
    :hook
    ((nix-mode) . lsp-deferred))

  (provide 'cur-config-nix)
#+end_src

** Configurations for Rust (=cur-config-rust.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-rust.el
:END:

#+begin_src emacs-lisp
  ;; ===Rust-Mode===
  (use-package rustic
    :after (lsp-mode)
    :hook (rustic . lsp-deferred))
#+end_src

#+begin_src emacs-lisp
  (provide 'cur-config-rust)
#+end_src

** Configurations for Haskell (=cur-config-haskell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-haskell.el
:END:

#+begin_src emacs-lisp
  ;; ===Haskell-Mode===
  (use-package haskell-mode)

  ;; ===LSP-Haskell===
  (use-package lsp-haskell
    :hook
    ((haskell-mode) . lsp-deferred))

  ;; ===Company-GHCI===
  (use-package company-ghci
    :after (company)
    :custom (company-ghc-show-info t)
    :config
    (push 'company-ghci company-backends))
#+end_src

#+begin_src emacs-lisp
  (provide 'cur-config-haskell)
#+end_src

** Configurations for C (=cur-config-c.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-c.el
:END:

#+begin_src emacs-lisp
  ;; ===C Tree-Sitter Mode===
  (use-package c-ts-mode
    :after (cc-mode)
    :mode
    ("\\.c\\'" . c-ts-mode)
    ("\\.h\\'" . c-ts-mode)
    :custom
    (c-default-style '((c-ts-mode . "linux")
                       (java-mode . "java")
                       (awk-mode  . "awk")
                       (other     . "gnu"))
     "default style for c programs is linux")
    :hook
    (c-ts-mode . (lambda () (require 'ccls) (lsp-deferred))))

  ;; ===CCLS Mode===
  (use-package ccls
    :after (cc-mode c-ts-mode))
#+end_src

#+begin_src emacs-lisp
  (provide 'cur-config-c)
#+end_src

** Configurations for Zig (=cur-config-zig.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-zig.el
:END:

#+begin_src emacs-lisp
  ;; ===Zig Mode===
  (use-package zig-mode)

  (provide 'cur-config-zig)
#+end_src

** Configurations for Go (=cur-config-go.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-go.el
:END:

#+begin_src emacs-lisp
  ;; ===Go Tree-Sitter Mode===
  (use-package go-ts-mode
    :mode "\\.go\\'"
    :custom
    (go-ts-mode-indent-offset 4 "Set the indentation to 4")
    :hook (go-ts-mode . lsp-deferred))

  (provide 'cur-config-go)
#+end_src

** Terminal emulation and Eshell configuration (=cur-config-shell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-shell.el
:END:

#+begin_src emacs-lisp
  ;; ===Vterm===
  (use-package vterm
    :ensure nil
    :commands (vterm cur/meow-vterm-other-window cur/meow-vterm)
    :bind (:map vterm-mode-map
           ("C-c C-k" . cur/vterm-kill)
           :map cur/sub-leader-keymap
           ("C-RET" . cur/meow-vterm-other-window)
           ("RET"   . cur/meow-vterm))
    :init
    (defun cur/meow-vterm ()
      (interactive)
      (vterm)
      (meow-insert-mode))
    (defun cur/meow-vterm-other-window ()
      (interactive)
      (vterm-other-window)
      (meow-insert-mode))
    (defun cur/vterm-kill ()
      (interactive)
      (when (equal (buffer-name) "*vterm*")
        (let ((kill-buffer-query-functions nil))
          (kill-buffer-and-window))))
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
    (setq vterm-max-scrollback 10000))
#+end_src

#+begin_src emacs-lisp
  ;; ===Eat===
  (use-package eat
    :config
    (eat-eshell-mode 1))
#+end_src

#+begin_src emacs-lisp
  ;; ===Eshell===
  (use-package eshell
    :init
    (defun cur/eshell-prompt ()
      (concat
       (propertize "[" 'face 'ansi-color-red)
       (propertize (eshell/whoami) 'face 'ansi-color-yellow)
       (propertize "@" 'face 'ansi-color-green)
       (propertize (system-name) 'face 'ansi-color-blue)
       " "
       (propertize (concat (eshell/pwd)) 'face 'ansi-color-magenta)
       (propertize "]" 'face 'ansi-color-red)
       (propertize "$ " 'face 'bold)))
    (defun eshell/ff (&optional file)
      "Eshell alias to open FILE. Will call `find-file' interactively if no file is
  specified."
      (cond (file
             (find-file file))
            (t
             (call-interactively 'find-file))))
    (defun eshell/dir (&optional dir)
      "Eshell alias to open `dired' at DIR. Will call `dired' on current directory
  if no directory is specified"
      (cond (dir
             (dired dir))
            (t
             (dired "."))))
    :custom
    (eshell-prompt-regexp "^\\[[^]]*\\]\\[?[[:digit:]]*\\]?[#$λ] " "Regex for custom eshell prompt")
    (eshell-prompt-function 'cur/eshell-prompt "Set custom prompt for eshell"))
#+end_src

#+begin_src emacs-lisp
  ;; ===Zoxide===
  (use-package zoxide)
#+end_src

#+begin_src emacs-lisp
  (provide 'cur-config-shell)
#+end_src

** Org-mode (=cur-config-org.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-org.el
:END:

#+begin_src emacs-lisp
  ;; ===Org-Mode===
  (use-package org
    :ensure nil
    :defer t
    :hook (org-mode . cur/org-mode-setup)
    :bind (:map org-mode-map
            ("C-S-h" . outline-promote)
            ("C-S-j" . outline-move-subtree-down)
            ("C-S-k" . outline-move-subtree-up)
            ("C-S-l" . outline-demote))
    :init
    (defun cur/org-mode-setup ()
      (org-indent-mode 1)
      (variable-pitch-mode 0)
      (visual-line-mode 1)
      (flyspell-mode 1))
    :custom
    (org-ellipsis " ▾" "Readable ellipsis")
    (org-adapt-indentation nil)
    (org-special-ctrl-a/e nil)
    (org-M-RET-may-split-line '((default . nil)))
    (org-hide-emphasis-markers nil)
    (org-hide-macro-markers nil)
    (org-hide-leading-stars nil)
    (org-agenda-start-with-log-mode t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-agenda-window-setup 'current-window "Have org-agenda pop up in the current window")
    :config
    (load-library "find-lisp")
    ;; (setq org-agenda-files (find-lisp-find-files "~/dox/agenda" "\.org$"))
    (setq org-agenda-time-grid '((daily today require-timed)
                                 (400 600 800 1000 1200 1400 1600 1800 2000 2200)
                                 "......" "----------------"))
    (setq org-format-latex-options '(:foreground "#e5e9e9" :scale 1.0)))
    ;; (cur/org-font-setup))
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; ===Org Bullets===
  (use-package org-bullets
    ;:ensure t
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("" "●" "○" "●" "○" "●" "○" "●" "○")))
  ;;  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

#+begin_src emacs-lisp
  ;; ===Org Tempo and SRC Blocks===
  (use-package org-tempo
    :after org
    :config
    (push '("conf-unix" . conf-unix) org-src-lang-modes)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("tex" . "src latex"))
    (add-to-list 'org-structure-template-alist '("conf" . "src conf-unix"))
    (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
    (add-to-list 'org-structure-template-alist '("java" . "src java"))
    (add-to-list 'org-structure-template-alist '("elv" . "src elvish")))
#+end_src

#+begin_src emacs-lisp
  ;; ===Org Babel===
  (use-package ob
    :after org)
  ;; TODO: fix this so I can still auto tangle on saving
    ;; :init
    ;; (defun cur/org-babel-tangle-config ()
    ;;   (when (string-equal (file-name-directory (buffer-file-name))
    ;;                       (expand-file-name user-emacs-directory))
    ;;     ;; Dynamic scoping to the rescue
    ;;     (let ((org-confirm-babel-evaluate nil))
    ;;       (org-babel-tangle))))
    ;; 
    ;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'cur/org-babel-tangle-config))))

  (provide 'cur-config-org)
#+end_src

** Configurations for Gemini and the smolnet (=cur-config-smol-net.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-smol-net.el
:END:

#+begin_src emacs-lisp
  ;; ===Gemini-Mode===
  (use-package gemini-mode)

  ;; ===Org Gemini Exporter==
  (use-package ox-gemini)

  ;; ===Elpher Gemini/Gopher Client===
  (use-package elpher
    :custom
    (elpher-default-url-type "gemini"))

  (provide 'cur-config-smol-net)
#+end_src

** Elcord and making myself look productive to my friends (=cur-config-elcord.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-elcord.el
:END:

#+begin_src emacs-lisp
  (use-package elcord)

  (provide 'cur-config-elcord)
#+end_src

** Direnv integration (=cur-config-direnv.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-direnv.el
:END:

#+begin_src emacs-lisp
  ;; ===Envrc===
  (use-package envrc
    :config
    (envrc-global-mode))

  (provide 'cur-config-direnv)
#+end_src

* Custom Library Modules

** Custom modeline (=cur-modline.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-modeline.el
:END:

#+begin_src emacs-lisp
  ;;; cur/modeline.el --- My custom modeline -*- lexical-binding: t -*-

  ;;; Commentary:
  ;;
  ;; This is my custom modeline.  This is here bascially because I don't want to
  ;; use doom modeline.

  ;;; Code:
  (defgroup cur-modeline nil
    "My custom modeline that tries to be minimal."
    :group 'mode-line)
  
  (defgroup cur-modeline-faces nil
    "The faces for my custom modeline."
    :group 'cur-modeline)

  (defun cur-mode-line/padding ()
    "Function to return padding so `mode-line-end-spaces' will be right aligned."
    (let ((r-length (length (format-mode-line mode-line-end-spaces))))
      (propertize " "
                  'display `(space :align-to (- right ,r-length)))))

  (setq-default mode-line-format
                '("%e"
                  (:eval
                   (when (and (mode-line-window-selected-p) defining-kbd-macro)
                     (propertize "  KMACRO  " 'face 'font-lock-string-face)))
                  (:eval
                   (when (and (mode-line-window-selected-p)
                              (buffer-narrowed-p)
                              (not (derived-mode-p 'Info-mode 'help-mode 'special-mode 'message-mode)))
                     (propertize "  NARROWED  " 'face 'font-lock-constant-face)))
                  (:eval
                   (when (and (member 'meow features) (mode-line-window-selected-p))
                     (propertize (format "  %s  " (upcase (symbol-name meow--current-state)))
                                 'face 'highlight)))
                  "  "
                  (:eval
                   (when (mode-line-window-selected-p)
                     (cond (buffer-read-only
                            (propertize "RO" 'face 'shadow))
                           ((buffer-modified-p)
                            (propertize "**" 'face 'shadow))
                           (t
                            (propertize "RW" 'face 'shadow)))))
                  "  "
                  (:eval
                   (propertize (format "%s" (buffer-name)) 'face 'bold))
                  "  "
                  (:eval
                   (if (mode-line-window-selected-p)
                     (propertize (capitalize (symbol-name major-mode)) 'face 'warning)
                     (propertize (capitalize (symbol-name major-mode)) 'face 'shadow)))
                  (:eval (cur-mode-line/padding))))

  (provide 'cur-modeline)
  ;;; cur-modeline.el ends here
#+end_src

** More Intuitive Isearch (=cur-isearch-meow.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-isearch-meow.el
:END:

This is my hacked together way of making ~isearch~ more "modal". I don't really like having to use a bunch of modifier keys just to search through text, but I really like the over all way that ~isearch~ is designed. In particular I like how well it works with keyboard macros and how well integrated it is with other emacs tool like ~occur~.

Really, this is just some wrapper functions to cancel ~isearch~ and run various meow functions and a hydra for the transient key bindings. I plan on doing more optimizations and better integrating isearch into meow but for now the somewhat hacky solution will have to do.

Just as a note to self, the command ~defhydra+~ can be use to override the hydra's keybindings.

#+begin_src emacs-lisp
  (require 'isearch)
  (require 'hydra)

  (defgroup isearch-meow nil
    "Setting for making isearch work better with meow."
    :group 'isearch)

  (defun isearch-meow-wrapper (&optional arg)
    (interactive (list 1))
    (progn
      (when (region-active-p)
        (call-interactively #'meow-cancel-selection))
      (cond ((< arg 1)
             (call-interactively #'isearch-backward))
            (t
             (call-interactively #'isearch-forward)))))

  (defun isearch-meow-exit-next-line()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-next)))

  (defun isearch-meow-exit-prev-line()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-prev)))

  (defun isearch-meow-exit-left()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-left)))

  (defun isearch-meow-exit-right()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-right)))

  (defun isearch-meow-exit-back-to-indentation()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-join)))

  (defun isearch-meow-exit-end-of-line()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-line)))

  (defun isearch-meow-exit-next-word()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-next-word)))

  (defun isearch-meow-exit-back-word()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-back-word)))

  (defun isearch-meow-insert ()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-insert)))

  (defun isearch-meow-append ()
    (interactive)
    (progn
      (call-interactively #'isearch-exit)
      (call-interactively #'meow-append)))

  (defhydra isearch-meow-hydra (:hint nil)
    ""
    ("`"   ignore)
    ("~"   ignore)
    ("1"   ignore)
    ("!"   ignore)
    ("2"   ignore)
    ("@"   ignore)
    ("3"   ignore)
    ("#"   ignore)
    ("4"   ignore)
    ("$"   ignore)
    ("5"   ignore)
    ("%"   ignore)
    ("6"   ignore)
    ("^"   ignore)
    ("7"   ignore)
    ("&"   ignore)
    ("8"   ignore)
    ("*"   ignore)
    ("9"   ignore)
    ("("   ignore)
    ("0"   ignore)
    (")"   ignore)
    ("a"   isearch-meow-append)
    ("A"   ignore)
    ("b"   isearch-meow-exit-back-word :exit t)
    ("B"   ignore)
    ("c"   isearch-query-replace-regexp)
    ("C"   ignore)
    ("d"   ignore)
    ("D"   ignore)
    ("e"   isearch-meow-exit-next-word :exit t)
    ("E"   ignore)
    ("f"   ignore)
    ("F"   ignore)
    ("g"   ignore)
    ("G"   ignore)
    ("l"   isearch-meow-exit-left)
    ("H"   ignore)
    ("i"   isearch-meow-insert)
    ("I"   ignore)
    ("j"   isearch-meow-exit-next-line :exit t)
    ("J"   ignore)
    ("k"   isearch-meow-exit-prev-line :exit t)
    ("K"   ignore)
    ("l"   isearch-meow-exit-right)
    ("L"   ignore)
    ("m"   isearch-meow-exit-back-to-indentation :exit t)
    ("M"   ignore)
    ("n"   isearch-repeat-forward)
    ("N"   ignore)
    ("o"   isearch-occur)
    ("O"   ignore)
    ("p"   isearch-repeat-backward)
    ("P"   ignore)
    ("q"   ignore)
    ("Q"   ignore)
    ("r"   isearch-query-replace-regexp)
    ("R"   ignore)
    ("s"   ignore)
    ("S"   ignore)
    ("t"   ignore)
    ("T"   ignore)
    ("u"   ignore)
    ("U"   ignore)
    ("v"   ignore)
    ("V"   ignore)
    ("w"   ignore)
    ("W"   ignore)
    ("x"   isearch-meow-exit-end-of-line :exit t)
    ("X"   ignore)
    ("y"   ignore)
    ("Y"   ignore)
    ("z"   ignore)
    ("Z"   ignore)
    ("-"   ignore)
    ("_"   ignore)
    ("="   ignore)
    ("+"   ignore)
    ("["   ignore)
    ("{"   ignore)
    ("]"   ignore)
    ("}"   ignore)
    ("\\"  ignore)
    ("|"   ignore)
    (";"   ignore)
    (":"   ignore)
    ("'"   ignore)
    ("\""  ignore)
    (","   ignore)
    ("<"   ignore)
    ("."   ignore)
    (">"   ignore)
    ("/"   nil :exit t)
    ("?"   ignore)
    ("RET" isearch-exit :exit t)
    ("<return>" isearch-exit :exit t)
    ("ESC" isearch-exit :exit t)
    ("<escape>" isearch-exit :exit t)
    ("SPC" ignore))

  (define-key isearch-mode-map (kbd "RET") 'isearch-meow-hydra/body)
  (define-key isearch-mode-map (kbd "<return>") 'isearch-meow-hydra/body)

  (provide 'cur-isearch-meow)
#+end_src
