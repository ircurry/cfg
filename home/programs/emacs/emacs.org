#+title: Emacs Configuration
#+author: icurry
#+language: en
#+options: toc:2 num:t author:t

* Introduction and Overview

Obligatory Frieren Ascii art.

#+begin_example text
            Frieren
⠀⠀⠀⠀⠀⠀⢀⡴⢾⣶⣴⠚⣫⠏⠉⠉⠛⠛⢭⡓⢶⣶⠶⣦⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣰⠋⡀⣠⠟⢁⣾⠇⠀⣀⣷⠀⠀⠓⣝⠂⠙⣆⢄⢻⡞⢢⠀⠀⠀
⠀⠀⠀⠀⢠⡇⢸⢡⠃⢠⡞⠁⠀⣰⡟⠉⢦⣄⠀⠈⢆⠀⢻⣾⡄⢧⢸⠀⠀⠀
⠀⠀⠀⠀⢸⠀⡇⡌⠀⡞⠀⢀⣴⡋⠀⠀⠀⣙⣷⡀⠘⡄⠘⣿⣧⢸⣼⣥⠀⠀
⣀⣀⣀⣀⣞⣰⠁⡇⠀⣧⠴⠛⠛⠁⠀⠀⠀⠉⠉⠙⠦⡇⠀⣿⣸⣼⣿⣇⣀⣀
⠳⢽⣷⠺⡟⡿⣯⡇⠰⣧⠠⣿⡷⠂⠀⠀⠀⠐⣾⠷⠀⡀⠀⣿⡟⣴⠶⢁⡨⠊
⠀⠀⠉⢳⢦⣅⠘⣿⣄⢿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⢀⣏⣳⣿⣴⡞⠈⠀
⠀⠀⠀⣼⢸⡅⢹⣿⣿⣾⣟⠀⠀⢠⣀⣄⣠⠀⠀⢠⣾⣿⡿⣿⢻⠁⢹⣷⡀⠀
⠀⠀⠸⡏⠸⡇⢼⣿⡿⠟⠛⠓⣦⣄⣀⣀⣀⣀⡤⠴⠿⢿⡟⠛⠺⣦⣬⣗⠀⠀
⠀⠀⢰⡇⠀⡇⠸⡏⠀⠀⢰⠋⠙⠛⠛⠉⠉⢹⠀⠀⠀⠀⡇⠀⠀⣿⣿⣿⣿⡇
⠀⡐⣾⠀⡀⢹⠀⣿⣄⠀⢸⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢠⣇⠀⠀⣿⣿⣿⣿⣿
⣰⣿⣿⠀⡇⠘⡄⢸⣿⠆⠈⡇⠀⠀⠀⠀⠈⢉⠃⠀⣰⡾⠻⠃⢰⣿⣿⣿⣿⡇
⣿⣿⣿⡆⢷⠀⢧⠈⣿⠤⠤⣇⠀⠀⠀⠀⢀⣸⣠⢾⠟⠓⡶⢤⣾⣿⣿⣿⣿⣷
#+end_example

* Initialization of Emacs (=init.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./init.el
:END:

** Emacs Version Check

I do not test this config on any emacs version less than 29.4.

#+begin_src emacs-lisp
;; ===Check Emacs Version===
(when (version< emacs-version "29.4")
  (error "This setup is only guarunteed to work on 29.4, disable this line to load anyways."))
#+end_src

** Some Basic Settings

These are some basic settings that don't really fit anywhere else in my config.

#+begin_src emacs-lisp
;; ===Basic Settings===
(setq frame-title-format "%b")      ; Set window title to buffer name
(setq initial-scratch-message ";; Scratch Buffer\n\n")
(setq initial-buffer-choice t)      ; Scratch as initial buffer
(setq make-backup-files nil)        ; No more file~ everywhere
(setq inhibit-startup-message t)    ; Starts on blank screen
(setq scroll-conservatively 101)    ; Enable Line by line scrolling
(setq use-dialog-box nil)           ; No yes-no-p for mouse clicks
(setq use-short-answers t)          ; Use y-or-n-p for yes-no dialogue.
(scroll-bar-mode -1)                ; Disable visible scrollbar
(tool-bar-mode -1)                  ; Disable tool bar
(menu-bar-mode -1)                  ; Disable menu bar
(tooltip-mode -1)                   ; Disable tooltips
(set-fringe-mode 10)                ; No idea what this does
#+end_src

** Enabling Disabled Functions

These functions I want enabled and not asking me if I want to run the command every single time.

#+begin_src emacs-lisp
;; ===Enable Disabled Functions===
(dolist (c '(narrow-to-region narrow-to-page upcase-region downcase-region))
  (put c 'disabled nil))
#+end_src

** "Disabling" Custom

Set ~custom-file~ to a temp file so I don't have to deal with custom, lol. This is a tip I learned from [[https://protesilaos.com/emacs/dotemacs#h:f2ffe0e9-a58d-4bba-9831-cc35940ea83f][Protesilaos' config]].

#+begin_src emacs-lisp
;; ===Disable Custom===
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Package.el and Package Archives

This is only used if I find myself on a non-nixos system, as I have nixos manage my emacs packages instead.

#+begin_src emacs-lisp
;; ===Package Initialization===
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("elpa" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/"))) ;; Setting Repos
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

** Use-package

Requiring ~use-package~ as that is what I use for almost all of my configuration.

#+begin_src emacs-lisp
;; ===use-package Initialization===
(require 'use-package)
#+end_src

** Configuration modules.

First, I add the =cur-lisp= and =cur-config= to the ~load-path~. Then its just as simple as ~(require 'module)~.

#+begin_src emacs-lisp
;; ===Load Modules and Packages===
(dolist (path '("cur-lisp" "cur-config"))
  (add-to-list 'load-path (locate-user-emacs-file path)))

;; =====================
;; == Loading Modules ==
;; =====================

;; ===Essentials===
(require 'cur-config-essentials)
(require 'cur-config-bindings)
(require 'cur-config-help)
(require 'cur-config-dired)

;; ===Interfaces===
(require 'cur-config-faces)
(require 'cur-config-completion)
(require 'cur-config-window)

;; ===Languages===
(require 'cur-config-ide)
(require 'cur-config-lisp)
(require 'cur-config-java)
(require 'cur-config-just)
(require 'cur-config-markup)
(require 'cur-config-nix)
(require 'cur-config-rust)
(require 'cur-config-haskell)
(require 'cur-config-ocaml)
(require 'cur-config-c)
(require 'cur-config-zig)
(require 'cur-config-go)

;; ===Terminal Apps===
(require 'cur-config-shell)

;; ===Word Processing===
(require 'cur-config-org)

;; ===Misc===
(require 'cur-config-smol-net)
(require 'cur-config-elcord)

;; ===Direnv is Last===
(require 'cur-config-direnv)

(provide 'init)
#+end_src

* Configuration Modules (=cur-config=)

** Essential configuration (=cur-config-essentials.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-essentials.el
:END:

These are the basic configurations that I have done in emacs. Its sort of a hodge-podge of fixing/changing things that are built emacs. They aren't strictly essential so the name is kind of a misnomer.

*** Parentheses highlighting

Removing the weird delay for highlighting the opposite parenthesis.

#+begin_src emacs-lisp
;; ===Parens===
(use-package paren
  :ensure nil
  :demand t
  :custom
  (show-paren-delay 0 "No delay for paren highlighting"))
#+end_src

*** Line numbers

I like having absolute line numbers, especially since the meow number selection makes relative line numbers not as useful. Some modes, especially terminal and shell modes, look weird with line numbers so I disable them. Org-mode also has them disabled because they make the document look kind of weird, especially with images or non-text.

#+begin_src emacs-lisp
;; ===Line Numbers===
(use-package emacs
  :custom
  (display-line-numbers-type t)
  :config
  (column-number-mode 1)
  (global-display-line-numbers-mode 1)
  ;; Disable line numbers for terminal modes
  (dolist (mode '(bookmark-bmenu-mode-hook
                  org-mode-hook
                  dired-mode-hook
                  term-mode-hook
                  vterm-mode-hook
                  shell-mode-hook
                  eshell-mode-hook
                  eat-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode -1)))))

#+end_src

*** Bookmark Settings

#+begin_src emacs-lisp
(use-package bookmark
  :commands (bookmark-set
             bookmark-set-no-overwrite
             bookmark-jump
             bookmark-bmenu-list)
  :hook (bookmark-bmenu-mode . hl-line-mode)
  :config
  (setq bookmark-save-flag 1))
#+end_src

*** Recent Files

#+begin_src emacs-lisp
(use-package recentf
  :hook (emacs-startup . recentf-mode))
#+end_src

*** Isearch configuration

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :demand t
  :custom
  (isearch-wrap-pause 'no-ding)
  (isearch-repeat-on-direction-change t)
  :config
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format "(%s/%s) ")
  (setq lazy-count-suffix-format nil))
#+end_src

*** Proced

#+begin_src emacs-lisp
(use-package proced
  :ensure nil
  :commands (proced)
  :custom
  (proced-auto-update-flag t)
  (proced-enable-color-flag t)
  (proced-auto-update-interval 2)
  (proced-descend t)
  (proced-filter 'user))
#+end_src

*** Emacs Server

#+begin_src emacs-lisp
(use-package server
  :defer 1
  :config
  (setq server-client-instructions nil)
  (unless (server-running-p)
    (server-start)))

(provide 'cur-config-essentials)
#+end_src

** Key bindings configurations (=cur-config-bindings.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-bindings.el
:END:

I use [[https:github.com/meow-edit/meow][meow]], a modal editing layer designed to be integrate well into emacs. It's very easy to hack on and extend and just feels more emacsy. I have had almost no issues with this, compared to evil which just felt sluggish and was hard to customize. The object-verb syntax is also really great and I prefer it to the verb-object of vim/nvim.

*** Repeat mode

One of the most basic ways to make using Emacs keybindings a breeze.

#+begin_src emacs-lisp
;; ===Repeat Mode===
(use-package emacs
  :demand t
  :config
  (repeat-mode 1))
#+end_src

*** Hydra 

I use hydras for repeat keybindings. I plan to switch to use the built in repeat keymap more in the future but they are very helpful for creating something almost like a mini meow state, just for one particular task.

#+begin_src text :tangle ./packages.txt :padline no
hydra
#+end_src

#+begin_src emacs-lisp
;; ===Hydra===
(use-package hydra
  :demand t)
#+end_src

*** Avy

#+begin_src text :tangle ./packages.txt :padline no
avy
#+end_src

#+begin_src emacs-lisp
(use-package avy
  :bind ( :map goto-map
	  ("c" . avy-goto-char-2)))
#+end_src

*** Meow

This is the meat and potatoes of my keybindings. First I have several keymaps: sub-leader, projectile, toggle, and alignment. Sub leader is for more miscellaneous one-off commands, such as ~ibuffer~. Projectile is for, you guessed it, projectile related commands. Toggle is for quick, on the fly, changing of settings, such as the font size. The alignment is currently unused as of now but will have commands to change how text is currently being viewed without actually modifying the text of the buffer, think ~recenter-top-bottom~ like commands and more.

I try to keep the leader key map as static as possible, with no keybindings being changed with the mode. If I want something to change with the mode I will put it under C-c, which I can access from =RET= via normal mode. The leader key primarily has things for interacting with general emacs constructs, like buffers, universal arg, =M-x=, etc.

The meow states, what vim/nvim call modes, are as follows:
- *Normal* - The main state that is used. Used for navigation, selection, and editing. Basically vim's normal and visual mode in one.
- *Insert* - Insert text, esc to go back to normal state.
- *Motion* - A minimal state used when you don't know what the major-mode does. I have only =j=, =k=, and =SPC= bound to down, up, and leader respectively. Everything else is as the major mode defines it. It's just there so I'm still able to interface with emacs like I normally would, just with a minimal interface.
- *Keypad* - Leader key map.
- *Beacon* - Multi-cursor in a region. Very convenient but kmacros are GOATed.

Also of note, I find it easier to think about the cursor in normal mode as being a single character selection. This is how helix does it and I really like it so I have a lot of the meow fallback commands to operate on the char after the cursor.

A cheatsheet for the normal state can be accessed via =M-x meow-cheatsheet RET=.

Currently Meow is broken in the emacsoverlay so I am including the package from mepla stable instead.

#+begin_src text :tangle ./packages.txt :padline no
meow
#+end_src

#+begin_src emacs-lisp
;; ===Meow Setup===
(use-package meow
  :after (hydra)
  :demand t
  :preface
  (defvar cur/sub-leader-keymap
    (let ((map (make-sparse-keymap)))
      map)
    "The keymap for quick command/function execution.")
  (defvar cur/toggle-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for commands that change settings from the leader key.")
  (defvar cur/alignment-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for commands that change alignment and cursor display.")
  (defvar cur/register-map
    (let ((map (make-sparse-keymap)))
      map)
    "Keymap for commands that use registers.")
  (defun cur/shell-filter-active-region ()
    (interactive)
    (if (region-active-p)
        (shell-command-on-region (region-beginning) (region-end)
                                 (read-shell-command "Filter Region with: ")
                                 1 1)
      (user-error "The region is not currently active")))
  (defhydra cur/window (:hint nil)
    "
^Movement^            ^Splitting and Balancing^   ^Manipulation^       ^Resizing^
^--------^------------^-----------------------^---^------------^-------^--------^---------------------
_h_: left             _._: only window            _H_: swap left       _i_: enlarge window
_j_: down             _v_: split vertical         _J_: swap down       _r_: shrink window
_k_: up               _s_: split horizontal       _K_: swap up         _f_: enlarge window horizonally
_l_: right            _=_: balance windows        _L_: swap right      _b_: shrink window horizonally
_o_: other window     _F_: fit to buffer          _d_: close window
"
    ("RET" ignore "finished" :exit t)

    ("o" other-window)
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)

    ("." delete-other-windows)
    ("v" split-window-right)
    ("s" split-window-below)
    ("=" balance-windows)
    ("F" fit-window-to-buffer)

    ("H" windmove-swap-states-left)
    ("J" windmove-swap-states-down)
    ("K" windmove-swap-states-up)
    ("L" windmove-swap-states-right)
    ("d" delete-window)

    ("i" enlarge-window)
    ("r" shrink-window)
    ("f" enlarge-window-horizontally)
    ("b" shrink-window-horizontally))
  (defun cur/reverse-other-window ()
    (interactive)
    (other-window -1))
  (defun meow-setup ()
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; ===Top Row===
     ;; '("1" . )
     ;; '("2" . )
     ;; '("3" . )
     ;; '("4" . )
     ;; '("5" . )
     ;; '("6" . )
     ;; '("7" . )
     ;; '("8" . )
     ;; '("9" . )
     ;; '("0" . )

     ;; ===2nd Row===
     ;; '("TAB"  . )
     '("q" . meow-comment) ; comment dwim
     ;; '("w" . ) ; bound in ace-window section
     '("W" . cur/window/body)
     ;; '("e" . )
     (cons "r" cur/register-map)
     (cons "t" cur/toggle-map)
     ;; '("y" . )
     '("u" . "C-u")   ; universal argument
     ;; '("i" . )
     '("o" . other-window) ; other window
     (cons "p" project-prefix-map)
     ;; '("-" . )

     ;; ===3rd Row===
     ;; '("<escape>" . )
     ;; '("a" . )
     '("s" . "C-x C-s") ; save buffer
     '("d" . kill-current-buffer)
     '("f" . "C-x C-f") ; find file
     ;; '("g" . ) ; C-M- map
     ;; '("h" . ) ; C-h map
     ;; '("j" . )
     ;; '("k" . )
     ;; '("l" . )
     (cons ";" cur/sub-leader-keymap)
     '("RET"   . "M-x")

     ;; ===4th Row===
     (cons "z" cur/alignment-map)
     ;; '("x" . ) ; C-x map
     ;; '("c" . ) ; C-c map
     '("C" . capitalize-dwim)
     ;; '("v" . )
     '("b" . "C-x b")
     ;; '("n" . )
     ;; '("m" . ) ; M- map
     '("," . meow-beginning-of-thing)
     '("." . meow-end-of-thing)
     '("/" . rg)
     ;; '("'"  . )
     )
    (meow-normal-define-key
     ;; ===Special===
     '("|" . cur/shell-filter-active-region)

     ;; ===Top Row===
     '("1" . meow-expand-1)
     ;; '("!" . )
     '("2" . meow-expand-2)
     ;; '("@" . )
     '("3" . meow-expand-3)
     ;; '("#" . )
     '("4" . meow-expand-4)
     ;; '("$" . )
     '("5" . meow-expand-5)
     '("%" . meow-query-replace)
     '("6" . meow-expand-6)
     ;; '("^" . )
     '("7" . meow-expand-7)
     ;; '("&" . )
     '("8" . meow-expand-8)
     ;; '("*" . )
     '("9" . meow-expand-9)
     '("(" . meow-start-kmacro)
     '("0" . meow-expand-0)
     '(")" . meow-end-kmacro)

     ;; ===2nd Row===
     ;; '("TAB"  . )
     ;; '("BTAB" . )
     ;; '("q" . )
     '("Q" . kmacro-end-and-call-macro)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("t" . meow-till)
     '("T" . meow-till-expand)
     '("y" . meow-save)
     '("Y" . meow-clipboard-save)
     '("u" . meow-undo)
     ;; '("U" . )
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("P" . meow-yank-pop)
     '("-" . negative-argument)
     ;; '("_" . )

     ;; ===3rd Row===
     '("<escape>" . keyboard-quit)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("s" . repeat)
     ;; '("S" . )
     '("d" . meow-kill)
     '("D" . meow-c-k)
     '("f" . meow-find)
     '("F" . meow-find-expand)
     '("g" . meow-cancel-selection)
     ;; '("G" . )
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '(";" . meow-reverse)
     '(":" . meow-page-up)
     '("RET" . "C-c")
     ;; '("S-RET" . )

     ;; ===4th Row===
     '("z" . meow-pop-selection)
     ;; '("Z" . )
     '("x" . meow-line)
     '("X" . meow-line-expand)
     '("c" . meow-change)
     '("C" . meow-sync-grab)
     (cons "v" goto-map)
     ;; '("V" . )
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("n" . meow-search)
     '("N" . meow-visit)
     '("m" . meow-join)
     ;; '("M" . )
     '("," . meow-bounds-of-thing)
     '("<" . beginning-of-buffer)
     '("." . meow-inner-of-thing)
     '(">" . end-of-buffer)
     ;; '("/" . ) ; I bind this later to `consult-line'
     '("?" . meow-page-down)
     '("'" . meow-grab)
     '("\"" . meow-pop-grab)))
  :init
  (defhydra cur/hydra-buffer-cycle (:timeout 4)
    "tab through buffers"
    ("n" next-buffer "next buffer")
    ("p" previous-buffer "previous buffer")
    ("f" nil "finished" :exit t)
    ("RET" nil "finished" :exit t))
  :custom
  (meow-mode-state-list
   '((authinfo-mode . normal)
     (beancount-mode . normal)
     (bibtex-mode . normal)
     (cider-repl-mode . normal)
     (cider-test-report-mode . normal)
     (cider-browse-spec-view-mode . motion)
     (cargo-process-mode . normal)
     (conf-mode . normal)
     (deadgrep-edit-mode . normal)
     (deft-mode . normal)
     (diff-mode . normal)
     (dired-mode . motion)
     (eat-mode . insert)
     (ediff-mode . motion)
     (eshell-mode . insert)
     (gud-mode . normal)
     (haskell-interactive-mode . normal)
     (help-mode . motion)
     (helpful-mode . normal)
     (json-mode . normal)
     (jupyter-repl-mode . normal)
     (mix-mode . normal)
     (occur-edit-mode . normal)
     (pass-view-mode . normal)
     (prog-mode . normal)
     (py-shell-mode . normal)
     (restclient-mode . normal)
     (telega-chat-mode . normal)
     (term-mode . normal)
     (text-mode . normal)
     (vterm-mode . insert)
     (Custom-mode . normal))
   "Default meow states for modes")
  (meow-selection-command-fallback
   '((meow-change . meow-change-char)
     (meow-kill . meow-C-d)
     (meow-cancel-selection . keyboard-quit)
     (meow-pop-selection . meow-pop-grab)
     (meow-beacon-change . meow-beacon-change-char))
   "Meow fallback commands")
  (meow-keypad-describe-delay 0.0 "No delay in keypad help popup")
  (meow-cheats-layout meow-cheatsheet-layout-qwerty "Meow qwerty layout for the cheatsheet")
  (meow-keypad-leader-dispatch nil)
  (meow-visit-sanitize-completion nil)
  :bind ( :map cur/sub-leader-keymap
          ("C-l" . ibuffer)
          ("C-b" . bookmark-set-no-overwrite)
          :map cur/register-map
          ("C-j" . jump-to-register)
          ("C-." . point-to-register)
          ("C-y" . copy-to-register)
          ("C-p" . insert-register)
          ("C-w" . window-configuration-to-register)
          ("C-n" . number-to-register)
          ("C-+" . increment-register)
          ("C-q" . kmacro-to-register)
          :map goto-map
          ("e a" . first-error)
          ("e n" . next-error)
          ("e p" . previous-error)
          (","   . xref-go-back)
          ("d"   . xref-find-definitions)
          ("r"   . xref-find-references)
          ("A"   . xref-find-apropos)
          ("h"   . move-beginning-of-line)
          ("j"   . end-of-buffer)
          ("k"   . beginning-of-buffer)
          ("l"   . move-end-of-line)
          ("J"   . next-logical-line)
          ("K"   . previous-logical-line)
          ("s"   . back-to-indentation)
          :map search-map
          ("n" . meow-visit)
          ("s" . isearch-forward)
          ("r" . isearch-backward))
  :config
  (meow-setup)
  (meow-global-mode 1))

(use-package meow
  :if (locate-library "ace-window.el")
  :config
  (meow-leader-define-key
   '("w" . ace-window)))

(use-package cur-meow
  :after (meow)
  :bind ( :map cur/sub-leader-keymap
          ("C-n" . cur-meow-toggle-temp-normal-motion)))
#+end_src

*** Meow Tree Sitter

#+begin_src text :tangle ./packages.txt :padline no
meow-tree-sitter
#+end_src

#+begin_src emacs-lisp
(use-package meow-tree-sitter
  :after meow
  :config
  (meow-tree-sitter-register-defaults))

(provide 'cur-config-bindings)
#+end_src

** Help configurations (=cur-config-help.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-help.el
:END:

Enhancing the help mechanisms in emacs.

*** Which-key

Which-key shows you what keybindings are available in a keychord. Super helpful and a must have in emacs.

#+begin_src text :tangle ./packages.txt :padline no
which-key
#+end_src

#+begin_src emacs-lisp
;; ===which-key===
(use-package which-key
  :demand t
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.0001))
#+end_src

*** Info

Info is emacs' built in manual system. In essence, its a more feature rich =man= (which emacs also has easy access to with =woman=). Right now I have a custom meow state for keybindings. However, this kind of sucks and I will eventually switch to just changing the default keybindings.

#+begin_src emacs-lisp
;; ===Info===
(use-package info
  :config
  (setq meow-info-keymap (make-keymap))
  (meow-define-state info
    "meow state for interacting with Info"
    :lighter "INFO"
    :keymap meow-info-keymap)
  (meow-define-keys 'info
    '(":" . meow-page-up)
    '("?" . meow-page-down)
    '("," . beginning-of-buffer)
    '("." . end-of-buffer)
    ;;  '("a" . )
    ;;  '("b" . )
    ;;  '("c" . Info-follow-reference)
    ;;  '("d" . )
    ;;  '("e" . )
    '("f" . Info-menu)
    '("g" . keyboard-quit)
    '("h" . Info-backward-node)
    '("H" . meow-left)
    '("i" . Info-index)
    '("j" . meow-next)
    '("k" . meow-prev)
    '("l" . Info-forward-node)
    '("L" . meow-right)
    '("m" . meow-join)
    '("n" . Info-next)
    ;;  '("o" . )
    '("p" . Info-prev)
    '("q" . meow-goto-line)
    '("r" . Info-follow-reference)
    ;;  '("s" . )
    '("t" . Info-toc)
    '("u" . Info-up)
    '("v" . meow-visit)
    ;;  '("w" . )
    ;;  '("x" . )
    '("y" . Info-copy-current-node-name)
    '("z" . info-display-manual)
    '("RET" . Info-follow-nearest-node)
    '("SPC" . meow-keypad)
    '("TAB" . Info-next-reference)
    '("<backtab>" . Info-prev-reference)
    '("<escape>" . keyboard-quit))
  (add-hook 'Info-mode-hook #'meow-info-mode))

(provide 'cur-config-help)
#+end_src

** Dired configuration (=cur-config-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-dired.el
:END:

Dired is the built in file manager in emacs. Its very capable and very hackable although it lacks good file previewing solutions

*** Nerd Icons Dired

Adds icons to make dired a bit more pretty and gives a visual sense of what files are what. 

#+begin_src text :tangle ./packages.txt :padline no
nerd-icons-dired
#+end_src

#+begin_src emacs-lisp
;; ===Dired Icons===
(use-package nerd-icons-dired
  :after (dired)
  :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** Main Dired Configuration

By default, I want dired to look very minimal. This lack of clutter makes it easier to focus on what I am doing in the file manager. This is also the approach I try to take with other parts of emacs as well. By default, I have file details (owner, permissions, last modified, etc.) hidden. I have other changes as well, use the system trash can instead of deleting, that are under the ~:config~ part of the ~use-package~ declaration.

The keybindings are a hybrid of my normal state and the default dired keybindings.

#+begin_src emacs-lisp
;; ===Dired===
(use-package dired
  :ensure nil
  :hook
  (dired-mode . dired-hide-details-mode) ; don't show file details by default
  (dired-mode . hl-line-mode) ; Highlight the line the cursor is on
  ;; TODO: create a dired-find-file-dwim for external programs
  :bind ( :map dired-mode-map
          ;; ===Top Row===
          ;; ("1" . )
          ("!" . dired-do-shell-command)
          ;; ("2" . )
          ;; ("@" . )
          ;; ("3" . )
          ;; ("#" . )
          ;; ("4" . )
          ;; ("$" . )
          ;; ("5" . )
          ;; ("%" . )
          ;; ("6" . )
          ;; ("^" . )
          ;; ("7" . )
          ("&" . dired-do-async-shell-command)
          ;; ("8" . )
          ;; ("*" . )
          ;; ("9" . )
          ;; ("(" . )
          ;; ("0" . )
          ;; (")" . )

          ;; ===2nd Row===
          ("TAB"  . dired-hide-subdir)
          ("<backtab>" . dired-hide-all)
          ("q" . quit-window)
          ;; ("Q" . )
          ("w" . dired-mark-subdir-files)
          ;; ("W" . ) ; Bound it custom wallpaper settings
          ("e" . dired-next-subdir)
          ;; ("E" . )
          ("r" . dired-do-rename)
          ("R" . dired-do-rename-regexp)
          ("t" . dired-toggle-marks)
          ("T" . dired-kill-tree)
          ("y" . dired-copy-filename-as-kill)
          ;; ("Y" . )
          ("u" . dired-unmark)
          ("U" . dired-unmark-all-marks)
          ("i" . dired-toggle-read-only)
          ("I" . image-dired)
          ("o" . dired-do-async-shell-command)
          ("O" . dired-do-chown)
          ("p" . dired-next-marked-file)
          ;; ("P" . )
          ("-" . negative-argument)
          ;; ("_" . )

          ;; ===3rd Row===
          ("<escape>" . keyboard-quit)
          ("a" . dired-find-alternate-file)
          ;; ("A" . dired-find-alternate-file)
          ("s" . dired-kill-subdir)
          ("S" . dired-kill-tree)
          ("d" . dired-do-kill-lines)
          ("D" . dired-do-delete)
          ("f" . dired-goto-file)
          ("F" . dired-goto-subdir)
          ("g" . revert-buffer)
          ;; ("G" . )
          ("h" . dired-up-directory)
          ;; ("H" . )
          ;; ("j" . ) ; already bound in meow-motion-mode
          ;; ("J" . )
          ;; ("k" . ) ; already bound in meow-motion-mode
          ;; ("K" . )
          ;; ("l" . ) ; bound in cur-dired declaration
          ("L" . dired-find-file-other-window)
          (";" . dired-toggle-marks)
          (":" . scroll-down-command)
          ("RET" . dired-find-file)
          ("S-RET" . dired-find-file-other-window)

          ;; ===4th Row===
          ("z" . dired-undo)
          ;; ("Z" . )
          ("x" . dired-mark)
          ("X" . dired-mark-files-regexp)
          ("c" . dired-do-copy)
          ("C" . dired-do-copy-regexp)
          ("v" . dired-view-file)
          ;; ("V" . )
          ("b" . dired-prev-subdir)
          ;; ("B" . )
          ("n" . dired-next-marked-file)
          ;; ("N" . )
          ;; ("m" . )
          ("M" . dired-do-chmod)
          ("," . dired-prev-dirline)
          ("<" . beginning-of-buffer)
          ("." . dired-next-dirline)
          (">" . end-of-buffer)
          ("/" . dired-sort-toggle-or-edit)
          ("?" . scroll-up-command)
          ;; ("'"  . ) ; Leave these blank, usually embark-act
          ;; ("\"" . ) ; Leave these blank, usually embark-dwim
          :map cur/sub-leader-keymap
          ("d" . dired))
  :custom
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (delete-by-moving-to-trash t)
  (dired-dwim-target t)
  (dired-listing-switches "-A -G -F -h -l -v --group-directories-first --time-style=long-iso")
  (dired-guess-shell-alist-user '(("\\.\\(png\\|jpe?g\\|tiff\\|gif\\)" "xdg-open" "imv" "feh")
                                  ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\|mov\\)" "xdg-open" "mpv" "vlc")
                                  ("\\.pdf" "xdg-open" "zathura")
                                  (".*" "xdg-open")))
  (dired-auto-revert-buffer #'dired-directory-changed-p)
  (dired-free-space nil)
  (dired-make-directory-clickable t)
  (dired-mouse-drag-files t)
  :config
  (setq dired-deletion-confirmer 'y-or-n-p)
  (setopt dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir)))))

(use-package cur-dired
  :after (dired)
  :bind ( :map dired-mode-map
	  ("l" . cur-dired-maybe-insert-subdir-or-find-file)))

(provide 'cur-config-dired)
#+end_src

*** Wallpaper

#+begin_src emacs-lisp
(use-package cur-wallpaper
  :after (dired)
  :bind ( :map dired-mode-map
	  ("W" . cur-wallpaper-set-wallpaper-dired)))

(use-package cur-wallpaper
  :after (image-dired)
  :bind ( :map image-dired-thumbnail-mode-map
	  ("W" . cur-wallpaper-set-wallpaper)))

(provide 'cur-config-dired)
#+end_src

** Faces, themes, and eye candy configurations (=cur-config-faces.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-faces.el
:END:

I think that emacs should have a lot of eye candy, especially since I spend so much time in it. These are my configurations for emacs' faces, theming and ui settings essentially.

*** Default Font and Fontaine

JetBrains Mono supremacy.

#+begin_src text :tangle ./packages.txt :padline no
fontaine
#+end_src

#+begin_src emacs-lisp
;; ===Default Font===

(use-package fontaine
  :demand t
  :bind ( :map cur/toggle-map
	  ("C-s" . fontaine-set-preset))
  :custom
  (fontaine-presets '((regular)
		      (extra-small
		       :default-height 100)
		      (small
		       :default-height 107)
		      (large
		       :default-height 140)
		      (t
		       :default-family "JetBrainsMono Nerd Font"
		       :default-weight regular
		       :default-height 110

		       :fixed-pitch-family nil
		       :fixed-pitch-weight nil
		       :fixed-pitch-height 1.0

		       :fixed-pitch-serif-family nil
		       :fixed-pitch-serif-weight nil
		       :fixed-pitch-serif-height 1.0

		       :mode-line-active-height 1.0
		       :mode-line-inactive-height 1.0)))
  :config
  (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))
  (fontaine-mode 1))
#+end_src

*** Default Opacity

I have this transparency set to be the same as with my Alacritty config. This adds more consistency to my computing experience. It also just looks really cool.

#+begin_src emacs-lisp
;; ===Default Opacity===
(add-to-list 'default-frame-alist
             '(alpha-background . 85))

(use-package emacs
  :preface
  (defun cur/toggle-frame-opacity ()
    (interactive)
    (let ((current-alpha (frame-parameter nil 'alpha-background)))
      (cond ((eq current-alpha 100)
	     (set-frame-parameter nil 'alpha-background 85))
	    (t
	     (set-frame-parameter nil 'alpha-background 100)))))
  :bind ( :map cur/toggle-map
	  ("C-o" . cur/toggle-frame-opacity)))
#+end_src

*** TODO Custom themes

I have several custom themes in a directory weirdly named themes. These are the =everforest= and =kanagawa= themes. I have changed these from the originals. TODO: add the links to the original themes.

#+begin_src emacs-lisp
;; ===Themes Path===
(add-to-list 'custom-theme-load-path (locate-user-emacs-file "themes"))

;; ===Theme Library===
(use-package cur-theme
  :bind ( :map cur/toggle-map
          ("C-t" . cur-override-theme-load-theme))
  :custom
  (cur-override-theme-overrides
   '((catppuccin (company-preview :foreground (catppuccin-color 'overlay0)
				  :background (if (eq catppuccin-flavor 'latte)
						  (catppuccin-darken (catppuccin-color 'base) 12)
						(catppuccin-lighten (catppuccin-color 'base) 17)))
		 (cur-mode-line-meow-state :background (catppuccin-color 'lavender)
					   :foreground (catppuccin-color 'base))
		 (cur-mode-line-major-mode-active :foreground (catppuccin-color 'blue) :weight 'bold)
		 (flycheck-info :underline (list :style 'wave :color (catppuccin-color 'green)))
		 (flycheck-warning :underline (list :style 'wave :color (catppuccin-color 'yellow)))
		 (flycheck-error :underline (list :style 'wave :color (catppuccin-color 'red))))
     (doom-gruvbox (secondary-selection :background "#504945")
		   (cur-mode-line-major-mode-active :foreground "#83a598"
						    :weight 'bold))
     (doom-oceanic-next (cur-mode-line-major-mode-active :foreground "#6699CC"
							 :weight 'bold))
     (doom-flatwhite (haskell-operator-face :background "#f7f3ee"
                                            :foreground "#605a52")
                     (haskell-type-face :background "#d2ebe3"
                                        :foreground "#465953")
                     (haskell-constructor-face :background "#f7e0c3"
                                               :foreground "#5b5143")
		     (completions-common-part :background "#dde4f2"
					      :foreground "#7382a0"
					      :weight 'bold)
		     (org-dispatcher-highlight :background "#f7e0c3"
					       :foreground "#957f5f")
		     (help-key-binding :background "#f7f3ee"
				       :foreground "#7382a0")
		     (fill-column-indicator :foreground "#b9a992")
		     (org-block :foreground "#93836c"
				:background "#f1ece4"))
     (doom-nord (mode-line :background "#3b4252")
		(mode-line-inactive :foreground "#88c0d0"
				    :background "#3b4252")
		(hl-line :background "#3b4252")
		(font-lock-comment-face :foreground "#4c566a")
		(org-block-begin-line :foreground "#d8dee9"
				      :background "#3b4252"
				      :inherit 'org-block
				      :extend t)
		(org-block :background "#2e3440")
		(dired-broken-symlink :foreground "#ebcb8b"
				      :background "#bf616a")
		(meow-beacon-fake-selection :foreground "#d8dee9"
					    :weight 'bold)
		(secondary-selection :background "#3b4252")
		(vertical-border :foreground "#3b4252"
				 :background "#3b4252")
		(help-key-binding :foreground "#88c0d0"
				  :background "#2e3440"
				  :box '(:line-width 1 :color "#4c566a")
				  :inherit 'fixed-pitch)
		(corfu-default :foreground "#eceff4"
			       :background "#3b4252")
		(corfu-current :foreground "#eceff4"
			       :background "#434c5e")
		(aw-leading-char-face :foreground "#bf616a" :height 1.3)
		(aw-background-face :foreground "#4c566a")))))
#+end_src

*** Doom themes

Doom themes are a theme pack specifically for the Doom Emacs distribution, but work well without doom as well. I have a function that sets some faces based on the theme in ~custom-enabled-themes~. This function is more than just a little jank and I plan on creating my own themes instead of trying to hack around ones made by someone else.

#+begin_src text :tangle ./packages.txt :padline no
doom-themes
#+end_src

#+begin_src emacs-lisp
;; ===Doom Emacs Themes===
(use-package doom-themes
  :demand t)
  ;; :config
  ;; (cur-override-theme-load-theme 'doom-flatwhite))
#+end_src

*** Autothemer

A library used by =catppuccin= and =kanagawa=.

#+begin_src text :tangle ./packages.txt :padline no
autothemer
#+end_src

#+begin_src emacs-lisp
;; ===Autothemer===
(use-package autothemer)
#+end_src

*** Catppuccin Theme

[[https:github.com/catppuccin/catppuccin][Link]] to the catppuccin theme.

#+begin_src text :tangle ./packages.txt :padline no
catppuccin-theme
#+end_src

#+begin_src emacs-lisp
;; ===Catppuccin Theme===
(use-package catppuccin-theme
  :after (autothemer cur-theme))
#+end_src

*** Default Theme

#+begin_src emacs-lisp
(cur-override-theme-load-theme 'catppuccin)
#+end_src

*** Ef-themes

Themes made by Protesilaos, also known as Prot.

#+begin_src text :tangle ./packages.txt :padline no
ef-themes
#+end_src

#+begin_src emacs-lisp
;; ===Ef-Themes===
(use-package ef-themes)
;; :config
;; (cur/load-theme 'ef-tritanopia-dark))
#+end_src

*** Nerd Icons Ibuffer

Adds Icons to ~ibuffer~. Not really a face thing but I don't have a dedicated ~ibuffer~ module so it goes here instead.

#+begin_src text :tangle ./packages.txt :padline no
nerd-icons-ibuffer
#+end_src

#+begin_src emacs-lisp
;; ===Ibuffer Icons===
(use-package nerd-icons-ibuffer
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** Custom Mode Line

#+begin_src emacs-lisp
(use-package cur-mode-line
  :custom
  (mode-line-right-align-edge 'right-fringe)
  (cur-mode-line-exclude-narrow-inidcator '(Info-mode))
  :config
  (setq-default mode-line-end-spaces
		'(""
		  cur-mode-line-flycheck-indicator
		  (:eval (when (cur-mode-line-flycheck-display-p) "  "))
		  cur-mode-line-eat-indicator
		  (:eval (when (cur-mode-line-eat-display-p) "  "))
		  cur-mode-line-eat-eshell-indicator
		  (:eval (when (cur-mode-line-eat-eshell-display-p) "  "))
		  cur-mode-line-major-mode-indicator
		  cur-mode-line-end-padding))
  (setq-default mode-line-format
		'("%e"
                  cur-mode-line-kmacro-indicator
                  cur-mode-line-narrowed-indicator
                  "  "
                  cur-mode-line-buffer-status-indicator
		  (:eval (when (cur-mode-line-meow-display-p) "  "))
                  cur-mode-line-meow-state-indicator
                  "  "
		  cur-mode-line-buffer-name-indicator
		  (:eval (when (mode-line-window-selected-p) "  "))
		  cur-mode-line-postion-indicator
		  cur-mode-line-right-align
		  mode-line-end-spaces)))
#+end_src

*** Page Break Lines
#+begin_src text :tangle ./packages.txt :padline no
page-break-lines
#+end_src

#+begin_src emacs-lisp
(use-package page-break-lines
  :defer t)
#+end_src

*** Dashboard

#+begin_src text :tangle ./packages.txt :padline no
dashboard
nerd-icons
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package dashboard
  :custom
  (dashboard-items '((projects . 5)
		     (recents . 5)
		     (bookmarks . 5)))
  (dashboard-startupify-list '(dashboard-insert-banner
			       dashboard-insert-newline
			       dashboard-insert-init-info
			       dashboard-insert-items
			       dashboard-insert-newline
			       dashboard-insert-footer))
  (dashboard-center-content t)
  :config
  ;; These make it really easy to accidentally delete projects and bookmarks
  (dolist (c '(dashboard-remove-item-under
	       dashboard-remove-item-agenda
	       dashboard-remove-item-recentf
	       dashboard-remove-item-projects
	       dashboard-remove-item-bookmarks))
    (put c 'disabled t))
  (setopt dashboard-heading-icons '((recents . "nf-oct-history")
				    (bookmarks . "nf-oct-bookmark")
				    (agenda . "nf-oct-calendar")
				    (projects . "nf-oct-rocket")
				    (registers . "nf-oct-database")))
  (setopt dashboard-startup-banner (concat (expand-file-name user-emacs-directory) "dashboard-banners/nocturne-fraktur.txt"))
  (dashboard-setup-startup-hook))

(use-package dashboard
  :if (locate-library "nerd-icons.el")
  :custom
  (dashboard-display-icons-p t)
  (dashboard-icon-type 'nerd-icons)
  (dashboard-set-file-icons t)
  (dashboard-set-heading-icons t))

(use-package dashboard
  :if (locate-library "page-break-lines.el")
  :hook (dashboard-before-initialize . (lambda (&rest _)
					(page-break-lines-mode +1)))
  :custom
  (dashboard-page-separator "\n"))
#+end_src

#+begin_src emacs-lisp
(provide 'cur-config-faces)
#+end_src

** Completion system configurations (=cur-config-completion.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-completion.el
:END:

This section is not about code completion. Rather, this is my configuration for Emacs' completion system and the main interfaces that use them. For code completion please go see =cur-config-ide.el= and ~company-mode~.

Currently I am using the [[https:github.com/abo-abo/swiper/][ivy/counsel/swiper]] suite for doing completions in emacs. I like it but I know that the vertico/marginelia/consult/embark chain is better, faster, and more modern. I plan to make the switch at some point but for now I sticking with ivy.

#+begin_src text :tangle ./packages.txt :padline no
embark
embark-consult
#+end_src

*** Completions Styles

#+begin_src text :tangle ./packages.txt :padline no
orderless
#+end_src

#+begin_src emacs-lisp
(use-package minibuffer
  :config
  (setq completion-styles '(basic substring orderless))
  (setq completion-category-overrides
        '((file      (styles . (basic partial-completion orderless)))
          (kill-ring (styles . (emacs22 orderless))))))

(use-package orderless
  :bind ( :map minibuffer-local-completion-map
          ("SPC" . nil)
          ("?" . nil))
  :config
  (setq orderless-matching-styles '(orderless-prefixes orderless-regexp)))
#+end_src

*** Vertico

#+begin_src text :tangle ./packages.txt :padline no
vertico
#+end_src

#+begin_src emacs-lisp
(use-package vertico
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :bind ( :map vertico-map
	  ("M-e" . vertico-next-group)
	  ("M-a" . vertico-previous-group))
  :init
  (vertico-mode 1))
#+end_src

*** Marginalia

#+begin_src text :tangle ./packages.txt :padline no
marginalia
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode 1))
#+end_src

*** Consult

#+begin_src text :tangle ./packages.txt :padline no
consult
#+end_src

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :bind (("C-x b"               . consult-buffer)
         ("M-g i"               . consult-imenu)
         ("M-y"                 . consult-yank-pop)
         ([remap goto-line]     . consult-goto-line)
         ([remap bookmark-jump] . consult-bookmark)
         ([remap rg-project]    . consult-ripgrep)
         ([remap rg]            . consult-ripgrep)
         ([remap project-switch-to-buffer] . consult-project-buffer)
         :map consult-narrow-map
         ("?" . consult-narrow-help)
         :map goto-map
         ("m" . consult-mark)
         ("M" . consult-global-mark)
         ("o" . consult-outline)
         :map search-map
         ("/" . consult-line)
         ("?" . consult-line-multi)
	 :map cur/register-map
	 ("C-s" . consult-register-store)
	 ("C-l" . consult-register-load)
	 ("C-v" . consult-register))
  :custom
  (consult-preview-allowed-hooks '(global-font-lock-mode
                                   save-place-find-file-hook
                                   ;; Dired
                                   dired-hide-details-mode
                                   hl-line-mode
                                   nerd-icons-dired-mode))

  :config
  (setq xref-show-xrefs-function       #'consult-xref
        xref-show-definitions-function #'consult-xref))

(use-package consult
  :after (meow)
  :config
  (meow-normal-define-key
   '("/" . consult-line)))

(use-package consult
  :after (org)
  :bind ( :map org-mode-map
          ([remap consult-imenu] . consult-org-heading)))

(use-package cur-consult
  :after (consult)
  :custom
  (cur-override-theme-load-function #'cur-consult-theme))
#+end_src

*** Consult Directory
#+begin_src text :tangle ./packages.txt :padline no
consult-dir
#+end_src

#+begin_src emacs-lisp
(use-package consult-dir
  :bind ( :map global-map
	  ("C-x C-d" . consult-dir)
	  :map minibuffer-local-completion-map
	  ("C-x C-d" . consult-dir)
	  ("C-x C-j" . consult-dir-jump-file)))

(use-package consult-dir
  :after vertico
  :bind ( :map vertico-map
	  ("C-x C-d" . consult-dir)
	  ("C-x C-j" . consult-dir-jump-file)))

(use-package consult-dir
  :after meow
  :bind ( :map cur/sub-leader-keymap
	  ("C-d" . consult-dir)))
#+end_src

*** TODO Embark

#+begin_src text :tangle ./packages.txt :padline no
embark
embark-consult
#+end_src

#+begin_src emacs-lisp
(use-package emabark
  :bind ( :map global-map
          ("C-." . embark-act)
          :map minibuffer-local-map
          ("C-." . embark-act)
          :map dired-mode-map
          ("'"  . embark-act)
          ("\"" . embark-dwim)))
#+end_src

*** TODO Corfu

#+begin_src text :tangle ./packages.txt :padline no
corfu
#+end_src

#+begin_src emacs-lisp
(use-package corfu
  :bind
  (:map corfu-map
	("TAB"       . corfu-next)
	("<tab>"     . corfu-next)
	("S-TAB"     . corfu-previous)
	("<backtab>" . corfu-previous)
	("<escape>"  . corfu-quit) ; note: cannot bind "ESC" because it causes errors
	("M-SPC"     . corfu-insert-separator))
  :custom
  (corfu-auto t)
  (corfu-preview-current 'insert)
  (corfu-auto-delay 0.1)
  (corfu-auto-prefix 3)
  (corfu-max-width 40)
  (corfu-popupinfo-delay '(2.0 . 1.0))
  (tab-always-indent 'complete)
  :hook
  (corfu-mode . corfu-popupinfo-mode))

(provide 'cur-config-completion)
#+end_src

*** TODO Cape

#+begin_src text :tangle ./packages.txt :padline no
cape
#+end_src

** Window management configurations (=cur-config-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-window.el
:END:

*** Display Buffer Alist

These are my settings for ~display-buffer-alist~ so windows just Do What I Mean.

#+begin_src emacs-lisp
(use-package cur-window
  :config
  (setq window-sides-slots
        '(1 1 1 1))
  (setq display-buffer-alist
        '(("\\`\\*Async Shell Command.*\\'"
           (display-buffer-no-window))
          ("\\*Org Src.*"
           (display-buffer-same-window))
          ((or (derived-mode . compilation-mode)
               (derived-mode . geiser-mode)
               (derived-mode . grep-mode)
               (derived-mode . help-mode)
               (derived-mode . Info-mode)
               (derived-mode . rg-mode)
               (derived-mode . woman-mode))
           (cur-window-display-buffer-below-or-pop)
           (body-function . cur-window-select-fit-to-size))
	  ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))
	  ("\\*Register Preview\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
	   (window-parameters . ((mode-line-format . none))))
          ((or (derived-mode . occur-mode)
               (derived-mode . xref--xref-buffer-mode))
           (display-buffer-reuse-window
            display-buffer-below-selected)
           (dedicated . t)
           (body-function . cur-window-select-fit-to-size))
          ((or (derived-mode . justl-mode)
               "justl - .*")
           (display-buffer-reuse-window
            display-buffer-at-bottom)
           (dedicated . t)
           (window-height . 0.25))
	  ((or "\\*eshell .*"
               "\\*.*-eshell*"
               "\\*.*-eat\\*")
           (display-buffer-reuse-window
            display-buffer-at-bottom)
           (window-height . 0.25))
          ((or (derived-mode . vterm-mode)
               "\\*vterm.*\\*"
               "\\*.*-vterm\\*")
           (display-buffer-reuse-mode-window
            display-buffer-same-window))
	  (".*"
	   (display-buffer-same-window)))))
#+end_src

*** Ace Window

#+begin_src text :tangle ./packages.txt :padline no
ace-window
#+end_src

#+begin_src emacs-lisp
(use-package ace-window
  :custom
  (aw-keys '(?n ?h ?j ?k ?l ?i ?u ?y ?r ?e))
  (aw-dispatch-always t)
  :config
  (setq aw-dispatch-alist '((?d delete-window)
			    (?D aw-delete-window "Delete Window")
			    (?m aw-swap-window "Swap Window")
			    (?w aw-flip-window)
			    (?b cur-aw-switch-buffer-in-window "Select Buffer")
			    (?s aw-split-window-horz "Split Horizonally")
			    (?v aw-split-window-vert "Split Vertically")
			    (?o delete-other-windows)
			    (?O delete-other-windows "Delete Other Windows")
			    (?? aw-show-dispatch-help))))

(use-package cur-aw
  :after ace-window)

(provide 'cur-config-window)
#+end_src

** IDE configurations (=cur-config-ide.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-ide.el
:END:

Emacs can be made to have all the features of a modern text editor and then some.

*** Display Fill Column Indicator

This is just a minor mode that shows a small bar at a certain column position. It's useful for a quick eyeball test if the line is too big but sometimes hurts readability.

#+begin_src emacs-lisp
(use-package emacs
  :custom
  (display-fill-column-indicator-column 81)
  ;; Enable this hook for it to show up in prog-mode
  ;; :hook (prog-mode . (lambda (&rest _)
  ;; 		       (display-fill-column-indicator-mode +1)))
  )
#+end_src

*** LSP-mode

Lsp-mode is my chosen language server protocol support package. I chose this over eglot because of the richer features and (at the time that I started using lsp) more mature state. I will revisit elgot in the future but for now I am perfectly happy with lsp-mode.

#+begin_src text :tangle ./packages.txt :padline no
lsp-mode
#+end_src

#+begin_src emacs-lisp
;; ===LSP Mode===
(use-package lsp-mode
  :demand t
  :hook
  (lsp-mode  . lsp-enable-which-key-integration)
  :custom
  (lsp-keymap-prefix "C-c C-M-l" "lsp mode keymap")
  (lsp-file-watch-threshold 1750)
  :bind (:map lsp-mode-map
              ("C-c C-a" . lsp-execute-code-action)  ; code actions
              ("C-c C-e" . lsp-treemacs-errors-list) ; treemacs error list
              ("C-c f"   . lsp-find-references)      ; find references
              ("C-c r"   . lsp-find-definition))     ; find definitions
  :config
  (lsp-deferred)
  (setq gc-cons-threshold (* 100 1024 1024))
  (setq read-process-output-max (* 3 1024 1024))
  (setq lsp-idle-delay 0.500)
  (setq lsp-lens-enable nil)
  (lsp-enable-which-key-integration t))
#+end_src

*** LSP UI

Lsp-ui provides some ui enhancements and extra features to lsp. Probably the best one is the doc feature to view documentation in the editor.

#+begin_src text :tangle ./packages.txt :padline no
lsp-ui
#+end_src

#+begin_src emacs-lisp
(use-package lsp-ui
  :after (lsp-mode)
  :custom
  (lsp-ui-doc-enable nil "lsp-ui doc disabled by default")
  (lsp-ui-doc-show-with-cursor t "lsp-ui doc follows cursor")
  (lsp-ui-doc-show-with-mouse t "lsp-ui doc follows mouse")
  (lsp-ui-doc-position 'at-point "lsp-ui doc shows at cursor")
  :bind (:map lsp-ui-mode-map
              ("C-c C-f" . lsp-ui-peek-find-references)  ; find references ui
              ("C-c C-r" . lsp-ui-peek-find-definitions) ; find definitions ui
              ("C-c C-d" . lsp-ui-doc-mode) ; toggle doc mode
              :map lsp-ui-peek-mode-map
              ("ESC" . lsp-ui-peek--abort)             ; toggle doc mode
              ("g"   . lsp-ui-peek--abort)             ; toggle doc mode
              ("j"   . lsp-ui-peek--select-next)       ; toggle doc mode
              ("k"   . lsp-ui-peek--select-prev)       ; toggle doc mode
              ("C-j" . lsp-ui-peek--select-next-file)  ; toggle doc mode
              ("C-k" . lsp-ui-peek--select-prev-file)) ; toggle doc mode
  :hook
  (lsp-mode . lsp-ui-mode))
#+end_src

*** TODO Eglot

*** Company

The code completion system. This is different from completions systems like ivy or vertico, this is for interactively completing a symbol while programming.

#+begin_src text :tangle ./packages.txt :padline no
company
#+end_src

#+begin_src emacs-lisp
;; ===Company Mode===
(use-package company
  :hook
  (prog-mode . company-mode)
  (lsp-mode . company-mode)
  :bind ( :map company-active-map
          ("<tab>" . company-complete-common-or-cycle)
          ("<return>" . company-complete-selection)
	  :map company-mode-map
	  ("<tab>" . company-indent-or-complete-common))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))
;;(company-tng-configure-default))
#+end_src

*** Flycheck

Code error checking with a nice UI.

#+begin_src text :tangle ./packages.txt :padline no
flycheck
#+end_src

#+begin_src emacs-lisp
;; ===Flycheck===
(use-package flycheck
  :hook
  (prog-mode . flycheck-mode)
  (lsp-mode  . flycheck-mode))
#+end_src

*** TODO Flymake

*** Magit

Magit is a git interface, probably the best one I have ever seen or had the pleasure of using. I consider magit to be one of emacs' "killer features", right up there with org-mode.

#+begin_src text :tangle ./packages.txt :padline no
magit
#+end_src

#+begin_src emacs-lisp
;; ===Magit===
(use-package magit
  :bind ( :map cur/sub-leader-keymap
          ("C-v" . magit)
          :map project-prefix-map
          ("C-v" . nil)
          ("v" . magit-project-status)
          ("V" . project-vc-dir))
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (transient-default-level 5 "Allowing for commit signing"))
#+end_src

*** Project.el

#+begin_src emacs-lisp
(use-package project
  :bind ( :map project-prefix-map
          ("d"   . project-dired)
          ("D"   . project-find-dir)
          ("C-b" . nil)
          ("b"   . project-switch-to-buffer)
          ("l"   . project-list-buffers))
  :custom
  (project-buffers-viewer #'project-list-buffers-ibuffer)
  (project-switch-use-entire-map t))
#+end_src

*** Ripgrep

Ripgrep go burrr.

#+begin_src text :tangle ./packages.txt :padline no
rg
#+end_src

#+begin_src emacs-lisp
(use-package rg)
#+end_src

*** TMR

#+begin_src text :tangle ./packages.txt :padline no
tmr
#+end_src

#+begin_src emacs-lisp
(use-package tmr
  :defer t)

(provide 'cur-config-ide)
#+end_src

** Configurations for Lisp (=cur-config-lisp.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-lisp.el
:END:

These are my configurations for working with Lisp languages.

*** Rainbow Delimiters

This color codes opening and closing delimiters such as parentheses and square brackets.

#+begin_src text :tangle ./packages.txt :padline no
rainbow-delimiters
#+end_src

#+begin_src emacs-lisp
;; ===rainbow-delimiters===
(use-package rainbow-delimiters
  ;; :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Paredit

#+begin_src text :tangle ./packages.txt :padline no
paredit
#+end_src

#+begin_src emacs-lisp
;; ===Paredit===
(use-package paredit
  :hook ((emacs-lisp-mode lisp-interaction-mode scheme-mode) .
         (lambda () (paredit-mode 1))))
#+end_src

*** Geiser

#+begin_src text :tangle ./packages.txt :padline no
geiser
geiser-chez
geiser-chibi
geiser-chicken
geiser-gambit
geiser-gauche
geiser-guile
geiser-kawa
geiser-mit
geiser-racket
geiser-stklos
macrostep
macrostep-geiser
#+end_src

#+begin_src emacs-lisp
;; ===Geiser===

(provide 'cur-config-lisp)
#+end_src

** Configurations for Java (=cur-config-java.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-java.el
:END:

My configurations for working with the Java language. I have ~java-ts-mode~, the tree sitter version of the normal ~java-mode~, as the mode for editing =.java= files. I have found that either tree sitter provides exactly the same or better syntax highlighting and the possibility of better movement once it gets better integrated into emacs.

I also have lsp-java set up for better integrating ~lsp-mode~ into ~java-ts-mode~. Note because I have =direnv= integration with ~envrc~, the hooks I add to start ~lsp~ must be ~lsp-defered~. ~lsp-defered~ does not start ~lsp-mode~ until after the buffer has visually loaded. We want this because ~envrc~ will change the ~exec-path~ to what =direnv= would change it to. For instance, if I have a devshell that says "here is the lsp-server, the build tool, and external libraries with these exact versions", envrc will make sure that ~exec-path~ contains exactly those versions of those programs in the nix store.

#+begin_src text :tangle ./packages.txt :padline no
lsp-java
#+end_src

#+begin_src emacs-lisp
;; ===Java Tree-Sitter Mode===
(use-package java-ts-mode
  :mode "\\.java\\'"
  :custom (java-ts-mode-indent-offset 8))

;; ===lsp-java===
(use-package lsp-java
  :after (lsp-mode cc-mode)
  :init
  :hook
  (envrc-mode . (lambda ()
                  (when (equal major-mode 'java-ts-mode)
                    (setq lsp-java-server-install-dir (concat (getenv "JDTLS_PATH") "/share/java/jdtls/")))))
  (java-ts-mode . lsp-deferred)
  :config
  (defun lsp-java--ls-command ()
    (let ((jdtls-path (getenv "JDTLS_PATH"))
          (jdtls-exec-options (list
                               "-configuration"
                               (concat (getenv "HOME") "/.jdtls/config_linux")
                               "-data"
                               (concat (getenv "HOME") "/.jdtls/java-workspace"))))
      (message (concat jdtls-path "/share/java/"))
      (append (list (concat jdtls-path "/bin/jdtls")) jdtls-exec-options))))

(provide 'cur-config-java)
#+end_src

** Configurations for Justfiles (=cur-config-just.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-just.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
just-mode
#+end_src

#+begin_src emacs-lisp
(use-package just-mode
  :defer t)

(provide 'cur-config-just)
#+end_src

** Configurations for Mark-up Languages (=cur-config-markup.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-markup.el
:END:

Literally just ~yaml-mode~.

#+begin_src text :tangle ./packages.txt :padline no
yaml-mode
#+end_src

#+begin_src emacs-lisp
;; ===YAML===
(use-package yaml-mode
  :commands (yaml-mode))

(provide 'cur-config-markup)
#+end_src

** Configurations for Nix (=cur-config-nix.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-nix.el
:END:

My configurations for the Nix language, which boils down to "start the lsp server".

#+begin_src text :tangle ./packages.txt :padline no
nix-mode
nix-ts-mode
#+end_src

#+begin_src emacs-lisp
;; ===nix-mode===
(use-package nix-mode
  :hook
  (nix-mode . lsp-deferred)) ;; So that envrc mode will work

(use-package nix-mode
  :after lsp-mode
  :custom
  (lsp-disabled-clients '((nix-mode . nix-nil)) "disable nil so that nixd will be used as lsp-server")
  (lsp-nix-nixd-server-path "nixd" "set nixd binary path to be use from current $PATH"))

(provide 'cur-config-nix)
#+end_src

** Configurations for Rust (=cur-config-rust.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-rust.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
rustic
#+end_src

#+begin_src emacs-lisp
;; ===Rust-Mode===
(use-package rustic
  :after (lsp-mode)
  :hook (rustic . lsp-deferred))

(provide 'cur-config-rust)
#+end_src

** Configurations for Haskell (=cur-config-haskell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-haskell.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
haskell-mode
company-ghci
#+end_src

#+begin_src emacs-lisp
;; ===Haskell-Mode===
(use-package haskell-mode)

;; ===LSP-Haskell===
(use-package lsp-haskell
  :hook
  ((haskell-mode) . lsp-deferred))

;; ===Company-GHCI===
(use-package company-ghci
  :after (company)
  :custom (company-ghc-show-info t)
  :config
  (push 'company-ghci company-backends))

(provide 'cur-config-haskell)
#+end_src

** Configurations for OCaml
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-ocaml.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
tuareg
utop
merlin
merlin-company
#+end_src

#+begin_src emacs-lisp
;; ===Tuareg===
(use-package tuareg
  :hook (tuareg-mode . merlin-mode)
  :defer t)

;; ===Utop===
(use-package utop
  :commands (utop utop-mode)
  :config
  (advice-add 'utop :around 'inheritenv-apply))

(use-package merlin
  :defer t)

(use-package merlin-company
  :after (merlin))

(provide 'cur-config-ocaml)
#+end_src

** Configurations for C (=cur-config-c.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-c.el
:END:

I use tree-sitter for C, which unfortunately is not currently integrated into the default C major mode for emacs. I have also changed the ~c-default-style~ for C to be "linux", which is 8 spaces for indentation instead of the default of 2.

#+begin_src text :tangle ./packages.txt :padline no
ccls
#+end_src

#+begin_src emacs-lisp
;; ===C Tree-Sitter Mode===
(use-package c-ts-mode
  :after (cc-mode)
  :mode
  ("\\.c\\'" . c-ts-mode)
  ("\\.h\\'" . c-ts-mode)
  :custom
  (c-default-style '((c-ts-mode . "linux")
                     (java-mode . "java")
                     (awk-mode  . "awk")
                     (other     . "gnu"))
		   "default style for c programs is linux")
  :hook
  (c-ts-mode . (lambda () (require 'ccls) (lsp-deferred))))

;; ===CCLS Mode===
(use-package ccls
  :after (cc-mode c-ts-mode))

(provide 'cur-config-c)
#+end_src

** Configurations for Zig (=cur-config-zig.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-zig.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
zig-mode
#+end_src

#+begin_src emacs-lisp
;; ===Zig Mode===
(use-package zig-mode
  :hook (zig-mode . lsp-deferred))

(provide 'cur-config-zig)
#+end_src

** Configurations for Go (=cur-config-go.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-go.el
:END:

#+begin_src emacs-lisp
;; ===Go Tree-Sitter Mode===
(use-package go-ts-mode
  :mode
  ("\\.go\\'" . go-ts-mode)
  ("go\\.mod\\'" . go-mod-ts-mode)
  :custom
  (go-ts-mode-indent-offset 4 "Set the indentation to 4")
  :hook
  (go-ts-mode . lsp-deferred)
  (go-ts-mode . (lambda () (setq tab-width 4))))

(provide 'cur-config-go)
#+end_src

** Terminal emulation and Eshell configuration (=cur-config-shell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-shell.el
:END:

*** Vterm

Vterm is a terminal emulator for emacs. It is faster than ~term~ and ~ansi-term~ but the downside is that it is not written entirely in elisp so its cross platform. ~cur/meow-vterm~ and ~cur/meow-vterm-other-window~ help make vterm more "intuitive". ~cur/vterm-kill~ kills the vterm buffer cleanly and without prompting.

#+begin_src text :tangle ./packages.txt :padline no
vterm
#+end_src

#+begin_src emacs-lisp
;; ===Vterm===
(use-package vterm
  :bind ( :map cur/sub-leader-keymap
          ("C-S-t" . vterm))
  :custom
  (vterm-shell "fish")
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
  (setq vterm-max-scrollback 10000))

(use-package cur-vterm
  :bind ( :map vterm-mode-map
          ("C-c C-RET"      . cur-vterm-enter-password)
          ("C-c C-<return>" . cur-vterm-enter-password)
          :map project-prefix-map
          ("T" . cur-vterm-project-other-window)))
#+end_src

*** Eat

Eat is just a better elisp terminal emulator. I mostly use this so that eshell can run TUI programs.

#+begin_src text :tangle ./packages.txt :padline no
eat
#+end_src

#+begin_src emacs-lisp
;; ===Eat===
(use-package eat
  :hook (eat-exec . (lambda (&rest _) (eat-line-mode)))
  :bind ( :map eat-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password)
	  :map project-prefix-map
	  ("t" . eat-project)
	  :map cur/sub-leader-keymap
	  ("C-t" . eat))
  :custom
  (eat-kill-buffer-on-exit t)
  (eat-enable-directory-tracking t))

(use-package eat
  :after meow
  :hook
  (eat--char-mode . (lambda (&rest _)
		      (if eat--char-mode
			  (meow-mode -1)
			(unless meow-mode
			  (meow-mode +1))))))

(use-package eat
  :after eshell
  :hook (eat-eshell-exec . (lambda (&rest _) (eat-eshell-emacs-mode)))
  :bind ( :map eat-eshell-emacs-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password)
	  :map eat-eshell-semi-char-mode-map
	  ("C-c C-RET" . eat-send-password)
	  ("C-c C-<return>" . eat-send-password))
  :custom
  (eshell-visual-commands nil "nil because using `eat-eshell-mode'")
  (eshell-visual-subcommands nil "nil because using `eat-eshell-mode'")
  :config
  (eat-eshell-mode 1))

(use-package eat
  :if (locate-library "corfu.el")
  :hook (eat-mode . (lambda (&rest _)
		      (setq-local corfu-auto nil)
		      (setq-local corfu-quit-at-boundary nil)
		      (corfu-mode +1))))
#+end_src

*** Eshell

Eshell is an shell for Emacs like bash or sh, but written in elisp and has its own ways of doing things. Note: not POSIX compliant.

#+begin_src text :tangle ./packages.txt :padline no
eshell-syntax-highlighting
#+end_src

#+begin_src emacs-lisp
;; ===Eshell===
(use-package eshell
  :bind ( :map cur/sub-leader-keymap
          ("C-e" . eshell)))

(use-package eshell
  :if (locate-library "corfu.el")
  :hook
  (eshell-mode . (lambda (&rest _)
		   (setq-local corfu-auto nil)
		   (setq-local corfu-quit-at-boundary nil)
		   (corfu-mode +1))))

(use-package eshell-syntax-highlighting
  :after eshell
  :config
  (eshell-syntax-highlighting-global-mode +1))

(use-package cur-eshell
  :after (eshell)
  :custom
  (eshell-prompt-function 'cur-eshell-prompt "Set custom prompt for eshell")
  :config
  (setopt eshell-prompt-regexp cur-eshell-prompt-regexp))
#+end_src

*** Zoxide

Interfacing with Zoxide from emacs.

#+begin_src text :tangle ./packages.txt :padline no
zoxide
#+end_src

#+begin_src emacs-lisp
;; ===Zoxide===
(use-package zoxide)

(provide 'cur-config-shell)
#+end_src

** Org-mode (=cur-config-org.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-org.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
org-bullets
#+end_src

#+begin_src emacs-lisp
;; ===Org-Mode===
(use-package org
  :ensure nil
  :defer t
  :hook (org-mode . cur/org-mode-setup)
  :bind ( :map org-mode-map
          ("C-S-h" . outline-promote)
          ("C-S-j" . outline-move-subtree-down)
          ("C-S-k" . outline-move-subtree-up)
          ("C-S-l" . outline-demote))
  :init
  (defun cur/org-mode-setup ()
    (org-indent-mode 1)
    (variable-pitch-mode 0)
    (visual-line-mode 1)
    (flyspell-mode 1))
  :custom
  (org-ellipsis " ▾" "Readable ellipsis")
  (org-adapt-indentation nil)
  (org-special-ctrl-a/e nil)
  (org-M-RET-may-split-line '((default . nil)))
  (org-hide-emphasis-markers nil)
  (org-hide-macro-markers nil)
  (org-hide-leading-stars nil)
  (org-agenda-start-with-log-mode t)
  (org-src-window-setup 'plain) ; don't override `display-buffer-alist'
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-agenda-window-setup 'current-window "Have org-agenda pop up in the current window")
  (org-imenu-depth 4)
  (org-edit-src-content-indentation 0)
  :config
  (load-library "find-lisp")
  ;; (setq org-agenda-files (find-lisp-find-files "~/dox/agenda" "\.org$"))
  (setq org-agenda-time-grid '((daily today require-timed)
                               (400 600 800 1000 1200 1400 1600 1800 2000 2200)
                               "......" "----------------"))
  (setq org-format-latex-options '(:foreground "#e5e9e9" :scale 1.0)))
;; (cur/org-font-setup))
#+end_src

#+begin_src emacs-lisp
;; ===Org Tempo and SRC Blocks===
(use-package org-tempo
  :after org
  :custom
  (org-structure-template-alist
   '(("s" . "src")
     ("e" . "src emacs-lisp")
     ("t" . "src emacs-lisp :tangle FILENAME")
     ("T" . "src text :tangle FILENAME")
     ("P" . "src text :tangle ./packages.txt :padline no")
     ("x" . "export")
     ("X" . "example")
     ("q" . "quote")
     ("v" . "verse"))))
#+end_src

#+begin_src emacs-lisp
;; ===Org Babel===
(use-package ob
  :after org)
;; TODO: fix this so I can still auto tangle on saving
;; :init
;; (defun cur/org-babel-tangle-config ()
;;   (when (string-equal (file-name-directory (buffer-file-name))
;;                       (expand-file-name user-emacs-directory))
;;     ;; Dynamic scoping to the rescue
;;     (let ((org-confirm-babel-evaluate nil))
;;       (org-babel-tangle))))
;; 
;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'cur/org-babel-tangle-config))))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell
  :bind ( :map flyspell-mode-map
          ("C-." . nil)
          ("C-," . nil)))

(provide 'cur-config-org)
#+end_src

** Configurations for Gemini and the smolnet (=cur-config-smol-net.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-smol-net.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
gemini-mode
ox-gemini
elpher
#+end_src

#+begin_src emacs-lisp
;; ===Gemini-Mode===
(use-package gemini-mode
  :defer t)

;; ===Org Gemini Exporter==
(use-package ox-gemini
  :defer t)

;; ===Elpher Gemini/Gopher Client===
(use-package elpher
  :defer t
  :custom
  (elpher-default-url-type "gemini"))

(provide 'cur-config-smol-net)
#+end_src

** Elcord and making myself look productive to my friends (=cur-config-elcord.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-elcord.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
elcord
#+end_src

#+begin_src emacs-lisp
(use-package elcord
  :custom
  (elcord-boring-buffers-regexp-list '("^ " "\\\\*Messages\\\\*"
				       "\\\\*Help\\\\*" "\\\\*elpher\\\\*"
				       "\\\\*Org Src .*\\\\*"
				       "\\\\*Occur\\\\*"
				       "\\\\*Embark Collect .*\\\\*")))

(provide 'cur-config-elcord)
#+end_src

** Direnv integration (=cur-config-direnv.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-config/cur-config-direnv.el
:END:

#+begin_src text :tangle ./packages.txt :padline no
envrc
inheritenv
#+end_src

#+begin_src emacs-lisp
;; ===Envrc===
(use-package envrc
  :config
  (envrc-global-mode))

(provide 'cur-config-direnv)
#+end_src

* Custom Library Modules (=cur-lisp=)

** Ace Window Extensions (=cur-aw.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-aw.el
:END:

#+begin_src emacs-lisp
;;; cur-aw.el --- The extensions for ace-window -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'ace-window)

(defgroup cur-aw ()
  "Base functions and variables for my Emacs configuration."
  :group 'windows)

(defun cur-aw--switch-buffer ()
  "Call `consult-buffer' if it is bound.
Call `switch-to-buffer' if it is not."
  (cond ((fboundp 'consult-buffer)
	 (call-interactively 'consult-buffer))
	(t
	 (call-interactively 'switch-to-buffer))))

(defun cur-aw-switch-buffer-in-window (window)
  "Switch to buffer in WINDOW.
Prefer the use of `consult-buffer'."
  (aw-switch-to-window window)
  (cur-aw--switch-buffer))

(provide 'cur-aw)
;;; cur-aw.el ends here
#+end_src

** Base Values and Functions (=cur-base.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-base.el
:END:

#+begin_src emacs-lisp
;;; cur-base.el --- The base of my customizations for emacs -*- lexical-binding: t -*-

;;; Commentary:
;; This is the base of my extensions to Emac's functionality.
;; Do try this at home kids.

;;; Code:

(defgroup cur-base ()
  "Base functions and variables for my Emacs configuration."
  :group 'editing)

(provide 'cur-base)
;;; cur-base.el ends here
#+end_src

** Consult Extensions (=cur-consult.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-consult.el
:END:

#+begin_src emacs-lisp
;;; cur-consult-el --- Extending and Customizing Consult -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'consult)

(defgroup cur-consult ()
  "Integrate Consult and Projectile."
  :group 'consult
  :prefix "cur-consult-")

(defun cur-consult-theme (theme)
  "Disable current themes and enable THEME from `consult-themes'.

If THEME is a list of symbols, go through and enable each theme in reverse
order.  The command supports previewing the currently selected theme."
  (interactive
   (list
    (let* ((regexp (consult--regexp-filter
                    (mapcar (lambda (x) (if (stringp x) x (format "\\`%s\\'" x)))
                            consult-themes)))
           (avail-themes (seq-filter
                          (lambda (x) (string-match-p regexp (symbol-name x)))
                          (cons 'default (custom-available-themes))))
           (saved-theme (if (< (length custom-enabled-themes) 2)
                            (car custom-enabled-themes)
                          custom-enabled-themes)))
      (consult--read
       (mapcar #'symbol-name avail-themes)
       :prompt "Theme: "
       :require-match t
       :category 'theme
       :history 'consult--theme-history
       :lookup (lambda (selected &rest _)
                 (setq selected (and selected (intern-soft selected)))
                 (or (and selected (car (memq selected avail-themes)))
                     saved-theme))
       :state (lambda (action theme)
                (pcase action
                  ('return (cur-consult-theme (or theme saved-theme)))
                  ((and 'preview (guard theme)) (cur-consult-theme theme))))
       :default (symbol-name (or (if (and saved-theme (listp saved-theme))
                                     (car (last saved-theme))
                                   saved-theme)
                                 'default))))))
  (when (or (eq theme 'default)
            (when (listp theme)
              (member 'default theme)))
    (setq theme nil))
  (cond ((symbolp theme)
         (unless (eq theme (car custom-enabled-themes))
           (mapc #'disable-theme custom-enabled-themes)
           (when theme
             (if (custom-theme-p theme)
                 (enable-theme theme)
               (load-theme theme :no-confirm)))))
        ((listp theme)
         (unless (equal theme custom-enabled-themes)
           (let ((themes (reverse theme)))
             (mapc #'disable-theme custom-enabled-themes)
             (when themes
               (mapc (lambda (theme)
                       (if (custom-theme-p theme)
                           (enable-theme theme)
                         (load-theme theme :no-confirm)))
                     themes)))))))

(provide 'cur-consult)
;;; cur-consult.el ends here
#+end_src

** Custom Mode Line (=cur-modline.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-mode-line.el
:END:

#+begin_src emacs-lisp
;;; cur-mode-line.el --- My custom mode-line -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(eval-when-compile
  (require 'cl-lib))

;;;;; Custom Groups

(defgroup cur-mode-line nil
  "My custom mode-line that tries to be minimal."
  :group 'mode-line)

(defgroup cur-mode-line-faces nil
  "The faces for my custom mode-line."
  :group 'cur-mode-line)

(defface cur-mode-line-active
  '((t :inherit mode-line-active))
  "Face for active mode-line."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-inactive
  '((t :inherit mode-line-inactive))
  "Face for inactive mode-line."
  :group 'cur-mode-line-faces)

(unless (boundp 'mode-line-right-align-edge)
  (defcustom mode-line-right-align-edge 'right-fringe
    "Where mode-line should align to.
This will be defined in Emacs 30."
    :type '(choice (const right-margin)
                   (const right-fringe)
                   (const window))
    :group 'mode-line))

;;;;; Modeline Padding For Right Alignment

(defun cur-mode-line-right-align-space (arg)
  "Return a space right alligned to before where ARG should begin.
ARG should be a list parseable by `format-mode-line'."
  (let* ((end-string (format-mode-line arg))
	 (end-string-length (length end-string))
	 (end-length (if (> end-string-length 0)
			 (progn
			   (add-face-text-property
			    0 end-string-length 'mode-line t end-string)
			   (string-pixel-width end-string))
		       0)))
    (propertize " " 'display
		(if (and (display-graphic-p)
			 (not (eq mode-line-right-align-edge 'window)))
		    `(space :align-to (- ,mode-line-right-align-edge
					 (,end-length)))
		  `(space :align-to
			  (,(- (window-pixel-width)
			       (window-scroll-bar-width)
			       (window-right-divider-width)
			       (* (or (car (window-margins)) 0)
				  (frame-char-width))
			       (or (cadr (window-fringes)) 0)
			       (pcase mode-line-right-align-edge
				 ('right-margin (or (cdr (window-margins)) 0))
				 (_ 0))
			       end-length)))))))

(defvar cur-mode-line-right-align
  '(:eval (cur-mode-line-right-align-space mode-line-end-spaces))
  "Puts a space right alligned to before where `mode-line-end-spaces' should begin.
This should ALWAYS come before `mode-line-end-spaces' otherwise the
spacing will be messed up.")

(defun cur-mode-line-end-space-conditionally (arg)
  "Return a list of space characters based on `mode-line-right-align-edge' and ARG.
If `mode-line-right-align-edge' is \\='right-align or \\='window, return a single
space character plus ARG addtional space characters.  Otherwise, just return ARG
space characters."
  (pcase mode-line-right-align-edge
    ((or 'right-margin 'window)
     (let ((spaces " "))
       (dotimes (_ arg spaces)
	 (setq spaces (concat spaces " ")))))
    (_
     (let (spaces )
       (dotimes (_ arg spaces)
	 (setq spaces (concat spaces " ")))))))

(defvar cur-mode-line-end-padding
  '(:eval (cur-mode-line-end-space-conditionally 0))
  "This is a value used to add some padding for `mode-line-end-spaces'.
This is supposed to go at the end of `mode-line-end-spaces'.
To create add more padding you can use the `cur-mode-line-end-space-dwim'
 function and input the amount of extra space you would like at the end.")

;;;;; Kmacro Indicator

(defface cur-mode-line-kmacro
  '((t :inherit font-lock-string-face))
  "Face for when KMacros are being defined."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--kmacro ()
  "Return a propertized string if defining a kmacro."
  (when (and (mode-line-window-selected-p) defining-kbd-macro)
    (propertize "  KMACRO  " 'face 'cur-mode-line-kmacro)))

(defvar cur-mode-line-kmacro-indicator
  '(:eval (cur-mode-line--kmacro))
  "Indicator for KMacro definitions.")

;;;;; Narrowed Indicator

(defface cur-mode-line-narrowed
  '((t :inherit font-lock-constant-face))
  "Face for current window is narrowed."
  :group 'cur-mode-line-faces)

(defcustom cur-mode-line-exclude-narrow-inidcator '()
  "Which modes to exclude from showing the narrow indicator."
  :type '(repeat symbol)
  :group 'cur-mode-line)

(defun cur-mode-line--narrowed ()
  "Return a propertized string if current window is narrowed."
  (when (and (mode-line-window-selected-p)
             (buffer-narrowed-p)
             (not (apply #'derived-mode-p cur-mode-line-exclude-narrow-inidcator)))
    (propertize "  NARROWED  " 'face 'cur-mode-line-narrowed)))

(defvar cur-mode-line-narrowed-indicator
  '(:eval (cur-mode-line--narrowed))
  "Indicator for window narrowing.")

;;;;; Meow Indicator

(defface cur-mode-line-meow-state
  '((t :inherit highlight))
  "Face for showing meow state."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-meow-display-p ()
  "Return whether or not meow related indicators should be displayed."
  (and (member 'meow features)
       (mode-line-window-selected-p)
       meow-mode))

(defun cur-mode-line--meow ()
  "Return a propertized string of the current meow state."
  (when (cur-mode-line-meow-display-p)
    (propertize (format "  %s  " (substring-no-properties
				  (upcase (symbol-name meow--current-state))
				  0 3))
		'face 'cur-mode-line-meow-state)))

(defvar cur-mode-line-meow-state-indicator
  '(:eval (cur-mode-line--meow))
  "Indicator for current meow state.")

;;;;; Buffer Status

(defface cur-mode-line-buffer-status
  '((t :inherit bold))
  "Face for the file indicator."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--buffer-status-indicator ()
  "Return a propertized string for file indicator."
  ;; TODO: make these clickable
  (propertize
   (concat "%z" (mode-line-eol-desc) "%1*" "%1+" "%@")
   'face 'cur-mode-line-buffer-status))

(defvar cur-mode-line-buffer-status-indicator
  '(:eval (cur-mode-line--buffer-status-indicator))
  "Indicator for file coding system, editing status, and remote status.")

;;;;; Buffer Name

(defface cur-mode-line-buffer-name
  '((t ()))
  "Face for the buffer name indicator."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--buffer-name ()
  "Return a propertized string of the current buffer's name."
  (propertize (format "%s" (buffer-name)) 'face 'cur-mode-line-buffer-name))

(defvar cur-mode-line-buffer-name-indicator
  '(:eval (cur-mode-line--buffer-name))
  "Indicator for current buffer name.")

;;;;; Major Mode

(defface cur-mode-line-major-mode-active
  '((t :inherit (mode-line-emphasis bold)))
  "Face for major mode indicator when active."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-major-mode-inactive
  '((t :inherit bold))
  "Face for major mode indicator when inactive."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--major-mode ()
  "Return a propertized string of current `major-mode'."
  (let ((face (if (mode-line-window-selected-p)
		  'cur-mode-line-major-mode-active
		'cur-mode-line-major-mode-inactive)))
    (propertize
     (capitalize
      (string-replace
       "-" " " (string-replace
		"-mode" "" (symbol-name major-mode))))
     'face face)))

(defvar cur-mode-line-major-mode-indicator
  '(:eval (cur-mode-line--major-mode))
  "Indicator for current buffer's major mode.")

;;;;; Eat

(defface cur-mode-line-eat
  '((t :inherit (bold eat-shell-prompt-annotation-success)))
  "Face for position when active."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-eat-display-p ()
  "Return whether or not eat related indicators should be displayed."
  (and (member 'eat features)
       (mode-line-window-selected-p)
       (eq major-mode 'eat-mode)))

(defun cur-mode-line--eat ()
  "Return propertized string of current eat mode."
  (when (cur-mode-line-eat-display-p)
   (propertize
    (cond (eat--line-mode "(Line Mode)")
	  ((or eat--char-mode eat--eshell-char-mode) "(Char Mode)")
	  ((or eat--semi-char-mode eat--eshell-semi-char-mode)
	   "(Semi-Char Mode)")
	  (t "(Emacs Mode)"))
    'face 'cur-mode-line-eat)))

(defvar cur-mode-line-eat-indicator
  '(:eval (cur-mode-line--eat))
  "Indicator for Eat's current mode.")

;;;;; Eat Eshell

(defface cur-mode-line-eat-eshell
  '((t :inherit (bold eat-shell-prompt-annotation-success)))
  "Face for displaying current `eat-eshell-mode' minor mode."
  :group 'cur-mode-line-faces)

(defun cur-mode-line-eat-eshell-display-p ()
  "Return whether or not it is appropriate to display eat indicator in eshell."
  (and (member 'eat features)
       (member 'eshell features)
       (mode-line-window-selected-p)
       (eq major-mode 'eshell-mode)
       eat-terminal))

(defun cur-mode-line--eat-eshell ()
  "Return propertized string of current eat mode."
  (when (cur-mode-line-eat-eshell-display-p)
    (propertize
     (cond ((or eat--char-mode eat--eshell-char-mode) "(Char Mode)")
	   ((or eat--semi-char-mode eat--eshell-semi-char-mode)
	    "(Semi-Char Mode)")
	   (t "(Emacs Mode)"))
     'face 'cur-mode-line-eat)))

(defvar cur-mode-line-eat-eshell-indicator
  '(:eval (cur-mode-line--eat-eshell))
  "Indicator for eat-eshell's current mode.")

;;;;; Position

(defface cur-mode-line-postion
  '((t ()))
  "Face for position when active."
  :group 'cur-mode-line-faces)

(defun cur-mode-line--position ()
  "Return a propertized string with the position of point in current buffer."
  (when (mode-line-window-selected-p)
    (concat "(%p" (when column-number-mode ", %c") ")")))

(defvar cur-mode-line-postion-indicator
  '(:eval (cur-mode-line--position))
  "Indicator for current buffer's position.")

;;;;; Flycheck

(defun cur-mode-line-flycheck-display-p ()
  "Whether or not to display flycheck indicator."
  (and (member 'flycheck features)
       flycheck-mode
       (mode-line-window-selected-p)))

(defun cur-mode-line--flycheck-num-errors (level face)
  "Return a string of number of errors in LEVEL with FACE applied conditionally."
  (when (cur-mode-line-flycheck-display-p)
    (let* ((error-nums (or (cdr (assoc level (flycheck-count-errors flycheck-current-errors))) 0))
	   (icon (pcase level
		   ('info "󰋽")
		   ('warning "")
		   ('error "")))
	   (string (format "%s %s" icon error-nums)))
      (if flycheck-mode-line-color
	  (propertize string 'face face)
	string))))

(cur-mode-line--flycheck-num-errors 'info 'cur-mode-line-flycheck-info)
(cur-mode-line--flycheck-num-errors 'warning 'cur-mode-line-flycheck-warning)
(cur-mode-line--flycheck-num-errors 'error 'cur-mode-line-flycheck-error)

(defface cur-mode-line-flycheck-info
  '((t :inherit (flycheck-error-list-info mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-flycheck-warning
  '((t :inherit (flycheck-error-list-warning mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defface cur-mode-line-flycheck-error
  '((t :inherit (flycheck-error-list-error mode-line)))
  "Face for flycheck info indicator."
  :group 'cur-mode-line-faces)

(defvar cur-mode-line-flycheck-indicator
  '((:eval (cur-mode-line--flycheck-num-errors 'error 'cur-mode-line-flycheck-error))
    " "
    (:eval (cur-mode-line--flycheck-num-errors 'warning 'cur-mode-line-flycheck-warning))
    " "
    (:eval (cur-mode-line--flycheck-num-errors 'info 'cur-mode-line-flycheck-info)))
  "Indicator for flycheck errors.")

(format-mode-line cur-mode-line-flycheck-indicator)

;;;;; Add Variables To Risky
(dolist (var '(cur-mode-line-right-align
	       cur-mode-line-end-padding
	       cur-mode-line-kmacro-indicator
	       cur-mode-line-narrowed-indicator
	       cur-mode-line-meow-state-indicator
	       cur-mode-line-buffer-status-indicator
	       cur-mode-line-buffer-name-indicator
	       cur-mode-line-major-mode-indicator
	       cur-mode-line-postion-indicator
	       cur-mode-line-flycheck-indicator
	       cur-mode-line-eat-indicator
	       cur-mode-line-eat-eshell-indicator))
  (put var 'risky-local-variable t))

(provide 'cur-mode-line)
;;; cur-mode-line.el ends here
#+end_src

** Dired Extensions (=cur-dired.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-dired.el
:END:

#+begin_src emacs-lisp
;;; cur-dired.el --- My extensions to dired -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

;;;###autoload
(defun cur-dired-maybe-insert-subdir-or-find-file (&optional other-window)
  (interactive "P")
  (let ((file (dired-get-file-for-visit)))
    (if (file-directory-p file)
	(if other-window
	    (dired-other-window file)
	  (dired-maybe-insert-subdir file nil t))
      (if other-window
	  (find-file-other-window file)
	(dired--find-possibly-alternative-file file)))))

;;;###autoload
(defun cur-dired-find-file-dwim (&optional other-window)
  (interactive "P")
  (let* ((file (dired-get-file-for-visit)))
    (if (file-directory-p file)
	(or (when other-window
	      (progn
		(dired-other-window file)	
		(dired-goto-file file)))
	    (when (and (cdr dired-subdir-alist)
		       (dired-goto-subdir file))
	      (when dired-trivial-filenames
		(dired-goto-next-nontrivial-file))
	      (run-hooks 'dired-initial-position-hook)
	      t)
	    (dired--find-possibly-alternative-file file))
      (progn
	(if other-window
	    (dired-find-file-other-window file)
	  (dired--find-possibly-alternative-file file))))))

(provide 'cur-dired)
;;; cur-dired.el ends here

#+end_src

** Eshell aliases and extensions (=cur-eshell.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-eshell.el
:END:

#+begin_src emacs-lisp
;;; cur-eshell.el --- My exensions of the Emacs Shell -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'eshell)
(require 'files)
(require 'dired)

(defun cur-eshell-prompt ()
  "A minimal and colourful prompt for `eshell'.
Set `eshell-prompt-function' to this function to enable."
  (let* ((red     (face-foreground 'ansi-color-red))
         (green   (face-foreground 'ansi-color-green))
         (yellow  (face-foreground 'ansi-color-yellow))
         (blue    (face-foreground 'ansi-color-blue))
         (magenta (face-foreground 'ansi-color-magenta))
         (cyan    (face-foreground 'ansi-color-cyan))
         (white   (face-foreground 'ansi-color-white)))
    (concat
     (propertize "["                   'face `(:weight bold :foreground ,red))
     (propertize (eshell/whoami)       'face `(:weight bold :foreground ,yellow))
     (propertize "@"                   'face `(:weight bold :foreground ,green))
     (propertize (system-name)         'face `(:weight bold :foreground ,blue))
     " "
     (propertize (concat (abbreviate-file-name (eshell/pwd))) 'face `(:weight bold :foreground ,magenta))
     (propertize "]"                   'face `(:weight bold :foreground ,red))
     (propertize "λ "                  'face `(:weight bold :foreground ,white)))))

(defun eshell/i (fn)
  "Call FN interactively.
FN should be a string."
  (let ((user-fn (intern-soft fn)))
    (cond ((and user-fn (commandp user-fn))
	   (call-interactively user-fn))
	  (user-fn
	   (user-error "Function is not an interactive function"))
	  (t
	   (user-error "There was no function with that name")))))

(defun eshell/ff (&optional file)
  "Eshell alias to open FILE.
Will call `find-file' interactively if no file is specified."
  (cond (file
         (find-file file))
        (t
         (call-interactively 'find-file))))

(defun eshell/lf (&optional dir)
  "Eshell alias to open `dired' at DIR.
Will call `dired' on current directory if no directory is specified."
  (cond (dir
         (dired dir))
        (t
         (dired "."))))

(defvar cur-eshell-prompt-regexp
  "^\\[.*?@.*? [/~].*\\]?[#$λ] "
  "Regex for the `cur-eshell-prompt' prompt.")

(provide 'cur-eshell)
;;; cur-base.el ends here
#+end_src

** Meow Extension (=cur-meow.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-meow.el
:END:

#+begin_src emacs-lisp
;;; cur-meow.el --- Extending Meow's Capabilities -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:
(require 'meow)

(defun cur-meow-toggle-temp-normal-motion ()
  "Toggle normal and motion mode.
If in neither of the two states, return nil."
  (interactive)
  (cond ((meow-normal-mode-p) (call-interactively 'meow-motion-mode))
        ((meow-motion-mode-p) (call-interactively 'meow-normal-mode))
        (t nil)))

(provide 'cur-meow)
;;; cur-meow.el ends here
#+end_src

** Theme Helpers (=cur-theme.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-theme.el
:END:

#+begin_src emacs-lisp
;;; cur-theme.el --- Helper functions for theming -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:

(require 'cl-lib)

(defgroup cur-theme nil
  "A themeing library for creating simple and extensible themes."
  :group 'faces)

(defgroup cur-override-theme nil
  "A theme that will conditionally override aspects of your current theme."
  :group 'cur-theme)

(defvar cur-theme--default-face-defs
  '(())
  "The default definitions for theme faces.")

(defun cur-theme-name-to-rgb (color)
  "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")
for FRAME (defaults to the current frame)."
  (cl-loop with div = (float (car (tty-color-standard-values "#ffffff")))
           for x in (tty-color-standard-values (downcase color))
           collect (/ x div)))

(defun cur-theme-blend (color1 color2 alpha)
  "Blend COLOR1 with COLOR2 with ALPHA.
Both COLOR1 and COLOR2 must be strings in hexidecimal form, prepended
with a \"#\"."
  (if (and (string-prefix-p "#" color2) (string-prefix-p "#" color2))
      (apply (lambda (r g b) (format "#%02x%02x%02x" (* r 255) (* g 255) (* b 255)))
             (cl-loop for it    in (cur-theme-name-to-rgb color1)
                      for other in (cur-theme-name-to-rgb color2)
                      collect (+ (* alpha it) (* other (- 1 alpha)))))
    (error "No \"#\" prefix for \"%s\" and \"%s\"" color2 color2)))

(defun cur-theme-lighten (color alpha)
  "Blend COLOR with \"#FFFFFF\" and ALPHA."
  (cur-theme-blend color "#FFFFFF" (- 1 alpha)))

(defun cur-theme-darken (color alpha)
  "Blend COLOR with \"#000000\" and ALPHA."
  (cur-theme-blend color "#000000" (- 1 alpha)))

(defvar cur-theme--schema-names
  '(base00
    base01
    base02))

(defun cur-theme--check-default-schema (colors)
  "Take COLORS and check if it has all of the default schema values defined.
The names of the default schema are in `cur-theme--schema-names'.
Note, this will not check recursively defined colors.  For example, something
like ((thing1 thing2) (thing2 thing1)) will be considered valid."
  (let ((color-names (mapcar (lambda (x) (car x)) colors)))
    (dolist (color-name cur-theme--schema-names)
      (unless (member color-name color-names)
        (error "Color %s is not defined in theme" color-name)))
    (dolist (color colors)
      (unless (equal (length color) 2)
        (error "Color %s has several definitions" (car color)))
      (let ((name (car color))
            (value (car (last color))))
        (cond ((stringp value)
               (unless (equal (length value) 7)
                 (error "Color %s's value is too long: %s" name value))
               (unless (string-match-p (rx "#" (repeat 6 (any "A-F" "a-f" "0-9"))) value)
                 (error "Color %s does not have a proper hex value: %s" name value)))
              ((symbolp value)
               (unless (member value color-names)
                 (error "Color %s references a nondefined color %s" name value)))
              (t
               (error "Color %s has nonsensical definition %s" name value)))))))

(defun cur-theme--expand-faces (face-defs)
  "Take FACE-DEFS and return faces that can be used by `custom-theme-set-faces'."
  (mapcar
   (lambda (face-def)
     (let* ((face (car face-def))
            (def  (cdr face-def)))
       `(list ',face ,`(list (list t (list ,@def))))))
   face-defs))

(defun cur-theme--get-face (face-name face-defs)
  "Return face-def with FACE-NAME in FACE-DEFS.
FACE-NAME should be a symbol."
  (cl-loop for face-def in face-defs
           when (equal face-name (car face-def))
           return face-def))

(defun cur-theme--merge-faces (prev-list new-list)
  "Take PREV-LIST of face defs and overlay NEW-LIST on top."
  (let (overridden)
    (setq overridden prev-list)
    (dolist (face-override new-list)
      (let ((face (car face-override))
            (definition (cdr face-override)))
        (if (assoc face overridden)
            (setcdr (cur-theme--get-face face overridden) definition)
          (push face-override overridden))))
    overridden))

(defun cur-theme--option-plist-get (plist prop default)
  "Get PROP from PLIST if PLIST has PROP, otherwise returning DEFAUlT."
  (if (plist-member plist prop)
      (plist-get plist prop)
    default))

(defmacro cur-theme-def (theme-name doc options-plist colors &rest faces)
  "Generate custom theme named THEME-NAME.
DOC is the documentation string.
OPTIONS-PLIST is an plist of optionional parameters that change the behavior of
different parts of the macro.  They are as follows:
,* :merge - When t, merge FACES with `cur-theme--default-face-defs'.  When nil,
  do not perform any merging.  Defaults to t.
,* :color-check - When set to t, check COLORS for conforming to schema.  When
  nil preform no checks.  Defaults to t.

COLORS is a list of lists, where the first element is a symbol and the second is
a string that is the hex value of the color or the name of another color in the
list.  COLORS must define all names in `cur-theme--schema-names' are defined.
OPTIONS-PLIST will affect this behavior.

FACES is a list of faces in the form (FACE PROPERTIES).  For example, (bold
:background bg :foreground fg :weight \\='bold).  OPTIONS-PLIST will affect
this behavior."
  (declare (indent 1))
  (let* ((merge (cur-theme--option-plist-get options-plist :merge t))
         (color-check (cur-theme--option-plist-get options-plist :color-check t)))
    (cond (color-check
           (cur-theme--check-default-schema colors))
          (t (when (eq merge t)
               (warn "Theme defined with no default schema but still merges with default faces defs which require the default schema"))))

    `(let* (,@colors)
       (deftheme ,theme-name
         ,doc)
       ,(unless (and (equal (length faces) 1)
                     (equal (car faces) nil))
          `(custom-theme-set-faces
            ',theme-name
            ,@(if merge
                  (cur-theme--expand-faces
                   (cur-theme--merge-faces cur-theme--default-face-defs faces))
		(cur-theme--expand-faces faces)))))))

(defcustom cur-override-theme-overrides
  '((doom-gruvbox (secondary-selection :background "#504945")))
  "The overrides for cur-override-theme."
  :group 'cur-override-theme
  :type '(alist :key-type symbol :value-type sexp))

(defcustom cur-override-theme-theme-priority
  'single
  "The priority for which theme has its overrides applied.
`first' means apply the override of the first theme if it has one.  `last' means
apply the override of the last theme if it has one.  `single' means expect only
a single theme to be enabled and signal a user error if multiple are enabled."
  :group 'cur-override-theme
  :type '(choice (const :tag "Use First Enabled Theme" first)
                 (const :tag "Use Last Enabled Theme" last)
                 (const :tag "Expect a Single Enabled Theme" single)))

(defun cur-theme--get-overrides (theme)
  "Return the overrides for THEME from `cur-override-theme-overrides'."
  (cdr (assoc theme cur-override-theme-overrides)))

(defmacro cur-override-theme-def ()
  "Define the override theme."
  (let ((overrides
         (cond ((eq cur-override-theme-theme-priority 'single)
                (when (> (length custom-enabled-themes) 1)
                  (user-error "More than one theme enabled.
Please disable all but one theme or change the value of `cur-override-theme-theme-priority'"))
                (cur-theme--get-overrides (car custom-enabled-themes)))
	       ((eq cur-override-theme-theme-priority 'first)
		(cur-theme--get-overrides (car (last custom-enabled-themes))))
               ((eq cur-override-theme-theme-priority 'last)
                (cur-theme--get-overrides (car custom-enabled-themes))))))
    `(cur-theme-def cur-override
       "A theme to override defintions another theme."
       ( :merge nil
         :color-check nil)
       nil
       ,@ (if overrides
              overrides
            '(nil)))))

(defun cur-theme-load-theme (theme)
  "Load THEME, disabling all other currently enabled themes."
  (interactive
   (list
    (intern (completing-read "Custom Themes: "
                             (mapcar #'symbol-name
                                     (custom-available-themes))))))
  (condition-case nil
      (progn
        (mapc #'disable-theme custom-enabled-themes)
        (load-theme theme t)
	(load-theme 'cur-override t))
    (error "Problem loading theme %s" theme)))

(defcustom cur-override-theme-load-function
  #'cur-theme-load-theme
  "The function to set a theme or themes."
  :group 'cur-override-theme
  :type '(function))

(defun cur-override-theme-load-theme (theme)
  "Load a THEME and then load the `cur-override' theme.
If THEME is nil then call interactively the function
`cur-override-theme-load-function'."
  (interactive (list nil))
  (if theme
      (cur-theme-load-theme theme)
    (call-interactively cur-override-theme-load-function))
  (load-theme 'cur-override t))

(provide 'cur-theme)
;;; cur-theme.el ends here
#+end_src

#+begin_src emacs-lisp :tangle ./themes/cur-override-theme.el
;;; cur-override-theme.el --- Theme that will override other themes -*- lexical-binding: t -*-

;;; Commentary:
;;

;;; Code:
(require 'cur-theme)

(cur-override-theme-def)

(provide 'cur-override)
;; cur-override-theme.el ends here
#+end_src

** Wallpaper Functions (=cur-wallpaper.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-wallpaper.el
:END:

#+begin_src emacs-lisp
;;; cur-wallpaper.el --- Setting wallpaper through dired -*- lexical-binding: t -*-

;;; Commentary:

;;; Code:

(require 'dired)
(require 'image-dired)

(defun cur-wallpaper-set-wallpaper (arg)
  "Set wallpaper as ARG."
  (interactive (list (image-dired-original-file-name)))
  (call-process-shell-command
   (concat "swww img -t any " arg " &")))

(defun cur-wallpaper-set-wallpaper-dired (arg)
  "Set wallpaper as ARG."
  (interactive (list (dired-get-filename)))
  (call-process-shell-command
   (concat "swww img -t any " arg " &")))

(provide 'cur-wallpaper)
;;; cur-wallpaper.el ends here
#+end_src

** Window Management (=cur-window.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-window.el
:END:

#+begin_src emacs-lisp
;;; cur-window.el --- Customization and helper functions for window management -*- lexical-binding: t -*-

;;; Commentary:
;; Custom functions and variables for managing windows.  In particular, setting `display-buffer-alist'
;; so that windows are just placed how I want.
;;
;; Much of this was shamelessly stolen from Protesilaos Stavrou, who greatly inspired much of my config.
;; Please see https://protesilaos.com/emacs/dotemacs#h:35b8a0a5-c447-4301-a404-bc274596238d for his window
;; management section of his Emacs config.

;;; Code:

(defun cur-window--window-small-p ()
  "Return non-nil if window is small.
Check if the `window-width' or `window-height' is less than
`split-width-threshold' and `split-height-threshold',
respectively."
  (or (and (numberp split-width-threshold)
           (< (window-total-width) split-width-threshold))
      (and (numberp split-height-threshold)
           (> (window-total-height) split-height-threshold))))

(defun cur-window--three-or-more-windows-p (&optional frame)
  "Return non-nil if three or more windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (>= (length (window-list frame :no-minibuffer)) 3))

(defun cur-window--get-display-buffer-below-or-pop ()
  "Return list of functions for `cur-window-display-buffer-below-or-pop'."
  (list
   #'display-buffer-reuse-mode-window
   (if (or (cur-window--window-small-p)
           (cur-window--three-or-more-windows-p))
       #'display-buffer-below-selected
     #'display-buffer-pop-up-window)))

(defun cur-window-display-buffer-below-or-pop (&rest args)
  "Display buffer below current window or pop a new window.
The criterion for choosing to display the buffer below the
current one is a non-nil return value for
`prot-common-window-small-p'.

Apply ARGS expected by the underlying `display-buffer' functions.

This as the action function in a `display-buffer-alist' entry."
  (let ((functions (cur-window--get-display-buffer-below-or-pop)))
    (catch 'success
      (dolist (fn functions)
        (when (apply fn args)
          (throw 'success fn))))))

(defvar cur-window-window-sizes
  '( :max-height (lambda () (floor (frame-height) 3))
     :min-height 10
     :max-width (lambda () (floor (frame-width) 3))
     :min-width 20)
  "This is a property list of max and min values for window sizes.
This value is used by `cur-window-select-fit-to-size' to set the
size of the window.")

(defun cur-window--get-window-size (key)
  "Use KEY to extract the value from `cur-window-window-sizes'.
If the value is a number return it, if it is a function, call
it and return it's value."
  (when-let ((value (plist-get cur-window-window-sizes key)))
    (cond
     ((functionp value)
      (funcall value))
     ((numberp value)
      value)
     (t
      (error "The value of %s is not a number or function" key)))))

(defun cur-window-select-fit-to-size (window)
  "Select WINDOW and fit it to the buffer.
The minimum and maximum height and width is determined by
`cur-window-window-sizes'."
  (select-window window)
  (fit-window-to-buffer
   window
   (cur-window--get-window-size :max-height)
   (cur-window--get-window-size :min-height)
   (cur-window--get-window-size :max-width)
   (cur-window--get-window-size :min-width)))

(defvar cur-window-same-window-modes-list
  '(justl-mode)
  "List of major modes that should have their window reused.
The function `cur-window-display-buffer-below-or-pop' uses this variable to
determine if it will create a new window or reuse the current one.")

(defun cur-window--get-display-buffer-same-window-or-below ()
  "Return a list of functions for `cur-window-display-buffer-same-window-or-below'."
  (list
   #'display-buffer-reuse-window
   (if (memq major-mode cur-window-same-window-modes-list)
       #'display-buffer-same-window
     #'display-buffer-below-selected)))

(defun cur-window-display-buffer-same-window-or-below (&rest args)
  "Display buffer either reusing the current window or bellow."
  (let ((functions (cur-window--get-display-buffer-same-window-or-below)))
    (catch 'success
      (dolist (fn functions)
        (when (apply fn args)
          (throw 'success fn))))))

(provide 'cur-window)
;;; cur-window.el ends here
#+end_src

** Vterm extension (=cur-vterm.el=)
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./cur-lisp/cur-vterm.el
:END:

#+begin_src emacs-lisp
;;; cur-vterm.el --- Customization and helper functions for vterm

;;; Commentary:

;;; Code:

(require 'vterm)

(defun cur-vterm-enter-password ()
  (declare (interactive-only t))
  (interactive)
  (unless (equal major-mode 'vterm-mode)
    (user-error "Not in a VTerm Terminal"))
  (vterm-insert (read-passwd "Password: "))
  (vterm-send-return))

(defun cur-vterm-project (&optional other-window)
  (interactive)
  (if-let* ((current-project (project-current))
            (default-directory (project-root current-project))
            (buffer-name (format "*%s-%s*" (project-name current-project) "vterm")))
      (if (buffer-live-p (get-buffer buffer-name))
          (if other-window
              (switch-to-buffer-other-window buffer-name)
            (switch-to-buffer buffer-name))
        (if other-window
            (vterm-other-window buffer-name)
          (vterm buffer-name)))
    (user-error "Cannot create vterm buffer in %s" (cdr current-project))))

(defun cur-vterm-project-other-window ()
  (interactive)
  (cur-vterm-project t))

(provide 'cur-vterm)
;;; cur-vterm.el ends here
#+end_src

* Themes
** Gruvbox
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

#+begin_src emacs-lisp
;;; cur-gruvbox-theme.el --- My custom gruvbox theme

;;; Commentary:

;;; Code:

(require 'cur-theme)

;; (add-to-list 'custom-theme-load-path (locate-user-emacs-file "/home/recur/cfg/home/programs/emacs/themes"))
;; (load-theme 'cur-gruvbox t)

(defun cur-theme-name-to-rgb (color)
  "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")
for FRAME (defaults to the current frame)."
  (cl-loop with div = (float (car (tty-color-standard-values "#ffffff")))
           for x in (tty-color-standard-values (downcase color))
           collect (/ x div)))

(defun cur-theme-blend (color1 color2 alpha)
  ""
  (if (and (string-prefix-p "#" color2) (string-prefix-p "#" color2))
      (apply (lambda (r g b) (format "#%02x%02x%02x" (* r 255) (* g 255) (* b 255)))
             (cl-loop for it    in (cur-theme-name-to-rgb color1)
                      for other in (cur-theme-name-to-rgb color2)
                      collect (+ (* alpha it) (* other (- 1 alpha)))))
    (error "No \"#\" prefix for \"%s\" and \"%s\"" color2 color2)))

(defun cur-theme-lighten (color alpha)
  ""
  (cur-theme-blend color "#FFFFFF" (- 1 alpha)))

(defun cur-theme-darken (color alpha)
  ""
  (cur-theme-blend color "#000000" (- 1 alpha)))

(deftheme cur-gruvbox
  "Asdf.")

(let* (
       ;; Normal colours
       (red        "#cc241d")
       (green      "#98971a")
       (yellow     "#d79921")
       (blue       "#458588")
       (purple     "#b16286")
       (aqua       "#689d6a")
       (orange     "#d65d0e")

       ;; Bright colours
       (light-red        "#fb4934")
       (light-green      "#b8bb26")
       (light-yellow     "#fabd2f")
       (light-blue       "#83a598")
       (light-purple     "#d3869b")
       (light-aqua       "#8ec07c")
       (light-orange     "#fe8019")

       ;; Colored Background
       (bg-red    (cur-theme-blend "#cc241d" "#282828" 0.1)) ; red
       (bg-green  (cur-theme-blend "#b8bb26" "#282828" 0.1)) ; light-green
       (bg-yellow (cur-theme-blend "#fabd2f" "#282828" 0.1)) ; light-yellow
       (bg-blue   (cur-theme-blend "#83a598" "#282828" 0.1)) ; light-blue
       (bg-purple (cur-theme-blend "#d3869b" "#282828" 0.1)) ; light-purple
       (bg-aqua   (cur-theme-blend "#8ec07c" "#282828" 0.1)) ; light-aqua
       (bg-orange (cur-theme-blend "#fe8019" "#282828" 0.1)) ; light-orange

       ;; Pale Colors
       (pale-red    (cur-theme-blend "#cc241d" "#ebdbb2" 0.6))
       (pale-green  (cur-theme-blend "#b8bb26" "#ebdbb2" 0.6))
       (pale-yellow (cur-theme-blend "#fabd2f" "#ebdbb2" 0.6))
       (pale-blue   (cur-theme-blend "#83a598" "#ebdbb2" 0.6))
       (pale-purple (cur-theme-blend "#d3869b" "#ebdbb2" 0.6))
       (pale-aqua   (cur-theme-blend "#8ec07c" "#ebdbb2" 0.6))
       (pale-orange (cur-theme-blend "#fe8019" "#ebdbb2" 0.6))

       ;; Background colours
       (bg-sp1   "#0d1011")
       (bg0h     "#1d2021") ;; Darkest
       (bg0      "#282828") ;; Default bg
       (bg0s     "#32302f")
       (bg1      "#3c3836")
       (bg2      "#504945")
       (bg3      "#665c54")
       (bg4      "#7c6f64")
       (grey     "#928374") ;; Lightest

       ;; Foreground colours
       (fg4     "#a89984") ;; Darkest
       (fg3     "#bdae93")
       (fg2     "#d5c4a1")
       (fg1     "#ebdbb2") ;; Default fg
       (fg0     "#fbf1c7") ;; Lightest
       )
  (custom-theme-set-faces
   'cur-gruvbox
   `(default             ((t (:foreground ,fg1 :background ,bg0))))
   `(success             ((t (:foreground ,light-green))))
   `(warning             ((t (:foreground ,light-yellow))))
   `(error               ((t (:foreground ,light-red))))
   `(link                ((t (:foreground ,light-aqua :underline t :weight bold))))
   `(link-visited        ((t (:foreground ,aqua :underline t :weight bold))))
   `(cursor              ((t (:background ,fg0))))
   `(fringe              ((t (:distant-foreground ,fg1 :background ,bg0))))
   `(region              ((t (:background ,bg3))))
   `(highlight           ((t (:foreground ,bg-sp1 :distant-foreground ,fg0 :background ,light-yellow))))
   `(hl-line             ((t (:background ,bg1))))
   `(header-line         ((t (:inherit (mode-line)))))
   `(vertical-border     ((t (:foreground ,bg0 :background ,bg0))))
   `(secondary-selection ((t (:background ,bg2))))
   `(query-replace       ((t (:inherit isearch))))
   `(minibuffer-prompt   ((t (:foreground ,aqua))))
   `(tooltip             ((t (:foreground ,fg1 :background ,bg0h))))
   `(shadow              ((t (:foreground ,bg4))))

   ;; Font Lock Faces

   `(font-lock-builtin-face           ((t (:foreground ,light-orange))))
   `(font-lock-comment-face           ((t (:foreground ,grey :slant italic))))
   `(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
   `(font-lock-doc-face               ((t (:foreground ,fg2))))
   `(font-lock-function-name-face     ((t (:foreground ,light-green))))
   `(font-lock-function-call-face     ((t (:inherit font-lock-function-name-face))))
   `(font-lock-keyword-face           ((t (:foreground ,light-red))))
   `(font-lock-preprocessor-face      ((t (:foreground ,fg1 :weight bold))))
   `(font-lock-string-face            ((t (:foreground ,light-green))))
   `(font-lock-type-face              ((t (:foreground ,light-yellow))))
   `(font-lock-constant-face          ((t (:foreground ,light-purple))))
   `(font-lock-variable-name-face     ((t (:foreground ,light-blue))))
   `(font-lock-warning-face           ((t (:inherit warning))))
   `(font-lock-negation-char-face     ((t (:foreground ,fg1 :weight bold))))
   `(font-lock-number-face            ((t (:foreground ,light-purple))))

   ;; Mode Line

   `(mode-line           ((t (:background ,bg1))))
   `(mode-line-active    ((t (:inherit mode-line))))
   `(mode-line-emphasis  ((t (:foreground ,light-blue :distant-foreground ,bg4))))
   `(mode-line-inactive  ((t (:foreground ,bg4 :background ,bg0s))))
   `(mode-line-buffer-id ((t (:weight bold))))

   ;; Line Number

   `(line-number              ((t (:foreground ,bg4 :background ,bg0 :inherit default :slant italic :weight normal))))
   `(line-number-current-line ((t (:foreground ,light-yellow :background ,bg1 :inherit (hl-line default) :slant italic :weight normal))))

   ;; Isearch

   `(isearch         ((t (:foreground ,bg0h :background ,light-orange))))
   `(isearch-fail    ((t (:foreground ,fg0 :background ,light-red))))
   `(isearch-group-1 ((t (:foreground ,bg0h :background ,light-orange))))
   `(isearch-group-2 ((t (:foreground ,bg0h :background ,orange))))
   `(lazy-highlight  ((t (:foreground ,bg0h :background ,light-yellow))))

;;; Minibuffer and Completions

   ;; Match and Completions

   `(match                   ((t (:foreground ,pale-orange :background ,bg-orange))))
   `(completions-common-part ((t (:foreground ,pale-aqua :background ,bg-aqua))))

   ;; Orderless

   `(orderless-match-face-0 ((t (:foreground ,pale-blue :background ,bg-blue))))
   `(orderless-match-face-1 ((t (:foreground ,pale-red :background ,bg-red))))
   `(orderless-match-face-2 ((t (:foreground ,pale-green :background ,bg-green))))
   `(orderless-match-face-3 ((t (:foreground ,pale-yellow :background ,bg-yellow))))

   ;; Vertico

   `(vertico-current         ((t (:background ,bg2))))
   `(vertico-group-separator ((t (:strike-through t :inherit (shadow)))))
   `(vertico-group-title     ((t (:slant italic :inherit (shadow)))))
   `(vertico-multiline       ((t (:inherit (shadow)))))

   ;; Vertico Posframe

   `(vertico-posframe                 ((t (:inherit (default)))))
   `(vertico-posframe-border          ((t (:background ,grey))))
   `(vertico-posframe-border-2        ((t (:background ,light-red))))
   `(vertico-posframe-border-3        ((t (:background ,light-green))))
   `(vertico-posframe-border-4        ((t (:background ,light-blue))))
   `(vertico-posframe-border-fallback ((t (:background ,light-yellow))))


;;; Terminal and Shell Colors

   ;; Ansi Colors

   `(ansi-color-black          ((t (:foreground ,bg0h :background ,bg0h))))
   `(ansi-color-red            ((t (:foreground ,light-red :background ,light-red))))
   `(ansi-color-green          ((t (:foreground ,light-green :background ,light-green))))
   `(ansi-color-yellow         ((t (:foreground ,light-yellow :background ,light-yellow))))
   `(ansi-color-blue           ((t (:foreground ,light-blue :background ,light-blue))))
   `(ansi-color-magenta        ((t (:foreground ,light-purple :background ,light-purple))))
   `(ansi-color-cyan           ((t (:foreground ,light-aqua :background ,light-aqua))))
   `(ansi-color-white          ((t (:foreground ,fg4 :background ,fg4))))
   `(ansi-color-bright-black   ((t (:foreground ,grey :background ,grey))))
   `(ansi-color-bright-red     ((t (:foreground ,light-red :background ,light-red))))
   `(ansi-color-bright-green   ((t (:foreground ,light-green :background ,light-green))))
   `(ansi-color-bright-yellow  ((t (:foreground ,light-yellow :background ,light-yellow))))
   `(ansi-color-bright-blue    ((t (:foreground ,light-blue :background ,light-blue))))
   `(ansi-color-bright-magenta ((t (:foreground ,light-purple :background ,light-purple))))
   `(ansi-color-bright-cyan    ((t (:foreground ,light-aqua :background ,light-aqua))))
   `(ansi-color-bright-white   ((t (:foreground ,fg1 :background ,fg1))))

;;; Programming Auxiliary

   ;; Paren Mode

   `(show-paren-match            ((t (:background ,bg4))))
   `(show-paren-match-expression ((t (:inherit show-paren-match))))
   `(show-paren-mismatch         ((t (:foreground ,fg0 :background ,light-red :weight bold))))

   ;; Rainbow Delimiters

   `(rainbow-delimiters-base-face       ((t (:inherit default))))
   `(rainbow-delimiters-base-error-face ((t (:foreground ,light-red :background ,bg0h))))
   `(rainbow-delimiters-unmatched-face  ((t (:foreground ,bg0h :background ,light-red :weight bold))))
   `(rainbow-delimiters-mismatched-face ((t (:inherit rainbow-delimiters-base-unmatched-face))))
   `(rainbow-delimiters-depth-1-face    ((t (:foreground ,light-orange))))
   `(rainbow-delimiters-depth-2-face    ((t (:foreground ,light-red))))
   `(rainbow-delimiters-depth-3-face    ((t (:foreground ,light-green))))
   `(rainbow-delimiters-depth-4-face    ((t (:foreground ,light-blue))))
   `(rainbow-delimiters-depth-5-face    ((t (:foreground ,light-aqua))))
   `(rainbow-delimiters-depth-6-face    ((t (:foreground ,light-purple))))
   `(rainbow-delimiters-depth-7-face    ((t (:foreground ,orange))))
   `(rainbow-delimiters-depth-8-face    ((t (:foreground ,red))))
   `(rainbow-delimiters-depth-9-face    ((t (:foreground ,green))))

   ;; Magit
   `(magit-branch-local ((t (:foreground ,light-aqua))))
   `(magit-section-heading ((t (:foreground ,light-aqua :bold t))))

;;; Languages and IDE Packages

   ;; Flycheck
   `(flycheck-error          ((t (:background ,bg1 :underline (:style wave :color ,light-red)))))
   `(flycheck-info           ((t (:background ,bg1 :underline (:style wave :color ,light-blue)))))
   `(flycheck-warning        ((t (:background ,bg1 :underline (:style wave :color ,light-yellow)))))
   `(flycheck-fringe-error   ((t (:inherit fringe :foreground ,light-red))))
   `(flycheck-fringe-info    ((t (:inherit fringe :foreground ,light-yellow))))
   `(flycheck-fringe-warning ((t (:inherit fringe :foreground ,light-green))))

   ;; Flyspell
   `(flyspell-duplicate ((t (:underline (:style wave :color ,light-yellow)))))
   `(flyspell-incorrect ((t (:underline (:style wave :color ,light-red)))))


;;; Internet Modes

   ;; Elpher

   `(elpher-binary                     ((t (:inherit (elpher-unknown)))))
   `(elpher-gemini                     ((t (:foreground ,light-aqua :weight normal :inherit (link)))))
   `(elpher-gemini-heading1            ((t (:foreground ,light-red :height 1.8 :inherit (default)))))
   `(elpher-gemini-heading2            ((t (:foreground ,light-yellow :height 1.4 :inherit (default)))))
   `(elpher-gemini-heading3            ((t (:foreground ,light-orange :height 1.2 :inherit (default)))))
   `(elpher-gemini-preformatted        ((t (:foreground ,grey :inherit (fixed-pitch)))))
   `(elpher-gemini-preformatted-toggle ((t (:inherit (button)))))
   `(elpher-gemini-quoted              ((t (:inherit (italic)))))
   `(elpher-html                       ((t (:inherit (elpher-other-url)))))
   `(elpher-image                      ((t (:inherit (elpher-other-url)))))
   `(elpher-index                      ((t (:foreground ,light-red))))
   `(elpher-info                       ((t (:inherit (elpher-text)))))
   `(elpher-margin-brackets            ((t (:inherit (bold)))))
   `(elpher-margin-key                 ((t (:inherit (shadow)))))
   `(elpher-other-url                  ((t (:foreground ,bg4 :slant italic))))
   `(elpher-search                     ((t (:foreground ,light-yellow))))
   `(elpher-telnet                     ((t (:inherit (elpher-unknown)))))
   `(elpher-text                       ((t (:inherit (bold)))))
   `(elpher-unknown                    ((t (:foreground ,bg4))))

   ;; Gemini

   `(gemini-heading-face-1    ((t (:foreground ,light-red :height 1.8 :inherit (default)))))
   `(gemini-heading-face-2    ((t (:foreground ,light-yellow :height 1.4 :inherit (default)))))
   `(gemini-heading-face-3    ((t (:foreground ,light-orange :height 1.2 :inherit (default)))))
   `(gemini-heading-face-rest ((t (:inherit (bold)))))
   `(gemini-preformatted-face ((t (:foreground ,grey :inherit (fixed-pitch)))))
   `(gemini-quote-face        ((t (:inherit (italic)))))
   `(gemini-ulist-face        ((t (:inherit (default)))))

;;; Org

   ;; Org General
   `(org-archived                 ((t (:foreground ,bg4))))
   `(org-block                    ((t (:background ,bg1 :extend t))))
   `(org-block-begin-line         ((t (:foreground ,grey :inherit (org-block)))))
   `(org-block-end-line           ((t (:inherit (org-block-begin-line)))))
   `(org-code                     ((t (:foreground ,light-orange :inherit org-block))))
   `(org-checkbox-statistics-done ((t (:inherit org-done))))
   `(org-checkbox-statistics-todo ((t (:inherit org-todo))))
   `(org-checkbox                 ((t (:inherit org-todo))))
   `(org-date                     ((t (:foreground ,light-green))))
   `(org-drawer                   ((t (:foreground ,(cur-theme-lighten light-aqua 0.4)))))
   `(org-done                     ((t (:inherit org-headline-done :weight bold))))
   `(org-ellipsis                 ((t (:foreground ,light-orange))))
   `(org-footnote                 ((t (:foreground ,light-orange))))
   `(org-formula                  ((t (:foreground ,light-green))))
   `(org-headline-done            ((t (:foreground ,bg4))))
   `(org-headline-todo            ((t (:foreground ,light-green))))
   `(org-link                     ((t (:foreground ,light-yellow :inherit link))))
   `(org-list-dt                  ((t (:foreground ,light-aqua))))
   `(org-meta-line                ((t (:foreground ,grey))))
   `(org-priority                 ((t (:foreground ,light-red))))
   `(org-property-value           ((t (:inherit default))))
   `(org-quote                    ((t (:foreground ,fg2  :inherit (italic org-block)))))
   `(org-special-keyword          ((t (:foreground ,(cur-theme-lighten light-aqua 0.15)))))
   `(org-table                    ((t (:foreground ,light-aqua))))
   `(org-tag                      ((t (:foreground ,bg4 :weight normal))))
   `(org-todo                     ((t (:inherit org-headline-todo :weight bold))))
   `(org-verbatim                 ((t (:foreground ,light-yellow))))

   ;; Outline N and Org Heading Levels
   `(outline-1 ((t (:foreground ,light-purple :weight bold :extend t))))
   `(outline-2 ((t (:foreground ,light-aqua :weight bold :extend t))))
   `(outline-3 ((t (:foreground ,light-green :weight bold :extend t))))
   `(outline-4 ((t (:foreground ,(cur-theme-lighten light-purple 0.2) :weight bold :extend t))))
   `(outline-5 ((t (:foreground ,(cur-theme-lighten aqua 0.25) :weight bold :extend t))))
   `(outline-6 ((t (:foreground ,(cur-theme-lighten light-purple 0.4) :weight bold :extend t))))
   `(outline-7 ((t (:foreground ,(cur-theme-lighten aqua 0.5) :weight bold :extend t))))
   `(outline-8 ((t (:foreground ,(cur-theme-lighten light-aqua 0.6) :weight bold :extend t))))

   `(nerd-icons-blue       ((t (:foreground ,light-blue))))
   `(nerd-icons-blue-alt   ((t (:foreground ,light-aqua))))
   `(nerd-icons-cyan       ((t (:foreground ,light-aqua))))
   `(nerd-icons-cyan-alt   ((t (:foreground ,light-aqua))))
   `(nerd-icons-dblue      ((t (:foreground ,blue))))
   `(nerd-icons-dcyan      ((t (:foreground ,aqua))))
   `(nerd-icons-dgreen     ((t (:foreground ,(cur-theme-darken light-green 0.3)))))
   `(nerd-icons-dmaroon    ((t (:foreground ,(cur-theme-darken red 0.3)))))
   `(nerd-icons-dorange    ((t (:foreground ,(cur-theme-darken light-orange 0.3)))))
   `(nerd-icons-dpink      ((t (:foreground ,(cur-theme-lighten light-red 0.15)))))
   `(nerd-icons-dpurple    ((t (:foreground ,(cur-theme-darken light-purple 0.3)))))
   `(nerd-icons-dred       ((t (:foreground ,(cur-theme-darken light-red 0.3)))))
   `(nerd-icons-dsilver    ((t (:foreground ,(cur-theme-lighten grey 0.1)))))
   `(nerd-icons-dyellow    ((t (:foreground ,(cur-theme-darken yellow 0.3)))))
   `(nerd-icons-green      ((t (:foreground ,light-green))))
   `(nerd-icons-lblue      ((t (:foreground ,(cur-theme-lighten light-blue 0.3)))))
   `(nerd-icons-lcyan      ((t (:foreground ,(cur-theme-lighten light-aqua 0.3)))))
   `(nerd-icons-lgreen     ((t (:foreground ,(cur-theme-lighten light-green 0.3)))))
   `(nerd-icons-lmaroon    ((t (:foreground ,(cur-theme-lighten red 0.3)))))
   `(nerd-icons-lorange    ((t (:foreground ,(cur-theme-lighten light-orange 0.3)))))
   `(nerd-icons-lpink      ((t (:foreground ,(cur-theme-lighten light-red 0.55)))))
   `(nerd-icons-lpurple    ((t (:foreground ,(cur-theme-lighten light-purple 0.3)))))
   `(nerd-icons-lred       ((t (:foreground ,(cur-theme-lighten light-red 0.3)))))
   `(nerd-icons-lsilver    ((t (:foreground ,(cur-theme-lighten grey 0.7)))))
   `(nerd-icons-lyellow    ((t (:foreground ,(cur-theme-lighten yellow 0.3)))))
   `(nerd-icons-maroon     ((t (:foreground ,red))))
   `(nerd-icons-orange     ((t (:foreground ,light-orange))))
   `(nerd-icons-pink       ((t (:foreground ,(cur-theme-lighten light-red 0.35)))))
   `(nerd-icons-purple     ((t (:foreground ,light-purple))))
   `(nerd-icons-purple-alt ((t (:foreground ,(cur-theme-blend light-purple grey 0.15)))))
   `(nerd-icons-red        ((t (:foreground ,light-red))))
   `(nerd-icons-red-alt    ((t (:foreground ,(cur-theme-blend light-red grey 0.15)))))
   `(nerd-icons-silver     ((t (:foreground ,(cur-theme-lighten grey 0.45)))))
   `(nerd-icons-yellow     ((t (:foreground ,yellow))))
   )
  )

(provide-theme 'cur-gruvbox)
;;; cur-gruvbox-theme.el ends here
#+end_src
